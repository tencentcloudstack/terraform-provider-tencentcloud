// Code generated by iacg; DO NOT EDIT.
package cynosdb

import (
	"context"
	"errors"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cynosdbv20190107 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cynosdb/v20190107"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudCynosdbBackupConfig() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudCynosdbBackupConfigCreate,
		Read:   resourceTencentCloudCynosdbBackupConfigRead,
		Update: resourceTencentCloudCynosdbBackupConfigUpdate,
		Delete: resourceTencentCloudCynosdbBackupConfigDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"cluster_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Cluster ID.",
			},

			"backup_time_beg": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: "Full backup start time. Value range: [0-24*3600]. For example, 0:00 AM, 1:00 AM, and 2:00 AM are represented by 0, 3600, and 7200, respectively.",
			},

			"backup_time_end": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: "Full backup end time. Value range: [0-24*3600]. For example, 0:00 AM, 1:00 AM, and 2:00 AM are represented by 0, 3600, and 7200, respectively.",
			},

			"reserve_duration": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: "Backup retention period in seconds. Backups will be cleared after this period elapses. 7 days is represented by 3600*24*7 = 604800. Maximum value: 158112000.",
			},

			"backup_freq": {
				Type: schema.TypeList,
				// Optional:    true,
				Computed:    true,
				Description: "Backup frequency. It is an array of 7 elements corresponding to Monday through Sunday. full: full backup; increment: incremental backup. This parameter cannot be modified currently and doesn't need to be entered.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"backup_type": {
				Type: schema.TypeString,
				// Optional:    true,
				Computed:    true,
				Description: "Backup mode. logic: logic backup; snapshot: snapshot backup. This parameter cannot be modified currently and doesn't need to be entered.",
			},

			"logic_backup_config": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "Logical backup configuration. Do not set this field if it is not enabled. Example value: [{\"LogicBackupEnable\": \"ON\",\"LogicBackupTimeBeg\": \"2023-04-24 15:06:04\",\"LogicBackupTimeEnd\": \"2024-04-24 15:06:04\",\"LogicReserveDuration\": \"60\",\"LogicCrossRegionsEnable\": \"ON\",\"LogicCrossRegions\": [\"ap-guangzhou\"]}].",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"logic_backup_enable": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Whether to enable automatic logical backup. Value: `ON`, `OFF`.",
						},
						"logic_backup_time_beg": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Automatic logical backup start time. When `logic_backup_enable` is `OFF`, it must be `0` or not entered. Example value: 2.",
						},
						"logic_backup_time_end": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Automatic logical backup end time. When `logic_backup_enable` is `OFF`, it must be `0` or not entered. Example value: 6.",
						},
						"logic_reserve_duration": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Automatic logical backup retention period. When `logic_backup_enable` is `OFF`, it must be `0` or not entered. Value range: [259200,158112000]. `logic_backup_enable` is `OFF`, `logic_reserve_duration` cannot be set when creating.",
						},
						"logic_cross_regions_enable": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Whether to enable cross-region logical backup. Cannot be input when `logic_backup_enable` is `OFF`. When `logic_backup_enable` is `ON`, `logic_cross_regions_enable` setting `ON` will take effect. Value: `ON`, `OFF`.",
						},
						"logic_cross_regions": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Logical backup across regions. Example value: [\"ap-guangzhou\"]. When `logic_backup_enable` is `OFF`, it must be `[]` or not entered.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudCynosdbBackupConfigCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cynosdb_backup_config.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		clusterId string
	)
	if v, ok := d.GetOk("cluster_id"); ok {
		clusterId = v.(string)
	}
	if logicBackupConfigMap, ok := helper.InterfacesHeadMap(d, "logic_backup_config"); ok {
		if v, ok := logicBackupConfigMap["logic_backup_enable"].(string); ok && v != "" {
			if v == "OFF" {
				return errors.New("`logic_backup_enable` is `OFF`, `logic_backup_config` cannot be set when creating.")
			}
		}
	}

	d.SetId(clusterId)

	return resourceTencentCloudCynosdbBackupConfigUpdate(d, meta)
}

func resourceTencentCloudCynosdbBackupConfigRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cynosdb_backup_config.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := CynosdbService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	clusterId := d.Id()

	respData, err := service.DescribeCynosdbBackupConfigById(ctx, clusterId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `cynosdb_backup_config` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}

	_ = d.Set("cluster_id", clusterId)

	if respData.BackupTimeBeg != nil {
		_ = d.Set("backup_time_beg", respData.BackupTimeBeg)
	}

	if respData.BackupTimeEnd != nil {
		_ = d.Set("backup_time_end", respData.BackupTimeEnd)
	}

	if respData.ReserveDuration != nil {
		_ = d.Set("reserve_duration", respData.ReserveDuration)
	}

	if respData.BackupFreq != nil {
		_ = d.Set("backup_freq", respData.BackupFreq)
	}

	if respData.BackupType != nil {
		_ = d.Set("backup_type", respData.BackupType)
	}

	logicBackupConfigMap := map[string]interface{}{}

	if respData.LogicBackupConfig != nil {
		if respData.LogicBackupConfig.LogicBackupEnable != nil {
			logicBackupConfigMap["logic_backup_enable"] = respData.LogicBackupConfig.LogicBackupEnable
		}

		if respData.LogicBackupConfig.LogicBackupTimeBeg != nil {
			logicBackupConfigMap["logic_backup_time_beg"] = respData.LogicBackupConfig.LogicBackupTimeBeg
		}

		if respData.LogicBackupConfig.LogicBackupTimeEnd != nil {
			logicBackupConfigMap["logic_backup_time_end"] = respData.LogicBackupConfig.LogicBackupTimeEnd
		}

		if respData.LogicBackupConfig.LogicReserveDuration != nil {
			logicBackupConfigMap["logic_reserve_duration"] = respData.LogicBackupConfig.LogicReserveDuration
		}

		if respData.LogicBackupConfig.LogicCrossRegionsEnable != nil {
			logicBackupConfigMap["logic_cross_regions_enable"] = respData.LogicBackupConfig.LogicCrossRegionsEnable
		}

		if respData.LogicBackupConfig.LogicCrossRegions != nil {
			logicBackupConfigMap["logic_cross_regions"] = respData.LogicBackupConfig.LogicCrossRegions
		}

		_ = d.Set("logic_backup_config", []interface{}{logicBackupConfigMap})
	}

	_ = clusterId
	return nil
}

func resourceTencentCloudCynosdbBackupConfigUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cynosdb_backup_config.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	clusterId := d.Id()

	needChange := false
	mutableArgs := []string{"backup_time_beg", "backup_time_end", "reserve_duration", "backup_freq", "backup_type", "logic_backup_config"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := cynosdbv20190107.NewModifyBackupConfigRequest()

		request.ClusterId = helper.String(clusterId)

		if v, ok := d.GetOkExists("backup_time_beg"); ok {
			request.BackupTimeBeg = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOkExists("backup_time_end"); ok {
			request.BackupTimeEnd = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOkExists("reserve_duration"); ok {
			request.ReserveDuration = helper.IntUint64(v.(int))
		}

		// if v, ok := d.GetOk("backup_freq"); ok {
		// 	backupFreqSet := v.([]interface{})
		// 	for i := range backupFreqSet {
		// 		backupFreq := backupFreqSet[i].(string)
		// 		request.BackupFreq = append(request.BackupFreq, helper.String(backupFreq))
		// 	}
		// }

		// if v, ok := d.GetOk("backup_type"); ok {
		// 	request.BackupType = helper.String(v.(string))
		// }

		if logicBackupConfigMap, ok := helper.InterfacesHeadMap(d, "logic_backup_config"); ok {
			logicBackupConfigInfo := cynosdbv20190107.LogicBackupConfigInfo{}
			if v, ok := logicBackupConfigMap["logic_backup_enable"].(string); ok && v != "" {
				logicBackupConfigInfo.LogicBackupEnable = helper.String(v)
			}
			if *logicBackupConfigInfo.LogicBackupEnable != "OFF" {
				if v, ok := logicBackupConfigMap["logic_backup_time_beg"].(int); ok {
					logicBackupConfigInfo.LogicBackupTimeBeg = helper.IntUint64(v)
				}
				if v, ok := logicBackupConfigMap["logic_backup_time_end"].(int); ok {
					logicBackupConfigInfo.LogicBackupTimeEnd = helper.IntUint64(v)
				}
				if v, ok := logicBackupConfigMap["logic_reserve_duration"].(int); ok {
					logicBackupConfigInfo.LogicReserveDuration = helper.IntUint64(v)
				}
				if v, ok := logicBackupConfigMap["logic_cross_regions_enable"].(string); ok && v != "" {
					logicBackupConfigInfo.LogicCrossRegionsEnable = helper.String(v)
				}
				if v, ok := logicBackupConfigMap["logic_cross_regions"]; ok {
					logicCrossRegionsSet := v.(*schema.Set).List()
					for i := range logicCrossRegionsSet {
						logicCrossRegions := logicCrossRegionsSet[i].(string)
						logicBackupConfigInfo.LogicCrossRegions = append(logicBackupConfigInfo.LogicCrossRegions, helper.String(logicCrossRegions))
					}
				}
			}

			request.LogicBackupConfig = &logicBackupConfigInfo
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseCynosdbClient().ModifyBackupConfigWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update cynosdb backup config failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	return resourceTencentCloudCynosdbBackupConfigRead(d, meta)
}

func resourceTencentCloudCynosdbBackupConfigDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_cynosdb_backup_config.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
