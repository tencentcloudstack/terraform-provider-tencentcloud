// Code generated by iacg; DO NOT EDIT.
package cdwdoris

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	cdwdorisv20211228 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cdwdoris/v20211228"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudCdwdorisInstances() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudCdwdorisInstancesRead,
		Schema: map[string]*schema.Schema{
			"search_instance_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The name of the cluster ID for the search.",
			},
			"search_instance_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The cluster name for the search.",
			},
			"search_tags": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Search tag list.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"tag_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Tag key.",
						},
						"tag_value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Tag value.",
						},
						"all_value": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "1 means only the tag key is entered without a value, and 0 means both the key and the value are entered.",
						},
					},
				},
			},
			// computed
			"instances_list": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Quantities of instances array.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"instance_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Cluster instance ID, `cdw-xxxx` string type. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"instance_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Cluster instance name. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"status": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Status,. Init is being created. Serving is running. Deleted indicates the cluster has been terminated. Deleting indicates the cluster is being terminated. Modify indicates the cluster is being changed. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Version. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"region": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Region, ap-guangzhou. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"zone": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Availability zone, ap-guangzhou-3. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"vpc_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "VPC name. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"subnet_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Subnet name. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"pay_mode": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Payment type: hour and prepay. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"create_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Creation time. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"expire_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Expiration time. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"master_summary": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Data node description information. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"spec": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Model, such as S1.",
									},
									"node_size": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Number of nodes.",
									},
									"core": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Number of CPU cores, in counts.",
									},
									"memory": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Memory size, in GB.",
									},
									"disk": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Disk size, in GB.",
									},
									"disk_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Disk type.",
									},
									"disk_desc": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Disk description.",
									},
									"attach_cbs_spec": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "Information of mounted cloud disks. Note: This field may return null, indicating that no valid values can be obtained.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disk_type": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Node disk type, such as CLOUD_SSD, CLOUD_PREMIUM.",
												},
												"disk_size": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Disk capacity, in GB.",
												},
												"disk_count": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Total number of disks.",
												},
												"disk_desc": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Description.",
												},
											},
										},
									},
									"sub_product_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Sub-product name. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"spec_core": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Specified cores. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"spec_memory": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Specified memory. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"disk_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Disk size. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"encrypt": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Whether it is encrypted.. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"max_disk_size": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Maximum disk. Note: This field may return null, indicating that no valid values can be obtained.",
									},
								},
							},
						},
						"core_summary": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Zookeeper node description information. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"spec": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Model, such as S1.",
									},
									"node_size": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Number of nodes.",
									},
									"core": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Number of CPU cores, in counts.",
									},
									"memory": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Memory size, in GB.",
									},
									"disk": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Disk size, in GB.",
									},
									"disk_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Disk type.",
									},
									"disk_desc": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Disk description.",
									},
									"attach_cbs_spec": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "Information of mounted cloud disks. Note: This field may return null, indicating that no valid values can be obtained.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disk_type": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Node disk type, such as CLOUD_SSD, CLOUD_PREMIUM.",
												},
												"disk_size": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Disk capacity, in GB.",
												},
												"disk_count": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Total number of disks.",
												},
												"disk_desc": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Description.",
												},
											},
										},
									},
									"sub_product_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Sub-product name. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"spec_core": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Specified cores. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"spec_memory": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Specified memory. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"disk_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Disk size. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"encrypt": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Whether it is encrypted.. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"max_disk_size": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Maximum disk. Note: This field may return null, indicating that no valid values can be obtained.",
									},
								},
							},
						},
						"ha": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "High availability, being true or false. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"ha_type": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "High availability type: 0: non-high availability. 1: read high availability. 2: read-write high availability. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"access_info": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Access address. Example: 10.0.0.1:9000. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"id": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Record ID, in numerical type. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"region_id": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Region ID, indicating the region. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"zone_desc": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Note about availability zone, such as Guangzhou Zone 2. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"flow_msg": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Error process description information. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"status_desc": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Status description, such as `running`. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"renew_flag": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Automatic renewal marker. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"tags": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Tag list. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"tag_key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Tag key.",
									},
									"tag_value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Tag value.",
									},
								},
							},
						},
						"monitor": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Monitoring Information. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"has_cls_topic": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Whether to enable logs. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"cls_topic_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Log Topic ID. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"cls_log_set_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Logset ID. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"enable_xml_config": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Whether to support XML configuration management. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"region_desc": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Region. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"eip": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Elastic network interface address. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"cos_move_factor": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Cold and hot stratification coefficient. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"kind": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "external/local/yunti. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"cos_bucket_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "COS bucket. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"can_attach_cbs": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "cbs. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"build_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Minor versions. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"components": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Component Information. Note: The return type here is map[string]struct, not the string type displayed. You can refer to Sample Value to parse the data. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"characteristic": {
							Type:        schema.TypeSet,
							Computed:    true,
							Description: "Page features, used to block some page entrances on the front end.. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"restart_timeout": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Timeout period, in seconds. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"grace_shutdown_wait_seconds": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The timeout time for the graceful restart of the kernel. If it is -1, it means it is not set.. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"case_sensitive": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Whether the table name is case sensitive, 0 refers to sensitive, 1 refers to insensitive, compared in lowercase; 2 refers to insensitive, and the table name is changed to lowercase for storage.. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"is_white_s_gs": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Whether users can bind security groups.. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"bind_s_gs": {
							Type:        schema.TypeSet,
							Computed:    true,
							Description: "Bound security group information. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"enable_multi_zones": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Whether it is a multi-AZ.. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"user_network_infos": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "User availability zone and subnet information. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"enable_cool_down": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Whether to enable hot and cold stratification. 0 refers to disabled, and 1 refers to enabled.. Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"cool_down_bucket": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "COS buckets are used for hot and cold stratification. Note: This field may return null, indicating that no valid values can be obtained.",
						},
					},
				},
			},
			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudCdwdorisInstancesRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_cdwdoris_instances.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId    = tccommon.GetLogId(nil)
		ctx      = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		service  = CdwdorisService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}
		respData []*cdwdorisv20211228.InstanceInfo
	)

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("search_instance_id"); ok {
		paramMap["SearchInstanceId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("search_instance_name"); ok {
		paramMap["SearchInstanceName"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("search_tags"); ok {
		searchTagsSet := v.([]interface{})
		tmpSet := make([]*cdwdorisv20211228.SearchTags, 0, len(searchTagsSet))
		for _, item := range searchTagsSet {
			searchTagsMap := item.(map[string]interface{})
			searchTags := cdwdorisv20211228.SearchTags{}
			if v, ok := searchTagsMap["tag_key"]; ok {
				searchTags.TagKey = helper.String(v.(string))
			}

			if v, ok := searchTagsMap["tag_value"]; ok {
				searchTags.TagValue = helper.String(v.(string))
			}

			if v, ok := searchTagsMap["all_value"]; ok {
				searchTags.AllValue = helper.IntInt64(v.(int))
			}

			tmpSet = append(tmpSet, &searchTags)
		}

		paramMap["SearchTags"] = tmpSet
	}

	err := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeCdwdorisInstancesByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}

		respData = result
		return nil
	})

	if err != nil {
		return err
	}

	ids := make([]string, 0, len(respData))
	tmpInstancesList := make([]map[string]interface{}, 0, len(respData))
	if respData != nil {
		for _, instancesList := range respData {
			instancesListMap := map[string]interface{}{}
			if instancesList.InstanceId != nil {
				instancesListMap["instance_id"] = instancesList.InstanceId
				ids = append(ids, *instancesList.InstanceId)
			}

			if instancesList.InstanceName != nil {
				instancesListMap["instance_name"] = instancesList.InstanceName
			}

			if instancesList.Status != nil {
				instancesListMap["status"] = instancesList.Status
			}

			if instancesList.Version != nil {
				instancesListMap["version"] = instancesList.Version
			}

			if instancesList.Region != nil {
				instancesListMap["region"] = instancesList.Region
			}

			if instancesList.Zone != nil {
				instancesListMap["zone"] = instancesList.Zone
			}

			if instancesList.VpcId != nil {
				instancesListMap["vpc_id"] = instancesList.VpcId
			}

			if instancesList.SubnetId != nil {
				instancesListMap["subnet_id"] = instancesList.SubnetId
			}

			if instancesList.PayMode != nil {
				instancesListMap["pay_mode"] = instancesList.PayMode
			}

			if instancesList.CreateTime != nil {
				instancesListMap["create_time"] = instancesList.CreateTime
			}

			if instancesList.ExpireTime != nil {
				instancesListMap["expire_time"] = instancesList.ExpireTime
			}

			masterSummaryMap := map[string]interface{}{}

			if instancesList.MasterSummary != nil {
				if instancesList.MasterSummary.Spec != nil {
					masterSummaryMap["spec"] = instancesList.MasterSummary.Spec
				}

				if instancesList.MasterSummary.NodeSize != nil {
					masterSummaryMap["node_size"] = instancesList.MasterSummary.NodeSize
				}

				if instancesList.MasterSummary.Core != nil {
					masterSummaryMap["core"] = instancesList.MasterSummary.Core
				}

				if instancesList.MasterSummary.Memory != nil {
					masterSummaryMap["memory"] = instancesList.MasterSummary.Memory
				}

				if instancesList.MasterSummary.Disk != nil {
					masterSummaryMap["disk"] = instancesList.MasterSummary.Disk
				}

				if instancesList.MasterSummary.DiskType != nil {
					masterSummaryMap["disk_type"] = instancesList.MasterSummary.DiskType
				}

				if instancesList.MasterSummary.DiskDesc != nil {
					masterSummaryMap["disk_desc"] = instancesList.MasterSummary.DiskDesc
				}

				attachCBSSpecMap := map[string]interface{}{}

				if instancesList.MasterSummary.AttachCBSSpec != nil {
					if instancesList.MasterSummary.AttachCBSSpec.DiskType != nil {
						attachCBSSpecMap["disk_type"] = instancesList.MasterSummary.AttachCBSSpec.DiskType
					}

					if instancesList.MasterSummary.AttachCBSSpec.DiskSize != nil {
						attachCBSSpecMap["disk_size"] = instancesList.MasterSummary.AttachCBSSpec.DiskSize
					}

					if instancesList.MasterSummary.AttachCBSSpec.DiskCount != nil {
						attachCBSSpecMap["disk_count"] = instancesList.MasterSummary.AttachCBSSpec.DiskCount
					}

					if instancesList.MasterSummary.AttachCBSSpec.DiskDesc != nil {
						attachCBSSpecMap["disk_desc"] = instancesList.MasterSummary.AttachCBSSpec.DiskDesc
					}

					masterSummaryMap["attach_cbs_spec"] = []interface{}{attachCBSSpecMap}
				}

				if instancesList.MasterSummary.SubProductType != nil {
					masterSummaryMap["sub_product_type"] = instancesList.MasterSummary.SubProductType
				}

				if instancesList.MasterSummary.SpecCore != nil {
					masterSummaryMap["spec_core"] = instancesList.MasterSummary.SpecCore
				}

				if instancesList.MasterSummary.SpecMemory != nil {
					masterSummaryMap["spec_memory"] = instancesList.MasterSummary.SpecMemory
				}

				if instancesList.MasterSummary.DiskCount != nil {
					masterSummaryMap["disk_count"] = instancesList.MasterSummary.DiskCount
				}

				if instancesList.MasterSummary.Encrypt != nil {
					masterSummaryMap["encrypt"] = instancesList.MasterSummary.Encrypt
				}

				if instancesList.MasterSummary.MaxDiskSize != nil {
					masterSummaryMap["max_disk_size"] = instancesList.MasterSummary.MaxDiskSize
				}

				instancesListMap["master_summary"] = []interface{}{masterSummaryMap}
			}

			coreSummaryMap := map[string]interface{}{}

			if instancesList.CoreSummary != nil {
				if instancesList.CoreSummary.Spec != nil {
					coreSummaryMap["spec"] = instancesList.CoreSummary.Spec
				}

				if instancesList.CoreSummary.NodeSize != nil {
					coreSummaryMap["node_size"] = instancesList.CoreSummary.NodeSize
				}

				if instancesList.CoreSummary.Core != nil {
					coreSummaryMap["core"] = instancesList.CoreSummary.Core
				}

				if instancesList.CoreSummary.Memory != nil {
					coreSummaryMap["memory"] = instancesList.CoreSummary.Memory
				}

				if instancesList.CoreSummary.Disk != nil {
					coreSummaryMap["disk"] = instancesList.CoreSummary.Disk
				}

				if instancesList.CoreSummary.DiskType != nil {
					coreSummaryMap["disk_type"] = instancesList.CoreSummary.DiskType
				}

				if instancesList.CoreSummary.DiskDesc != nil {
					coreSummaryMap["disk_desc"] = instancesList.CoreSummary.DiskDesc
				}

				attachCBSSpecMap := map[string]interface{}{}

				if instancesList.CoreSummary.AttachCBSSpec != nil {
					if instancesList.CoreSummary.AttachCBSSpec.DiskType != nil {
						attachCBSSpecMap["disk_type"] = instancesList.CoreSummary.AttachCBSSpec.DiskType
					}

					if instancesList.CoreSummary.AttachCBSSpec.DiskSize != nil {
						attachCBSSpecMap["disk_size"] = instancesList.CoreSummary.AttachCBSSpec.DiskSize
					}

					if instancesList.CoreSummary.AttachCBSSpec.DiskCount != nil {
						attachCBSSpecMap["disk_count"] = instancesList.CoreSummary.AttachCBSSpec.DiskCount
					}

					if instancesList.CoreSummary.AttachCBSSpec.DiskDesc != nil {
						attachCBSSpecMap["disk_desc"] = instancesList.CoreSummary.AttachCBSSpec.DiskDesc
					}

					coreSummaryMap["attach_cbs_spec"] = []interface{}{attachCBSSpecMap}
				}

				if instancesList.CoreSummary.SubProductType != nil {
					coreSummaryMap["sub_product_type"] = instancesList.CoreSummary.SubProductType
				}

				if instancesList.CoreSummary.SpecCore != nil {
					coreSummaryMap["spec_core"] = instancesList.CoreSummary.SpecCore
				}

				if instancesList.CoreSummary.SpecMemory != nil {
					coreSummaryMap["spec_memory"] = instancesList.CoreSummary.SpecMemory
				}

				if instancesList.CoreSummary.DiskCount != nil {
					coreSummaryMap["disk_count"] = instancesList.CoreSummary.DiskCount
				}

				if instancesList.CoreSummary.Encrypt != nil {
					coreSummaryMap["encrypt"] = instancesList.CoreSummary.Encrypt
				}

				if instancesList.CoreSummary.MaxDiskSize != nil {
					coreSummaryMap["max_disk_size"] = instancesList.CoreSummary.MaxDiskSize
				}

				instancesListMap["core_summary"] = []interface{}{coreSummaryMap}
			}

			if instancesList.HA != nil {
				instancesListMap["ha"] = instancesList.HA
			}

			if instancesList.HaType != nil {
				instancesListMap["ha_type"] = instancesList.HaType
			}

			if instancesList.AccessInfo != nil {
				instancesListMap["access_info"] = instancesList.AccessInfo
			}

			if instancesList.Id != nil {
				instancesListMap["id"] = instancesList.Id
			}

			if instancesList.RegionId != nil {
				instancesListMap["region_id"] = instancesList.RegionId
			}

			if instancesList.ZoneDesc != nil {
				instancesListMap["zone_desc"] = instancesList.ZoneDesc
			}

			if instancesList.FlowMsg != nil {
				instancesListMap["flow_msg"] = instancesList.FlowMsg
			}

			if instancesList.StatusDesc != nil {
				instancesListMap["status_desc"] = instancesList.StatusDesc
			}

			if instancesList.RenewFlag != nil {
				instancesListMap["renew_flag"] = instancesList.RenewFlag
			}

			tagsList := make([]map[string]interface{}, 0, len(instancesList.Tags))
			if instancesList.Tags != nil {
				for _, tags := range instancesList.Tags {
					tagsMap := map[string]interface{}{}

					if tags.TagKey != nil {
						tagsMap["tag_key"] = tags.TagKey
					}

					if tags.TagValue != nil {
						tagsMap["tag_value"] = tags.TagValue
					}

					tagsList = append(tagsList, tagsMap)
				}

				instancesListMap["tags"] = tagsList
			}
			if instancesList.Monitor != nil {
				instancesListMap["monitor"] = instancesList.Monitor
			}

			if instancesList.HasClsTopic != nil {
				instancesListMap["has_cls_topic"] = instancesList.HasClsTopic
			}

			if instancesList.ClsTopicId != nil {
				instancesListMap["cls_topic_id"] = instancesList.ClsTopicId
			}

			if instancesList.ClsLogSetId != nil {
				instancesListMap["cls_log_set_id"] = instancesList.ClsLogSetId
			}

			if instancesList.EnableXMLConfig != nil {
				instancesListMap["enable_xml_config"] = instancesList.EnableXMLConfig
			}

			if instancesList.RegionDesc != nil {
				instancesListMap["region_desc"] = instancesList.RegionDesc
			}

			if instancesList.Eip != nil {
				instancesListMap["eip"] = instancesList.Eip
			}

			if instancesList.CosMoveFactor != nil {
				instancesListMap["cos_move_factor"] = instancesList.CosMoveFactor
			}

			if instancesList.Kind != nil {
				instancesListMap["kind"] = instancesList.Kind
			}

			if instancesList.CosBucketName != nil {
				instancesListMap["cos_bucket_name"] = instancesList.CosBucketName
			}

			if instancesList.CanAttachCbs != nil {
				instancesListMap["can_attach_cbs"] = instancesList.CanAttachCbs
			}

			if instancesList.BuildVersion != nil {
				instancesListMap["build_version"] = instancesList.BuildVersion
			}

			if instancesList.Components != nil {
				instancesListMap["components"] = instancesList.Components
			}

			if instancesList.Characteristic != nil {
				instancesListMap["characteristic"] = instancesList.Characteristic
			}

			if instancesList.RestartTimeout != nil {
				instancesListMap["restart_timeout"] = instancesList.RestartTimeout
			}

			if instancesList.GraceShutdownWaitSeconds != nil {
				instancesListMap["grace_shutdown_wait_seconds"] = instancesList.GraceShutdownWaitSeconds
			}

			if instancesList.CaseSensitive != nil {
				instancesListMap["case_sensitive"] = instancesList.CaseSensitive
			}

			if instancesList.IsWhiteSGs != nil {
				instancesListMap["is_white_s_gs"] = instancesList.IsWhiteSGs
			}

			if instancesList.BindSGs != nil {
				instancesListMap["bind_s_gs"] = instancesList.BindSGs
			}

			if instancesList.EnableMultiZones != nil {
				instancesListMap["enable_multi_zones"] = instancesList.EnableMultiZones
			}

			if instancesList.UserNetworkInfos != nil {
				instancesListMap["user_network_infos"] = instancesList.UserNetworkInfos
			}

			if instancesList.EnableCoolDown != nil {
				instancesListMap["enable_cool_down"] = instancesList.EnableCoolDown
			}

			if instancesList.CoolDownBucket != nil {
				instancesListMap["cool_down_bucket"] = instancesList.CoolDownBucket
			}

			tmpInstancesList = append(tmpInstancesList, instancesListMap)
		}

		_ = d.Set("instances_list", tmpInstancesList)
	}

	d.SetId(helper.DataResourceIdsHash(ids))
	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), tmpInstancesList); e != nil {
			return e
		}
	}

	return nil
}
