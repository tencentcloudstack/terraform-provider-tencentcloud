// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teov20220901 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTeoL4ProxyRule() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudTeoL4ProxyRuleCreate,
		Read:   resourceTencentCloudTeoL4ProxyRuleRead,
		Update: resourceTencentCloudTeoL4ProxyRuleUpdate,
		Delete: resourceTencentCloudTeoL4ProxyRuleDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Zone ID.",
			},

			"proxy_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Layer 4 proxy instance ID.",
			},

			"l4_proxy_rules": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "List of forwarding rules. Note: When L4ProxyRule is used here, Protocol, PortRange, OriginType, OriginValue, and OriginPortRange are required fields; ClientIPPassThroughMode, SessionPersist, SessionPersistTime, and RuleTag are optional fields; do not fill in RuleId and Status.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"rule_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Forwarding rule ID.",
						},
						"protocol": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Forwarding protocol. Valid values:\n<li>TCP: TCP protocol;</li>\n<li>UDP: UDP protocol.</li>\nNote: This parameter must be filled in when L4ProxyRule is used as an input parameter in Createl4ProxyRule; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"port_range": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Forwarding port, which can be set as follows:\n<li>A single port, such as 80;</li>\n<li>A range of ports, such as 81-85, representing ports 81, 82, 83, 84, 85.</li>\nNote: This parameter must be filled in when L4ProxyRule is used as an input parameter in Createl4ProxyRule; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"origin_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Origin server type. Valid values:\n<li>IP_DOMAIN: IP/Domain name origin server;</li>\n<li>ORIGIN_GROUP: Origin server group;</li>\n<li>LB: Cloud Load Balancer, currently only open to the allowlist.</li>\nNote: This parameter must be filled in when L4ProxyRule is used as an input parameter in Createl4ProxyRule; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"origin_value": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Origin server address.\n<li>When OriginType is set to IP_DOMAIN, enter the IP address or domain name, such as 8.8.8.8 or test.com;</li>\n<li>When OriginType is set to ORIGIN_GROUP, enter the origin server group ID, such as og-537y24vf5b41;</li>\n<li>When OriginType is set to LB, enter the Cloud Load Balancer instance ID, such as lb-2qwk30xf7s9g.</li>\nNote: This parameter must be filled in when L4ProxyRule is used as an input parameter in Createl4ProxyRule; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"origin_port_range": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Origin server port, which can be set as follows:<li>A single port, such as 80;</li>\n<li>A range of ports, such as 81-85, representing ports 81, 82, 83, 84, 85. When inputting a range of ports, ensure that the length corresponds with that of the forwarding port range. For example, if the forwarding port range is 80-90, this port range should be 90-100.</li>\nNote: This parameter must be filled in when L4ProxyRule is used as an input parameter in Createl4ProxyRule; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"client_ip_pass_through_mode": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Transmission of the client IP address. Valid values:<li>TOA: Available only when Protocol=TCP;</li> \n<li>PPV1: Transmission via Proxy Protocol V1. Available only when Protocol=TCP;</li>\n<li>PPV2: Transmission via Proxy Protocol V2;</li> \n<li>SPP: Transmission via Simple Proxy Protocol. Available only when Protocol=UDP;</li> \n<li>OFF: No transmission.</li>\nNote: This parameter is optional when L4ProxyRule is used as an input parameter in Createl4ProxyRule, and if not specified, the default value OFF will be used; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"session_persist": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Specifies whether to enable session persistence. Valid values:\n<li>on: Enable;</li>\n<li>off: Disable.</li>\nNote: This parameter is optional when L4ProxyRule is used as an input parameter in Createl4ProxyRule, and if not specified, the default value off will be used; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"session_persist_time": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Session persistence period, with a range of 30-3600, measured in seconds.\nNote: This parameter is optional when L4ProxyRule is used as an input parameter in Createl4ProxyRule. It is valid only when SessionPersist is set to on and defaults to 3600 if not specified. It is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"rule_tag": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Rule tag. Accepts 1-50 arbitrary characters.\nNote: This parameter is optional when L4ProxyRule is used as an input parameter in Createl4ProxyRule; it is optional when L4ProxyRule is used as an input parameter in Modifyl4ProxyRule. If not specified, it will retain its existing value.",
						},
						"status": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Rule status. Valid values:<li>online: Enabled;</li>\n<li>offline: Disabled;</li>\n<li>progress: Deploying;</li>\n<li>stopping: Disabling;</li>\n<li>fail: Failed to deploy or disable.</li>.",
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudTeoL4ProxyRuleCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l4_proxy_rule.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		zoneId  string
		proxyId string
	)
	var (
		request  = teov20220901.NewCreateL4ProxyRulesRequest()
		response = teov20220901.NewCreateL4ProxyRulesResponse()
	)

	if v, ok := d.GetOk("zone_id"); ok {
		zoneId = v.(string)
	}
	if v, ok := d.GetOk("proxy_id"); ok {
		proxyId = v.(string)
	}

	request.ZoneId = helper.String(zoneId)

	if v, ok := d.GetOk("proxy_id"); ok {
		request.ProxyId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("l4_proxy_rules"); ok {
		for _, item := range v.([]interface{}) {
			l4ProxyRuleMap := item.(map[string]interface{})
			l4ProxyRule := teov20220901.L4ProxyRule{}
			if v, ok := l4ProxyRuleMap["protocol"].(string); ok && v != "" {
				l4ProxyRule.Protocol = helper.String(v)
			}
			if v, ok := l4ProxyRuleMap["port_range"]; ok {
				portRangeSet := v.(*schema.Set).List()
				for i := range portRangeSet {
					portRange := portRangeSet[i].(string)
					l4ProxyRule.PortRange = append(l4ProxyRule.PortRange, helper.String(portRange))
				}
			}
			if v, ok := l4ProxyRuleMap["origin_type"].(string); ok && v != "" {
				l4ProxyRule.OriginType = helper.String(v)
			}
			if v, ok := l4ProxyRuleMap["origin_value"]; ok {
				originValueSet := v.(*schema.Set).List()
				for i := range originValueSet {
					originValue := originValueSet[i].(string)
					l4ProxyRule.OriginValue = append(l4ProxyRule.OriginValue, helper.String(originValue))
				}
			}
			if v, ok := l4ProxyRuleMap["origin_port_range"].(string); ok && v != "" {
				l4ProxyRule.OriginPortRange = helper.String(v)
			}
			if v, ok := l4ProxyRuleMap["client_ip_pass_through_mode"].(string); ok && v != "" {
				l4ProxyRule.ClientIPPassThroughMode = helper.String(v)
			}
			if v, ok := l4ProxyRuleMap["session_persist"].(string); ok && v != "" {
				l4ProxyRule.SessionPersist = helper.String(v)
			}
			if v, ok := l4ProxyRuleMap["session_persist_time"].(int); ok {
				l4ProxyRule.SessionPersistTime = helper.IntUint64(v)
			}
			if v, ok := l4ProxyRuleMap["rule_tag"].(string); ok && v != "" {
				l4ProxyRule.RuleTag = helper.String(v)
			}
			request.L4ProxyRules = append(request.L4ProxyRules, &l4ProxyRule)
		}
	}

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().CreateL4ProxyRulesWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s create teo l4 proxy rule failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	if response.Response.L4ProxyRuleIds == nil || len(response.Response.L4ProxyRuleIds) == 0 {
		return fmt.Errorf("create teo l4 proxy rule failed, response.L4ProxyRuleIds is empty")
	}
	ruleId := *response.Response.L4ProxyRuleIds[0]

	if err := resourceTencentCloudTeoL4ProxyRuleCreatePostHandleResponse0(ctx, response); err != nil {
		return err
	}

	d.SetId(strings.Join([]string{zoneId, proxyId, ruleId}, tccommon.FILED_SP))

	return resourceTencentCloudTeoL4ProxyRuleRead(d, meta)
}

func resourceTencentCloudTeoL4ProxyRuleRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l4_proxy_rule.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 3 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	proxyId := idSplit[1]
	ruleId := idSplit[2]

	_ = d.Set("zone_id", zoneId)

	_ = d.Set("proxy_id", proxyId)

	l4ProxyRule, err := service.DescribeTeoL4ProxyRuleById(ctx, zoneId, proxyId, ruleId)
	if err != nil {
		return err
	}

	if l4ProxyRule == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `teo_l4_proxy_rule` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	l4ProxyRuleList := make([]map[string]interface{}, 0, 1)
	if l4ProxyRule != nil {
		l4ProxyRuleMap := map[string]interface{}{}

		if l4ProxyRule.Protocol != nil {
			l4ProxyRuleMap["rule_id"] = l4ProxyRule.RuleId
		}

		if l4ProxyRule.Protocol != nil {
			l4ProxyRuleMap["protocol"] = l4ProxyRule.Protocol
		}

		if l4ProxyRule.PortRange != nil {
			l4ProxyRuleMap["port_range"] = l4ProxyRule.PortRange
		}

		if l4ProxyRule.OriginType != nil {
			l4ProxyRuleMap["origin_type"] = l4ProxyRule.OriginType
		}

		if l4ProxyRule.OriginValue != nil {
			l4ProxyRuleMap["origin_value"] = l4ProxyRule.OriginValue
		}

		if l4ProxyRule.OriginPortRange != nil {
			l4ProxyRuleMap["origin_port_range"] = l4ProxyRule.OriginPortRange
		}

		if l4ProxyRule.ClientIPPassThroughMode != nil {
			l4ProxyRuleMap["client_ip_pass_through_mode"] = l4ProxyRule.ClientIPPassThroughMode
		}

		if l4ProxyRule.SessionPersist != nil {
			l4ProxyRuleMap["session_persist"] = l4ProxyRule.SessionPersist
		}

		if l4ProxyRule.SessionPersistTime != nil {
			l4ProxyRuleMap["session_persist_time"] = l4ProxyRule.SessionPersistTime
		}

		if l4ProxyRule.RuleTag != nil {
			l4ProxyRuleMap["rule_tag"] = l4ProxyRule.RuleTag
		}

		if l4ProxyRule.Status != nil {
			l4ProxyRuleMap["status"] = l4ProxyRule.Status
		}

		l4ProxyRuleList = append(l4ProxyRuleList, l4ProxyRuleMap)

		_ = d.Set("l4_proxy_rules", l4ProxyRuleList)
	}

	return nil
}

func resourceTencentCloudTeoL4ProxyRuleUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l4_proxy_rule.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 3 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	proxyId := idSplit[1]
	ruleId := idSplit[2]

	needChange := false
	mutableArgs := []string{"l4_proxy_rules"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := teov20220901.NewModifyL4ProxyRulesRequest()

		request.ZoneId = helper.String(zoneId)
		request.ProxyId = helper.String(proxyId)

		if v, ok := d.GetOk("l4_proxy_rules"); ok {
			for _, item := range v.([]interface{}) {
				l4ProxyRuleMap := item.(map[string]interface{})
				l4ProxyRule := teov20220901.L4ProxyRule{}
				l4ProxyRule.RuleId = helper.String(ruleId)
				if v, ok := l4ProxyRuleMap["protocol"].(string); ok && v != "" {
					l4ProxyRule.Protocol = helper.String(v)
				}
				if v, ok := l4ProxyRuleMap["port_range"]; ok {
					portRangeSet := v.(*schema.Set).List()
					for i := range portRangeSet {
						portRange := portRangeSet[i].(string)
						l4ProxyRule.PortRange = append(l4ProxyRule.PortRange, helper.String(portRange))
					}
				}
				if v, ok := l4ProxyRuleMap["origin_type"].(string); ok && v != "" {
					l4ProxyRule.OriginType = helper.String(v)
				}
				if v, ok := l4ProxyRuleMap["origin_value"]; ok {
					originValueSet := v.(*schema.Set).List()
					for i := range originValueSet {
						originValue := originValueSet[i].(string)
						l4ProxyRule.OriginValue = append(l4ProxyRule.OriginValue, helper.String(originValue))
					}
				}
				if v, ok := l4ProxyRuleMap["origin_port_range"].(string); ok && v != "" {
					l4ProxyRule.OriginPortRange = helper.String(v)
				}
				if v, ok := l4ProxyRuleMap["client_ip_pass_through_mode"].(string); ok && v != "" {
					l4ProxyRule.ClientIPPassThroughMode = helper.String(v)
				}
				if v, ok := l4ProxyRuleMap["session_persist"].(string); ok && v != "" {
					l4ProxyRule.SessionPersist = helper.String(v)
				}
				if v, ok := l4ProxyRuleMap["session_persist_time"].(int); ok {
					l4ProxyRule.SessionPersistTime = helper.IntUint64(v)
				}
				if v, ok := l4ProxyRuleMap["rule_tag"].(string); ok && v != "" {
					l4ProxyRule.RuleTag = helper.String(v)
				}
				request.L4ProxyRules = append(request.L4ProxyRules, &l4ProxyRule)
			}
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().ModifyL4ProxyRulesWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update teo l4 proxy rule failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	if err := resourceTencentCloudTeoL4ProxyRuleUpdateOnExit(ctx); err != nil {
		return err
	}

	_ = ruleId
	return resourceTencentCloudTeoL4ProxyRuleRead(d, meta)
}

func resourceTencentCloudTeoL4ProxyRuleDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l4_proxy_rule.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 3 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	proxyId := idSplit[1]
	ruleId := idSplit[2]

	var (
		request  = teov20220901.NewDeleteL4ProxyRulesRequest()
		response = teov20220901.NewDeleteL4ProxyRulesResponse()
	)

	request.ZoneId = helper.String(zoneId)

	request.ProxyId = helper.String(proxyId)

	request.RuleIds = append(request.RuleIds, helper.String(ruleId))

	if err := resourceTencentCloudTeoL4ProxyRuleDeletePostFillRequest0(ctx, request); err != nil {
		return err
	}

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().DeleteL4ProxyRulesWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s delete teo l4 proxy rule failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	_ = response
	_ = ruleId
	return nil
}
