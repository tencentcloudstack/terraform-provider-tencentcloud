// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teo "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTeoZoneSetting() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudTeoZoneSettingCreate,
		Read:   resourceTencentCloudTeoZoneSettingRead,
		Update: resourceTencentCloudTeoZoneSettingUpdate,
		Delete: resourceTencentCloudTeoZoneSettingDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		DeprecationMessage: "This resource has been deprecated in favour of the Terraform equivalent resource `tencentcloud_teo_l7_acc_setting`.",
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Site ID.",
			},

			"area": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Acceleration area of the zone. Valid values: `mainland`, `overseas`.",
			},

			"cache": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Cache expiration time configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cache": {
							Type:        schema.TypeList,
							Optional:    true,
							Computed:    true,
							MaxItems:    1,
							Description: "Cache configuration. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Computed:    true,
										Description: "Cache configuration switch.\n- `on`: Enable.\n- `off`: Disable. Note: This field may return null, indicating that no valid value can be obtained.",
									},
									"cache_time": {
										Type:        schema.TypeInt,
										Optional:    true,
										Computed:    true,
										Description: "Cache expiration time settings.\nUnit: second. The maximum value is 365 days. Note: This field may return null, indicating that no valid value can be obtained.",
									},
								},
							},
						},
						"no_cache": {
							Type:        schema.TypeList,
							Optional:    true,
							Computed:    true,
							MaxItems:    1,
							Description: "No-cache configuration. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Computed:    true,
										Description: "Whether to cache the configuration.\n- `on`: Do not cache.\n- `off`: Cache. Note: This field may return null, indicating that no valid value can be obtained.",
									},
								},
							},
						},
						"follow_origin": {
							Type:        schema.TypeList,
							Optional:    true,
							Computed:    true,
							MaxItems:    1,
							Description: "Follows the origin server configuration. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Computed:    true,
										Description: "Specifies whether to follow the origin server configuration.\n- `on`: Enable.\n- `off`: Disable. Note: This field may return null, indicating that no valid value can be obtained.",
									},
								},
							},
						},
					},
				},
			},

			"cache_key": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Node cache key configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"full_url_cache": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Specifies whether to enable full-path cache.\n- `on`: Enable full-path cache (i.e., disable Ignore Query String).\n- `off`: Disable full-path cache (i.e., enable Ignore Query String). Note: This field may return null, indicating that no valid value can be obtained.",
						},
						"ignore_case": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Specifies whether the cache key is case-sensitive. Note: This field may return null, indicating that no valid value can be obtained.",
						},
						"query_string": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Request parameter contained in CacheKey. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Whether to use QueryString as part of CacheKey.\n- `on`: Enable.\n- `off`: Disable. Note: This field may return null, indicating that no valid value can be obtained.",
									},
									"action": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "- `includeCustom`: Include the specified query strings.\n- `excludeCustom`: Exclude the specified query strings. Note: This field may return null, indicating that no valid value can be obtained.",
									},
									"value": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "Array of query strings used/excluded. Note: This field may return null, indicating that no valid value can be obtained.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
			},

			"max_age": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Browser cache configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_age_time": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Specifies the max age of the cache (in seconds). The maximum value is 365 days. Note: the value 0 means not to cache. Note: This field may return null, indicating that no valid value can be obtained.",
						},
						"follow_origin": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Specifies whether to follow the max cache age of the origin server.\n- `on`: Enable.\n- `off`: Disable.\nIf it's on, MaxAgeTime is ignored. Note: This field may return null, indicating that no valid value can be obtained.",
						},
					},
				},
			},

			"offline_cache": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Offline cache configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable offline cache.\n- `on`: Enable.\n- `off`: Disable. Note: This field may return null, indicating that no valid value can be obtained.",
						},
					},
				},
			},

			"quic": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "QUIC access configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable QUIC.\n- `on`: Enable.\n- `off`: Disable.",
						},
					},
				},
			},

			"post_max_size": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Maximum size of files transferred over POST request.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specifies whether to enable custom setting of the maximum file size.\n- `on`: Enable. You can set a custom max size.\n- `off`: Disable. In this case, the max size defaults to 32 MB.",
						},
						"max_size": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Maximum size. Value range: 1-500 MB. Note: This field may return null, indicating that no valid value can be obtained.",
						},
					},
				},
			},

			"compression": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Smart compression configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable Smart compression.\n- `on`: Enable.\n- `off`: Disable.",
						},
						"algorithms": {
							Type:        schema.TypeSet,
							Optional:    true,
							Computed:    true,
							Description: "Compression algorithms to select. Valid values: `brotli`, `gzip`.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"upstream_http2": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "HTTP2 origin-pull configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable HTTP2 origin-pull.\n- `on`: Enable.\n- `off`: Disable.",
						},
					},
				},
			},

			"force_redirect": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Force HTTPS redirect configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable force redirect.\n- `on`: Enable.\n- `off`: Disable.",
						},
						"redirect_status_code": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Redirection status code.\n- 301\n- 302 Note: This field may return null, indicating that no valid value can be obtained.",
						},
					},
				},
			},

			"https": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "HTTPS acceleration configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"http2": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "HTTP2 configuration switch.\n- `on`: Enable.\n- `off`: Disable. Note: This field may return null, indicating that no valid value can be obtained.",
						},
						"ocsp_stapling": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "OCSP configuration switch.\n- `on`: Enable.\n- `off`: Disable.\nIt is disabled by default. Note: This field may return null, indicating that no valid value can be obtained.",
						},
						"tls_version": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "TLS version settings. Valid values: `TLSv1`, `TLSV1.1`, `TLSV1.2`, and `TLSv1.3`.\nOnly consecutive versions can be enabled at the same time. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"hsts": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "HSTS Configuration. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "- `on`: Enable.\n- `off`: Disable.",
									},
									"max_age": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "MaxAge value in seconds, should be no more than 1 day. Note: This field may return null, indicating that no valid value can be obtained.",
									},
									"include_sub_domains": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Specifies whether to include subdomain names. Valid values: `on` and `off`. Note: This field may return null, indicating that no valid value can be obtained.",
									},
									"preload": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Specifies whether to preload. Valid values: `on` and `off`. Note: This field may return null, indicating that no valid value can be obtained.",
									},
								},
							},
						},
					},
				},
			},

			"origin": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Origin server configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"origins": {
							Type:        schema.TypeSet,
							Optional:    true,
							Computed:    true,
							Description: "Origin sites list. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"backup_origins": {
							Type:        schema.TypeSet,
							Optional:    true,
							Computed:    true,
							Description: "Backup origin sites list. Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"origin_pull_protocol": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Origin-pull protocol.\n- `http`: Switch HTTPS requests to HTTP.\n- `follow`: Follow the protocol of the request.\n- `https`: Switch HTTP requests to HTTPS. This only supports port 443 on the origin server. Note: This field may return null, indicating that no valid value can be obtained.",
						},
					},
				},
			},

			"smart_routing": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Smart acceleration configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable smart acceleration.\n- `on`: Enable.\n- `off`: Disable.",
						},
					},
				},
			},

			"web_socket": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "WebSocket configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether to enable custom WebSocket timeout setting. When it's off: it means to keep the default WebSocket connection timeout period, which is 15 seconds. To change the timeout period, please set it to on.",
						},
						"timeout": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Sets timeout period in seconds. Maximum value: 120.",
						},
					},
				},
			},

			"client_ip_header": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Origin-pull client IP header configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specifies whether to enable client IP header.\n- `on`: Enable.\n- `off`: Disable. Note: This field may return null, indicating that no valid value can be obtained.",
						},
						"header_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Name of the origin-pull client IP request header. Note: This field may return null, indicating that no valid value can be obtained.",
						},
					},
				},
			},

			"cache_prefresh": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "Cache pre-refresh configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specifies whether to enable cache prefresh.\n- `on`: Enable.\n- `off`: Disable.",
						},
						"percent": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Percentage of cache time before try to prefresh. Valid value range: 1-99.",
						},
					},
				},
			},

			"ipv6": {
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				MaxItems:    1,
				Description: "IPv6 access configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"switch": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "- `on`: Enable.\n- `off`: Disable.",
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudTeoZoneSettingCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_zone_setting.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		zoneId string
	)
	if v, ok := d.GetOk("zone_id"); ok {
		zoneId = v.(string)
	}

	d.SetId(zoneId)

	return resourceTencentCloudTeoZoneSettingUpdate(d, meta)
}

func resourceTencentCloudTeoZoneSettingRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_zone_setting.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	zoneId := d.Id()

	_ = d.Set("zone_id", zoneId)

	respData, err := service.DescribeTeoZoneSettingById(ctx, zoneId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `teo_zone_setting` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.Area != nil {
		_ = d.Set("area", respData.Area)
	}

	cacheConfigMap := map[string]interface{}{}

	if respData.CacheConfig != nil {
		cacheMap := map[string]interface{}{}

		if respData.CacheConfig.Cache != nil {
			if respData.CacheConfig.Cache.Switch != nil {
				cacheMap["switch"] = respData.CacheConfig.Cache.Switch
			}

			if respData.CacheConfig.Cache.CacheTime != nil {
				cacheMap["cache_time"] = respData.CacheConfig.Cache.CacheTime
			}

			cacheConfigMap["cache"] = []interface{}{cacheMap}
		}

		noCacheMap := map[string]interface{}{}

		if respData.CacheConfig.NoCache != nil {
			if respData.CacheConfig.NoCache.Switch != nil {
				noCacheMap["switch"] = respData.CacheConfig.NoCache.Switch
			}

			cacheConfigMap["no_cache"] = []interface{}{noCacheMap}
		}

		followOriginMap := map[string]interface{}{}

		if respData.CacheConfig.FollowOrigin != nil {
			if respData.CacheConfig.FollowOrigin.Switch != nil {
				followOriginMap["switch"] = respData.CacheConfig.FollowOrigin.Switch
			}

			cacheConfigMap["follow_origin"] = []interface{}{followOriginMap}
		}

		_ = d.Set("cache", []interface{}{cacheConfigMap})
	}

	cacheKeyMap := map[string]interface{}{}

	if respData.CacheKey != nil {
		if respData.CacheKey.FullUrlCache != nil {
			cacheKeyMap["full_url_cache"] = respData.CacheKey.FullUrlCache
		}

		if respData.CacheKey.IgnoreCase != nil {
			cacheKeyMap["ignore_case"] = respData.CacheKey.IgnoreCase
		}

		queryStringMap := map[string]interface{}{}

		if respData.CacheKey.QueryString != nil {
			if respData.CacheKey.QueryString.Switch != nil {
				queryStringMap["switch"] = respData.CacheKey.QueryString.Switch
			}

			if respData.CacheKey.QueryString.Action != nil {
				queryStringMap["action"] = respData.CacheKey.QueryString.Action
			}

			if respData.CacheKey.QueryString.Value != nil {
				queryStringMap["value"] = respData.CacheKey.QueryString.Value
			}

			cacheKeyMap["query_string"] = []interface{}{queryStringMap}
		}

		_ = d.Set("cache_key", []interface{}{cacheKeyMap})
	}

	maxAgeMap := map[string]interface{}{}

	if respData.MaxAge != nil {
		if respData.MaxAge.MaxAgeTime != nil {
			maxAgeMap["max_age_time"] = respData.MaxAge.MaxAgeTime
		}

		if respData.MaxAge.FollowOrigin != nil {
			maxAgeMap["follow_origin"] = respData.MaxAge.FollowOrigin
		}

		_ = d.Set("max_age", []interface{}{maxAgeMap})
	}

	offlineCacheMap := map[string]interface{}{}

	if respData.OfflineCache != nil {
		if respData.OfflineCache.Switch != nil {
			offlineCacheMap["switch"] = respData.OfflineCache.Switch
		}

		_ = d.Set("offline_cache", []interface{}{offlineCacheMap})
	}

	quicMap := map[string]interface{}{}

	if respData.Quic != nil {
		if respData.Quic.Switch != nil {
			quicMap["switch"] = respData.Quic.Switch
		}

		_ = d.Set("quic", []interface{}{quicMap})
	}

	postMaxSizeMap := map[string]interface{}{}

	if respData.PostMaxSize != nil {
		if respData.PostMaxSize.Switch != nil {
			postMaxSizeMap["switch"] = respData.PostMaxSize.Switch
		}

		if respData.PostMaxSize.MaxSize != nil {
			postMaxSizeMap["max_size"] = respData.PostMaxSize.MaxSize
		}

		_ = d.Set("post_max_size", []interface{}{postMaxSizeMap})
	}

	compressionMap := map[string]interface{}{}

	if respData.Compression != nil {
		if respData.Compression.Switch != nil {
			compressionMap["switch"] = respData.Compression.Switch
		}

		if respData.Compression.Algorithms != nil {
			compressionMap["algorithms"] = respData.Compression.Algorithms
		}

		_ = d.Set("compression", []interface{}{compressionMap})
	}

	upstreamHttp2Map := map[string]interface{}{}

	if respData.UpstreamHttp2 != nil {
		if respData.UpstreamHttp2.Switch != nil {
			upstreamHttp2Map["switch"] = respData.UpstreamHttp2.Switch
		}

		_ = d.Set("upstream_http2", []interface{}{upstreamHttp2Map})
	}

	forceRedirectMap := map[string]interface{}{}

	if respData.ForceRedirect != nil {
		if respData.ForceRedirect.Switch != nil {
			forceRedirectMap["switch"] = respData.ForceRedirect.Switch
		}

		if respData.ForceRedirect.RedirectStatusCode != nil {
			forceRedirectMap["redirect_status_code"] = respData.ForceRedirect.RedirectStatusCode
		}

		_ = d.Set("force_redirect", []interface{}{forceRedirectMap})
	}

	httpsMap := map[string]interface{}{}

	if respData.Https != nil {
		if respData.Https.Http2 != nil {
			httpsMap["http2"] = respData.Https.Http2
		}

		if respData.Https.OcspStapling != nil {
			httpsMap["ocsp_stapling"] = respData.Https.OcspStapling
		}

		if respData.Https.TlsVersion != nil {
			httpsMap["tls_version"] = respData.Https.TlsVersion
		}

		hstsMap := map[string]interface{}{}

		if respData.Https.Hsts != nil {
			if respData.Https.Hsts.Switch != nil {
				hstsMap["switch"] = respData.Https.Hsts.Switch
			}

			if respData.Https.Hsts.MaxAge != nil {
				hstsMap["max_age"] = respData.Https.Hsts.MaxAge
			}

			if respData.Https.Hsts.IncludeSubDomains != nil {
				hstsMap["include_sub_domains"] = respData.Https.Hsts.IncludeSubDomains
			}

			if respData.Https.Hsts.Preload != nil {
				hstsMap["preload"] = respData.Https.Hsts.Preload
			}

			httpsMap["hsts"] = []interface{}{hstsMap}
		}

		_ = d.Set("https", []interface{}{httpsMap})
	}

	originMap := map[string]interface{}{}

	if respData.Origin != nil {
		if respData.Origin.Origins != nil {
			originMap["origins"] = respData.Origin.Origins
		}

		if respData.Origin.BackupOrigins != nil {
			originMap["backup_origins"] = respData.Origin.BackupOrigins
		}

		if respData.Origin.OriginPullProtocol != nil {
			originMap["origin_pull_protocol"] = respData.Origin.OriginPullProtocol
		}

		_ = d.Set("origin", []interface{}{originMap})
	}

	smartRoutingMap := map[string]interface{}{}

	if respData.SmartRouting != nil {
		if respData.SmartRouting.Switch != nil {
			smartRoutingMap["switch"] = respData.SmartRouting.Switch
		}

		_ = d.Set("smart_routing", []interface{}{smartRoutingMap})
	}

	webSocketMap := map[string]interface{}{}

	if respData.WebSocket != nil {
		if respData.WebSocket.Switch != nil {
			webSocketMap["switch"] = respData.WebSocket.Switch
		}

		if respData.WebSocket.Timeout != nil {
			webSocketMap["timeout"] = respData.WebSocket.Timeout
		}

		_ = d.Set("web_socket", []interface{}{webSocketMap})
	}

	clientIpHeaderMap := map[string]interface{}{}

	if respData.ClientIpHeader != nil {
		if respData.ClientIpHeader.Switch != nil {
			clientIpHeaderMap["switch"] = respData.ClientIpHeader.Switch
		}

		if respData.ClientIpHeader.HeaderName != nil {
			clientIpHeaderMap["header_name"] = respData.ClientIpHeader.HeaderName
		}

		_ = d.Set("client_ip_header", []interface{}{clientIpHeaderMap})
	}

	cachePrefreshMap := map[string]interface{}{}

	if respData.CachePrefresh != nil {
		if respData.CachePrefresh.Switch != nil {
			cachePrefreshMap["switch"] = respData.CachePrefresh.Switch
		}

		if respData.CachePrefresh.Percent != nil {
			cachePrefreshMap["percent"] = respData.CachePrefresh.Percent
		}

		_ = d.Set("cache_prefresh", []interface{}{cachePrefreshMap})
	}

	ipv6Map := map[string]interface{}{}

	if respData.Ipv6 != nil {
		if respData.Ipv6.Switch != nil {
			ipv6Map["switch"] = respData.Ipv6.Switch
		}

		_ = d.Set("ipv6", []interface{}{ipv6Map})
	}

	return nil
}

func resourceTencentCloudTeoZoneSettingUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_zone_setting.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	zoneId := d.Id()

	needChange := false
	mutableArgs := []string{"cache", "cache_key", "max_age", "offline_cache", "quic", "post_max_size", "compression", "upstream_http2", "force_redirect", "https", "origin", "smart_routing", "web_socket", "client_ip_header", "cache_prefresh", "ipv6"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := teo.NewModifyZoneSettingRequest()

		request.ZoneId = &zoneId

		if cacheConfigMap, ok := helper.InterfacesHeadMap(d, "cache"); ok {
			cacheConfig := teo.CacheConfig{}
			if cacheMap, ok := helper.ConvertInterfacesHeadToMap(cacheConfigMap["cache"]); ok {
				cache := teo.Cache{}
				if v, ok := cacheMap["switch"]; ok {
					cache.Switch = helper.String(v.(string))
				}
				if v, ok := cacheMap["cache_time"]; ok {
					cache.CacheTime = helper.IntInt64(v.(int))
				}
				cacheConfig.Cache = &cache
			}
			if noCacheMap, ok := helper.ConvertInterfacesHeadToMap(cacheConfigMap["no_cache"]); ok {
				noCache := teo.NoCache{}
				if v, ok := noCacheMap["switch"]; ok {
					noCache.Switch = helper.String(v.(string))
				}
				cacheConfig.NoCache = &noCache
			}
			if followOriginMap, ok := helper.ConvertInterfacesHeadToMap(cacheConfigMap["follow_origin"]); ok {
				followOrigin := teo.FollowOrigin{}
				if v, ok := followOriginMap["switch"]; ok {
					followOrigin.Switch = helper.String(v.(string))
				}
				cacheConfig.FollowOrigin = &followOrigin
			}
			request.CacheConfig = &cacheConfig
		}

		if cacheKeyMap, ok := helper.InterfacesHeadMap(d, "cache_key"); ok {
			cacheKey := teo.CacheKey{}
			if v, ok := cacheKeyMap["full_url_cache"]; ok {
				cacheKey.FullUrlCache = helper.String(v.(string))
			}
			if v, ok := cacheKeyMap["ignore_case"]; ok {
				cacheKey.IgnoreCase = helper.String(v.(string))
			}
			if queryStringMap, ok := helper.ConvertInterfacesHeadToMap(cacheKeyMap["query_string"]); ok {
				queryString := teo.QueryString{}
				if v, ok := queryStringMap["switch"]; ok {
					queryString.Switch = helper.String(v.(string))
				}
				if v, ok := queryStringMap["action"]; ok {
					queryString.Action = helper.String(v.(string))
				}
				if v, ok := queryStringMap["value"]; ok {
					valueSet := v.(*schema.Set).List()
					for i := range valueSet {
						value := valueSet[i].(string)
						queryString.Value = append(queryString.Value, helper.String(value))
					}
				}
				cacheKey.QueryString = &queryString
			}
			request.CacheKey = &cacheKey
		}

		if maxAgeMap, ok := helper.InterfacesHeadMap(d, "max_age"); ok {
			maxAge := teo.MaxAge{}
			if v, ok := maxAgeMap["max_age_time"]; ok {
				maxAge.MaxAgeTime = helper.IntInt64(v.(int))
			}
			if v, ok := maxAgeMap["follow_origin"]; ok {
				maxAge.FollowOrigin = helper.String(v.(string))
			}
			request.MaxAge = &maxAge
		}

		if offlineCacheMap, ok := helper.InterfacesHeadMap(d, "offline_cache"); ok {
			offlineCache := teo.OfflineCache{}
			if v, ok := offlineCacheMap["switch"]; ok {
				offlineCache.Switch = helper.String(v.(string))
			}
			request.OfflineCache = &offlineCache
		}

		if quicMap, ok := helper.InterfacesHeadMap(d, "quic"); ok {
			quic := teo.Quic{}
			if v, ok := quicMap["switch"]; ok {
				quic.Switch = helper.String(v.(string))
			}
			request.Quic = &quic
		}

		if postMaxSizeMap, ok := helper.InterfacesHeadMap(d, "post_max_size"); ok {
			postMaxSize := teo.PostMaxSize{}
			if v, ok := postMaxSizeMap["switch"]; ok {
				postMaxSize.Switch = helper.String(v.(string))
			}
			if v, ok := postMaxSizeMap["max_size"]; ok {
				postMaxSize.MaxSize = helper.IntInt64(v.(int))
			}
			request.PostMaxSize = &postMaxSize
		}

		if compressionMap, ok := helper.InterfacesHeadMap(d, "compression"); ok {
			compression := teo.Compression{}
			if v, ok := compressionMap["switch"]; ok {
				compression.Switch = helper.String(v.(string))
			}
			if v, ok := compressionMap["algorithms"]; ok {
				algorithmsSet := v.(*schema.Set).List()
				for i := range algorithmsSet {
					algorithms := algorithmsSet[i].(string)
					compression.Algorithms = append(compression.Algorithms, helper.String(algorithms))
				}
			}
			request.Compression = &compression
		}

		if upstreamHttp2Map, ok := helper.InterfacesHeadMap(d, "upstream_http2"); ok {
			upstreamHttp2 := teo.UpstreamHttp2{}
			if v, ok := upstreamHttp2Map["switch"]; ok {
				upstreamHttp2.Switch = helper.String(v.(string))
			}
			request.UpstreamHttp2 = &upstreamHttp2
		}

		if forceRedirectMap, ok := helper.InterfacesHeadMap(d, "force_redirect"); ok {
			forceRedirect := teo.ForceRedirect{}
			if v, ok := forceRedirectMap["switch"]; ok {
				forceRedirect.Switch = helper.String(v.(string))
			}
			if v, ok := forceRedirectMap["redirect_status_code"]; ok {
				forceRedirect.RedirectStatusCode = helper.IntInt64(v.(int))
			}
			request.ForceRedirect = &forceRedirect
		}

		if httpsMap, ok := helper.InterfacesHeadMap(d, "https"); ok {
			https := teo.Https{}
			if v, ok := httpsMap["http2"]; ok {
				https.Http2 = helper.String(v.(string))
			}
			if v, ok := httpsMap["ocsp_stapling"]; ok {
				https.OcspStapling = helper.String(v.(string))
			}
			if v, ok := httpsMap["tls_version"]; ok {
				tlsVersionSet := v.(*schema.Set).List()
				for i := range tlsVersionSet {
					tlsVersion := tlsVersionSet[i].(string)
					https.TlsVersion = append(https.TlsVersion, helper.String(tlsVersion))
				}
			}
			if hstsMap, ok := helper.ConvertInterfacesHeadToMap(httpsMap["hsts"]); ok {
				hsts := teo.Hsts{}
				if v, ok := hstsMap["switch"]; ok {
					hsts.Switch = helper.String(v.(string))
				}
				if v, ok := hstsMap["max_age"]; ok {
					hsts.MaxAge = helper.IntInt64(v.(int))
				}
				if v, ok := hstsMap["include_sub_domains"]; ok {
					hsts.IncludeSubDomains = helper.String(v.(string))
				}
				if v, ok := hstsMap["preload"]; ok {
					hsts.Preload = helper.String(v.(string))
				}
				https.Hsts = &hsts
			}
			request.Https = &https
		}

		if originMap, ok := helper.InterfacesHeadMap(d, "origin"); ok {
			origin := teo.Origin{}
			if v, ok := originMap["origins"]; ok {
				originsSet := v.(*schema.Set).List()
				for i := range originsSet {
					origins := originsSet[i].(string)
					origin.Origins = append(origin.Origins, helper.String(origins))
				}
			}
			if v, ok := originMap["backup_origins"]; ok {
				backupOriginsSet := v.(*schema.Set).List()
				for i := range backupOriginsSet {
					backupOrigins := backupOriginsSet[i].(string)
					origin.BackupOrigins = append(origin.BackupOrigins, helper.String(backupOrigins))
				}
			}
			if v, ok := originMap["origin_pull_protocol"]; ok {
				origin.OriginPullProtocol = helper.String(v.(string))
			}
			request.Origin = &origin
		}

		if smartRoutingMap, ok := helper.InterfacesHeadMap(d, "smart_routing"); ok {
			smartRouting := teo.SmartRouting{}
			if v, ok := smartRoutingMap["switch"]; ok {
				smartRouting.Switch = helper.String(v.(string))
			}
			request.SmartRouting = &smartRouting
		}

		if webSocketMap, ok := helper.InterfacesHeadMap(d, "web_socket"); ok {
			webSocket := teo.WebSocket{}
			if v, ok := webSocketMap["switch"]; ok {
				webSocket.Switch = helper.String(v.(string))
			}
			if v, ok := webSocketMap["timeout"]; ok {
				webSocket.Timeout = helper.IntInt64(v.(int))
			}
			request.WebSocket = &webSocket
		}

		if clientIpHeaderMap, ok := helper.InterfacesHeadMap(d, "client_ip_header"); ok {
			clientIpHeader := teo.ClientIpHeader{}
			if v, ok := clientIpHeaderMap["switch"]; ok {
				clientIpHeader.Switch = helper.String(v.(string))
			}
			if v, ok := clientIpHeaderMap["header_name"]; ok {
				clientIpHeader.HeaderName = helper.String(v.(string))
			}
			request.ClientIpHeader = &clientIpHeader
		}

		if cachePrefreshMap, ok := helper.InterfacesHeadMap(d, "cache_prefresh"); ok {
			cachePrefresh := teo.CachePrefresh{}
			if v, ok := cachePrefreshMap["switch"]; ok {
				cachePrefresh.Switch = helper.String(v.(string))
			}
			if v, ok := cachePrefreshMap["percent"]; ok {
				cachePrefresh.Percent = helper.IntInt64(v.(int))
			}
			request.CachePrefresh = &cachePrefresh
		}

		if ipv6Map, ok := helper.InterfacesHeadMap(d, "ipv6"); ok {
			ipv6 := teo.Ipv6{}
			if v, ok := ipv6Map["switch"]; ok {
				ipv6.Switch = helper.String(v.(string))
			}
			request.Ipv6 = &ipv6
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoClient().ModifyZoneSettingWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update teo zone setting failed, reason:%+v", logId, err)
			return err
		}
	}

	return resourceTencentCloudTeoZoneSettingRead(d, meta)
}

func resourceTencentCloudTeoZoneSettingDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_zone_setting.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
