// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teov20220901 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudTeoZones() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudTeoZonesRead,
		Schema: map[string]*schema.Schema{
			"filters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Filter criteria. the maximum value of Filters.Values is 20. if this parameter is left empty, all site information authorized under the current appid will be returned. detailed filter criteria are as follows: zone-name: filter by site name; zone-id: filter by site id. the site id is in the format of zone-2noz78a8ev6k; status: filter by site status; tag-key: filter by tag key; tag-value: filter by tag value; alias-zone-name: filter by identical site identifier. when performing a fuzzy query, the fields that support filtering are named zone-name or alias-zone-name.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Field to be filtered.",
						},
						"values": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "Value of the filtered field.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"fuzzy": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to enable fuzzy query.",
						},
					},
				},
			},

			"order": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Sort the returned results according to this field. Values include: `type`: Connection mode; `area`: Acceleration region; `create-time`: Creation time; `zone-name`: Site name; `use-time`: Last used time; `active-status` Effective status. Default value: `create-time`.",
			},

			"direction": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Sort direction. If the field value is a number, sort by the numeric value. If the field value is text, sort by the ascill code. Values include: `asc`: From the smallest to largest; `desc`: From the largest to smallest. Default value: `desc`.",
			},

			"zones": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Details of sites.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"zone_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Site ID.",
						},
						"zone_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The site name.",
						},
						"original_name_servers": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "List of name servers used by the site.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"name_servers": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "The list of name servers assigned by Tencent Cloud.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The site status. Values: `active`: The name server is switched to EdgeOne. `pending`: The name server is not switched. `moved`: The name server is changed to other service providers. `deactivated`: The site is blocked. `initializing`: The site is not bound with any plan.",
						},
						"type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Site access method. Valid values: full: NS access; partial: CNAME access; noDomainAccess: access with no domain name.",
						},
						"paused": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: "Whether the site is disabled.",
						},
						"cname_speed_up": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Whether CNAME acceleration is enabled. Values: `enabled`: Enabled; `disabled`: Disabled.",
						},
						"cname_status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "CNAME record access status. Values: `finished`: The site is verified.`pending`: The site is being verified.",
						},
						"tags": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "The list of resource tags.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"tag_key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The tag key. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"tag_value": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The tag value. Note: This field may return null, indicating that no valid values can be obtained.",
									},
								},
							},
						},
						"resources": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "The list of billable resources.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The resource ID.",
									},
									"pay_mode": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Billing mode, `0`: Pay-as-you-go",
									},
									"create_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The creation time.",
									},
									"enable_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The effective time.",
									},
									"expire_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The expiration time.",
									},
									"status": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The plan status. Values: `normal`: Normal; `isolated`: Isolated; `destroyed`: Terminated.",
									},
									"sv": {
										Type:        schema.TypeList,
										Required:    true,
										Description: "Pricing query parameter",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The parameter key.",
												},
												"value": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The parameter value.",
												},
												"pack": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Quota for a resource. Values: `zone`: Quota for sites; `custom-rule`: Quota for custom rules; `rate-limiting-rule`: Quota for rate limiting rules; `l4-proxy-instance`: Quota for L4 proxy instances. Note: This field may return null, indicating that no valid values can be obtained.",
												},
												"instance_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "ID of the L4 proxy instance. Note: This field may return null, indicating that no valid values can be obtained.",
												},
												"protection_specs": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "The protection specification. Values: `cm_30G`: 30 Gbps base protection bandwidth in **Chinese mainland** service area; `cm_60G`: 60 Gbps base protection bandwidth in **Chinese mainland** service area; `cm_100G`: 100 Gbps base protection bandwidth in **Chinese mainland** service area; `anycast_300G`: 300 Gbps Anycast-based protection in **Global (MLC)** service area; `anycast_unlimited`: Unlimited Anycast-based protection bandwidth in **Global (MLC)** service area; `cm_30G_anycast_300G`: 30 Gbps base protection bandwidth in **Chinese mainland** service area and 300 Gbps Anycast-based protection bandwidth in **Global (MLC)** service area; `cm_30G_anycast_unlimited`: 30 Gbps base protection bandwidth in **Chinese mainland** service area and unlimited Anycast-based protection bandwidth in **Global (MLC)** service area; cm_60G_anycast_300G`: 60 Gbps base protection bandwidth in **Chinese mainland** service area and 300 Gbps Anycast-based protection bandwidth in **Global (MLC)** service area; cm_60G_anycast_unlimited`: 60 Gbps base protection bandwidth in **Chinese mainland** service area and unlimited Anycast-based protection bandwidth in **Global (MLC)** service area</li><li> `cm_100G_anycast_300G`: 100 Gbps base protection bandwidth in **Chinese mainland** service area and 300 Gbps Anycast-based protection bandwidth in **Global (MLC)** service area, cm_100G_anycast_unlimited`: 100 Gbps base protection bandwidth in **Chinese mainland** service area and unlimited Anycast-based protection bandwidth in **Global (MLC)** service area. Note: This field may return null, indicating that no valid values can be obtained.",
												},
											},
										},
									},
									"auto_renew_flag": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Whether to enable auto-renewal. Values: `0`: Default status. `1`: Enable auto-renewal. `2`: Disable auto-renewal.",
									},
									"plan_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "ID of the resource associated with the plan.",
									},
									"area": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Applicable area. Values: `mainland`: Chinese mainland; `overseas`: Regions outside the Chinese mainland; `global`: Global.",
									},
									"group": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "The resource type. Values: `plan`: Plan resources; `pay-as-you-go`: Pay-as-you-go resources; `value-added`: Value-added resources. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"zone_number": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "The sites that are associated with the current resources. Note: This field may return null, indicating that no valid values can be obtained.",
									},
									"type": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Resource tag type. Valid values: vodeo: vodeo resource.",
									},
								},
							},
						},
						"created_on": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The creation time of the site.",
						},
						"modified_on": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The modification date of the site.",
						},
						"area": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The site access region. Values: `global`: Global. `mainland`: Chinese mainland. `overseas`: Outside the Chinese mainland.",
						},
						"vanity_name_servers": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "The custom name server information.\nNote: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Whether to enable custom name servers. Values: `on`: Enable; `off`: Disable.",
									},
									"servers": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "List of custom name servers",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"vanity_name_servers_ips": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "The custom name server IP information. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Custom name of the name server",
									},
									"i_pv4": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "IPv4 address of the custom name server",
									},
								},
							},
						},
						"active_status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Status of the proxy. Values: `active`: Enabled; `inactive`: Not activated; `paused`: Disabled.",
						},
						"alias_zone_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The site alias. It can be up to 20 characters consisting of digits, letters, hyphens (-) and underscores (_). Note: This field may return null, indicating that no valid values can be obtained.",
						},
						"is_fake": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Whether it is a fake site. Valid values: `0`: Non-fake site; `1`: Fake site.",
						},
						"lock_status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Lock status. Values: `enable`: Normal. Modification is allowed. `disable`: Locked. Modification is not allowed. `plan_migrate`: Adjusting the plan. Modification is not allowed.",
						},
						"ownership_verification": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Ownership verification information. Note: This field may return null, indicating that no valid values can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dns_verification": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "CNAME, when there is no domain name access, the information required for DNS resolution verification is used. For details, refer to [Site/Domain Ownership Verification\n](https://intl.cloud.tencent.com/document/product/1552/70789?from_cn_redirect=1#7af6ecf8-afca-4e35-8811-b5797ed1bde5). Note: This field may return null, which indicates a failure to obtain a valid value.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"subdomain": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The host record.",
												},
												"record_type": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The record type.",
												},
												"record_value": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The record value.",
												},
											},
										},
									},
									"file_verification": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "CNAME, when there is no domain name access, the information required for file verification is used. For details, refer to [Site/Domain Ownership Verification\n](https://intl.cloud.tencent.com/document/product/1552/70789?from_cn_redirect=1#7af6ecf8-afca-4e35-8811-b5797ed1bde5). Note: This field may return null, which indicates a failure to obtain a valid value.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"path": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "EdgeOne obtains the file verification information in the format of \"Scheme + Host + URL Path\", (e.g. https://www.example.com/.well-known/teo-verification/z12h416twn.txt). This field is the URL path section of the URL you need to create.",
												},
												"content": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Content of the verification file. The contents of this field need to be filled into the text file returned by `Path`.",
												},
											},
										},
									},
									"ns_verification": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "u200cInformation required for switching DNS servers. It's applicable to sites connected via NSs. For details, see [Modifying DNS Server](https://intl.cloud.tencent.com/document/product/1552/90452?from_cn_redirect=1).\nNote: This field may return·null, indicating that no valid values can be obtained.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"name_servers": {
													Type:        schema.TypeSet,
													Required:    true,
													Description: "The DNS server address assigned to the user when connecting a site to EO via NS. You need to switch the NameServer of the domain name to this address.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudTeoZonesRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_teo_zones.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("filters"); ok {
		filtersSet := v.([]interface{})
		tmpSet := make([]*teov20220901.AdvancedFilter, 0, len(filtersSet))
		for _, item := range filtersSet {
			filtersMap := item.(map[string]interface{})
			advancedFilter := teov20220901.AdvancedFilter{}
			if v, ok := filtersMap["name"].(string); ok && v != "" {
				advancedFilter.Name = helper.String(v)
			}
			if v, ok := filtersMap["values"]; ok {
				valuesSet := v.(*schema.Set).List()
				for i := range valuesSet {
					values := valuesSet[i].(string)
					advancedFilter.Values = append(advancedFilter.Values, helper.String(values))
				}
			}
			if v, ok := filtersMap["fuzzy"].(bool); ok {
				advancedFilter.Fuzzy = helper.Bool(v)
			}
			tmpSet = append(tmpSet, &advancedFilter)
		}
		paramMap["Filters"] = tmpSet
	}

	if v, ok := d.GetOk("order"); ok {
		paramMap["Order"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("direction"); ok {
		paramMap["Direction"] = helper.String(v.(string))
	}

	var respData []*teov20220901.Zone
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeTeoZonesByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	var zoneIds []string
	zonesList := make([]map[string]interface{}, 0, len(respData))
	if respData != nil {
		for _, zones := range respData {
			zonesMap := map[string]interface{}{}

			var zoneId string
			if zones.ZoneId != nil {
				zonesMap["zone_id"] = zones.ZoneId
				zoneId = *zones.ZoneId
			}

			if zones.ZoneName != nil {
				zonesMap["zone_name"] = zones.ZoneName
			}

			if zones.OriginalNameServers != nil {
				zonesMap["original_name_servers"] = zones.OriginalNameServers
			}

			if zones.NameServers != nil {
				zonesMap["name_servers"] = zones.NameServers
			}

			if zones.Status != nil {
				zonesMap["status"] = zones.Status
			}

			if zones.Type != nil {
				zonesMap["type"] = zones.Type
			}

			if zones.Paused != nil {
				zonesMap["paused"] = zones.Paused
			}

			if zones.CnameSpeedUp != nil {
				zonesMap["cname_speed_up"] = zones.CnameSpeedUp
			}

			if zones.CnameStatus != nil {
				zonesMap["cname_status"] = zones.CnameStatus
			}

			tagsList := make([]map[string]interface{}, 0, len(zones.Tags))
			if zones.Tags != nil {
				for _, tags := range zones.Tags {
					tagsMap := map[string]interface{}{}

					if tags.TagKey != nil {
						tagsMap["tag_key"] = tags.TagKey
					}

					if tags.TagValue != nil {
						tagsMap["tag_value"] = tags.TagValue
					}

					tagsList = append(tagsList, tagsMap)
				}

				zonesMap["tags"] = tagsList
			}
			resourcesList := make([]map[string]interface{}, 0, len(zones.Resources))
			if zones.Resources != nil {
				for _, resources := range zones.Resources {
					resourcesMap := map[string]interface{}{}

					if resources.Id != nil {
						resourcesMap["id"] = resources.Id
					}

					if resources.PayMode != nil {
						resourcesMap["pay_mode"] = resources.PayMode
					}

					if resources.CreateTime != nil {
						resourcesMap["create_time"] = resources.CreateTime
					}

					if resources.EnableTime != nil {
						resourcesMap["enable_time"] = resources.EnableTime
					}

					if resources.ExpireTime != nil {
						resourcesMap["expire_time"] = resources.ExpireTime
					}

					if resources.Status != nil {
						resourcesMap["status"] = resources.Status
					}

					svList := make([]map[string]interface{}, 0, len(resources.Sv))
					if resources.Sv != nil {
						for _, sv := range resources.Sv {
							svMap := map[string]interface{}{}

							if sv.Key != nil {
								svMap["key"] = sv.Key
							}

							if sv.Value != nil {
								svMap["value"] = sv.Value
							}

							if sv.Pack != nil {
								svMap["pack"] = sv.Pack
							}

							if sv.InstanceId != nil {
								svMap["instance_id"] = sv.InstanceId
							}

							if sv.ProtectionSpecs != nil {
								svMap["protection_specs"] = sv.ProtectionSpecs
							}

							svList = append(svList, svMap)
						}

						resourcesMap["sv"] = svList
					}
					if resources.AutoRenewFlag != nil {
						resourcesMap["auto_renew_flag"] = resources.AutoRenewFlag
					}

					if resources.PlanId != nil {
						resourcesMap["plan_id"] = resources.PlanId
					}

					if resources.Area != nil {
						resourcesMap["area"] = resources.Area
					}

					if resources.Group != nil {
						resourcesMap["group"] = resources.Group
					}

					if resources.ZoneNumber != nil {
						resourcesMap["zone_number"] = resources.ZoneNumber
					}

					if resources.Type != nil {
						resourcesMap["type"] = resources.Type
					}

					resourcesList = append(resourcesList, resourcesMap)
				}

				zonesMap["resources"] = resourcesList
			}
			if zones.CreatedOn != nil {
				zonesMap["created_on"] = zones.CreatedOn
			}

			if zones.ModifiedOn != nil {
				zonesMap["modified_on"] = zones.ModifiedOn
			}

			if zones.Area != nil {
				zonesMap["area"] = zones.Area
			}

			vanityNameServersMap := map[string]interface{}{}

			if zones.VanityNameServers != nil {
				if zones.VanityNameServers.Switch != nil {
					vanityNameServersMap["switch"] = zones.VanityNameServers.Switch
				}

				if zones.VanityNameServers.Servers != nil {
					vanityNameServersMap["servers"] = zones.VanityNameServers.Servers
				}

				zonesMap["vanity_name_servers"] = []interface{}{vanityNameServersMap}
			}

			vanityNameServersIpsList := make([]map[string]interface{}, 0, len(zones.VanityNameServersIps))
			if zones.VanityNameServersIps != nil {
				for _, vanityNameServersIps := range zones.VanityNameServersIps {
					vanityNameServersIpsMap := map[string]interface{}{}

					if vanityNameServersIps.Name != nil {
						vanityNameServersIpsMap["name"] = vanityNameServersIps.Name
					}

					if vanityNameServersIps.IPv4 != nil {
						vanityNameServersIpsMap["i_pv4"] = vanityNameServersIps.IPv4
					}

					vanityNameServersIpsList = append(vanityNameServersIpsList, vanityNameServersIpsMap)
				}

				zonesMap["vanity_name_servers_ips"] = vanityNameServersIpsList
			}
			if zones.ActiveStatus != nil {
				zonesMap["active_status"] = zones.ActiveStatus
			}

			if zones.AliasZoneName != nil {
				zonesMap["alias_zone_name"] = zones.AliasZoneName
			}

			if zones.IsFake != nil {
				zonesMap["is_fake"] = zones.IsFake
			}

			if zones.LockStatus != nil {
				zonesMap["lock_status"] = zones.LockStatus
			}

			ownershipVerificationMap := map[string]interface{}{}

			if zones.OwnershipVerification != nil {
				dnsVerificationMap := map[string]interface{}{}

				if zones.OwnershipVerification.DnsVerification != nil {
					if zones.OwnershipVerification.DnsVerification.Subdomain != nil {
						dnsVerificationMap["subdomain"] = zones.OwnershipVerification.DnsVerification.Subdomain
					}

					if zones.OwnershipVerification.DnsVerification.RecordType != nil {
						dnsVerificationMap["record_type"] = zones.OwnershipVerification.DnsVerification.RecordType
					}

					if zones.OwnershipVerification.DnsVerification.RecordValue != nil {
						dnsVerificationMap["record_value"] = zones.OwnershipVerification.DnsVerification.RecordValue
					}

					ownershipVerificationMap["dns_verification"] = []interface{}{dnsVerificationMap}
				}

				fileVerificationMap := map[string]interface{}{}

				if zones.OwnershipVerification.FileVerification != nil {
					if zones.OwnershipVerification.FileVerification.Path != nil {
						fileVerificationMap["path"] = zones.OwnershipVerification.FileVerification.Path
					}

					if zones.OwnershipVerification.FileVerification.Content != nil {
						fileVerificationMap["content"] = zones.OwnershipVerification.FileVerification.Content
					}

					ownershipVerificationMap["file_verification"] = []interface{}{fileVerificationMap}
				}

				nsVerificationMap := map[string]interface{}{}

				if zones.OwnershipVerification.NsVerification != nil {
					if zones.OwnershipVerification.NsVerification.NameServers != nil {
						nsVerificationMap["name_servers"] = zones.OwnershipVerification.NsVerification.NameServers
					}

					ownershipVerificationMap["ns_verification"] = []interface{}{nsVerificationMap}
				}

				zonesMap["ownership_verification"] = []interface{}{ownershipVerificationMap}
			}

			zoneIds = append(zoneIds, zoneId)
			zonesList = append(zonesList, zonesMap)
		}

		_ = d.Set("zones", zonesList)
	}

	d.SetId(helper.DataResourceIdsHash(zoneIds))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), zonesList); e != nil {
			return e
		}
	}

	return nil
}
