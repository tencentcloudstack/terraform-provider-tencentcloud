// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teov20220901 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTeoL7AccSetting() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudTeoL7AccSettingCreate,
		Read:   resourceTencentCloudTeoL7AccSettingRead,
		Update: resourceTencentCloudTeoL7AccSettingUpdate,
		Delete: resourceTencentCloudTeoL7AccSettingDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Zone id.",
			},

			"zone_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Zone name.",
			},

			"zone_config": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "Site acceleration global configuration. the settings in this parameter will apply to all domain names under the site. you only need to modify the required settings directly, and other settings not passed in will remain unchanged.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"smart_routing": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Intelligent acceleration configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable smart acceleration. values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"cache": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Node cache expiration time configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"follow_origin": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Follow origin server cache configuration. only one of followorigin, nocache, customtime can have switch set to on.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"switch": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Whether to enable the configuration of following the origin server. Valid values:\non: Enable;\noff: Disable.",
												},
												"default_cache": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Whether to cache when an origin server does not return the cache-control header. this field is required when switch is on; when switch is off, this field is not required and will be ineffective if filled. valid values:\non: Cache;\noff: Do not cache.",
												},
												"default_cache_strategy": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Whether to use the default caching policy when an origin server does not return the cache-control header. this field is required when defaultcache is set to on; otherwise, it is ineffective. when defaultcachetime is not 0, this field should be off. valid values:\non: Use the default caching policy.\noff: Do not use the default caching policy.",
												},
												"default_cache_time": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "The default cache time in seconds when an origin server does not return the cache-control header. the value ranges from 0 to 315360000. this field is required when defaultcache is set to on; otherwise, it is ineffective. when defaultcachestrategy is on, this field should be 0.",
												},
											},
										},
									},
									"no_cache": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "No cache configuration. only one of followorigin, nocache, customtime can have switch set to on.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"switch": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Whether to enable no-cache configuration. Valid values:\non: Enable;\noff: Disable.",
												},
											},
										},
									},
									"custom_time": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Custom cache time configuration. only one of followorigin, nocache, customtime can have switch set to on.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"switch": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Custom cache time switch. values:\non: Enable;\noff: Disable.",
												},
												"cache_time": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Custom cache time value, unit: seconds. value range: 0-315360000.\nNote: This field is required when switch is on; when switch is off, this field is not required and will not take effect if filled.",
												},
											},
										},
									},
								},
							},
						},
						"max_age": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Browser cache rule configuration, which is used to set the default value of maxage and is disabled by default.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"follow_origin": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Specifies whether to follow the origin server cache-control configuration, with the following values:\non: Follow the origin server and ignore the field cachetime;\noff: Do not follow the origin server and apply the field cachetime.",
									},
									"cache_time": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Custom cache time value, unit: seconds. value range: 0-315360000.\nNote: When followorigin is off, it means not following the origin server and using cachetime to set the cache time; otherwise, this field will not take effect.",
									},
								},
							},
						},
						"cache_key": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "The node cache key configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"full_url_cache": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable full-path cache. values:\non: Enable full-path cache (i.e., disable ignore query string);\noff: Disable full-path cache (i.e., enable ignore query string).",
									},
									"ignore_case": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to ignore case in the cache key. values:\non: Ignore;\noff: Not ignore.",
									},
									"query_string": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Query string retention configuration parameter. this field and fullurlcache must be set simultaneously, but cannot both be on.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"switch": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Query string retain/ignore specified parameter switch. valid values are:\non: Enable;\noff: Disable.",
												},
												"action": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Actions to retain/ignore specified parameters in the query string. values:\nincludeCustom: retain partial parameters;\nexcludeCustom: ignore partial parameters.\nNote: This field is required when switch is on. when switch is off, this field is not required and will not take effect if filled.",
												},
												"values": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: "List of parameter names to be retained/ignored in the query string.\nnote: This field is required when switch is on. when switch is off, this field is not required and will not take effect if filled.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
						"cache_prefresh": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Cache prefresh configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable cache prefresh. values:\non: Enable;\noff: Disable.",
									},
									"cache_time_percent": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Prefresh interval set as a percentage of the node cache time. value range: 1-99.\nNote: This field is required when switch is on; when switch is off, this field is not required and will not take effect if filled.",
									},
								},
							},
						},
						"offline_cache": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Offline cache configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable offline caching. values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"compression": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Smart compression configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable smart compression. values:\non: Enable;\noff: Disable.",
									},
									"algorithms": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "Supported compression algorithm list. this field is required when switch is on; otherwise, it is not effective. valid values:\nbrotli: Brotli algorithm;\ngzip: Gzip algorithm.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"force_redirect_https": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Forced https redirect configuration for access protocols.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable forced redirect configuration switch. values:\non: Enable;\noff: Disable.",
									},
									"redirect_status_code": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Redirection status code. this field is required when switch is on; otherwise, it is not effective. valid values are:\n301: 301 redirect;\n302: 302 redirect.",
									},
								},
							},
						},
						"hsts": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "HSTS configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable hsts. values:\non: Enable;\noff: Disable.",
									},
									"timeout": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Cache hsts header time, unit: seconds. value range: 1-31536000.\nNote: This field is required when switch is on; when switch is off, this field is not required and will not take effect if filled.",
									},
									"include_sub_domains": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to allow other subdomains to inherit the same hsts header. values:\non: Allows other subdomains to inherit the same hsts header;\noff: Does not allow other subdomains to inherit the same hsts header.\nNote: When switch is on, this field is required; when switch is off, this field is not required and will not take effect if filled.",
									},
									"preload": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to allow the browser to preload the hsts header. valid values:\non: Allows the browser to preload the hsts header;\noff: Does not allow the browser to preload the hsts header.\nNote: When switch is on, this field is required; when switch is off, this field is not required and will not take effect if filled.",
									},
								},
							},
						},
						"tls_config": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "TLS configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"version": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "TLS version. at least one must be specified. if multiple versions are specified, they must be consecutive, e.g., enable tls1, 1.1, 1.2, and 1.3. it is not allowed to enable only 1 and 1.2 while disabling 1.1. valid values:\nTLSv1: TLSv1 version;\nTLSv1.1: TLSv1.1 version;\nTLSv1.2: TLSv1.2 version;\nTLSv1.3: TLSv1.3 version.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"cipher_suite": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Cipher suite. for detailed information, please refer to tls versions and cipher suites description. valid values:\nloose-v2023: loose-v2023 cipher suite;\ngeneral-v2023: general-v2023 cipher suite;\nstrict-v2023: strict-v2023 cipher suite.",
									},
								},
							},
						},
						"ocsp_stapling": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "OCSP stapling configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable ocsp stapling configuration switch. values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"http2": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "HTTP/2 configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable http2 access. values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"quic": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "QUIC access configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable quic. values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"upstream_http2": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "HTTP2 origin-pull configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable http2 origin-pull. valid values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"ipv6": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "IPv6 access configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable ipv6 access functionality. valid values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"web_socket": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "WebSocket configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable websocket connection timeout. values:\non: Use timeout as the websocket timeout;\noff: The platform still supports websocket connections, using the system default timeout of 15 seconds.",
									},
									"timeout": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout, unit: seconds. maximum timeout is 120 seconds.\nNote: This field is required when switch is on; otherwise, this field will not take effect.",
									},
								},
							},
						},
						"post_max_size": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "POST request transport configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable post request file upload limit, in bytes (default limit: 32 * 2^20 bytes). valid values:\non: Enable limit;\noff: Disable limit.",
									},
									"max_size": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Maximum size of the file uploaded for streaming via a post request, in bytes. value range: 1 * 2^20 bytes to 500 * 2^20 bytes.",
									},
								},
							},
						},
						"client_ip_header": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Client ip origin-pull request header configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable configuration. values:\non: Enable;\noff: Disable.",
									},
									"header_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Name of the request header containing the client ip address for origin-pull. when switch is on, this parameter is required. x-forwarded-for is not allowed for this parameter.",
									},
								},
							},
						},
						"client_ip_country": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Client ip origin-pull request header configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable configuration. Values:\non: Enable;\noff: Disable.",
									},
									"header_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Name of the request header that contains the client IP region. It is valid when Switch=on.\nThe default value EO-Client-IPCountry is used when it is not specified.",
									},
								},
							},
						},
						"grpc": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Configuration of grpc support.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable grpc. values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"accelerate_mainland": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Accelerate optimization and configuration in mainland china.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Mainland china acceleration optimization switch. valid values:\non: Enable;\noff: Disable.",
									},
								},
							},
						},
						"standard_debug": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Standard debugging configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"switch": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Whether to enable standard debugging. values:\non: Enable;\noff: Disable.",
									},
									"allow_client_ip_list": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "The client ip to allow. it can be an ipv4/ipv6 address or a cidr block. `0.0.0.0/0` means to allow all ipv4 clients for debugging; `::/0` means to allow all ipv6 clients for debugging; `127.0.0.1` is not allowed.\nNote: this field is required when switch=on and the number of entries should be 1-100. when switch=off, this field is not required and any value specified will not take effect.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"expires": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Debug feature expiration time. the feature will be disabled after the set time.\nNote: this field is required when switch=on. when switch=off, this field is not required and any value specified will not take effect.",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudTeoL7AccSettingCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l7_acc_setting.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		zoneId string
	)
	if v, ok := d.GetOk("zone_id"); ok {
		zoneId = v.(string)
	}

	d.SetId(zoneId)

	return resourceTencentCloudTeoL7AccSettingUpdate(d, meta)
}

func resourceTencentCloudTeoL7AccSettingRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l7_acc_setting.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	zoneId := d.Id()

	_ = d.Set("zone_id", zoneId)

	respData, err := service.DescribeTeoL7AccSettingById(ctx, zoneId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `teo_l7_acc_setting` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.ZoneName != nil {
		_ = d.Set("zone_name", respData.ZoneName)
	}

	zoneConfigMap := map[string]interface{}{}

	if respData.ZoneConfig != nil {
		smartRoutingMap := map[string]interface{}{}

		if respData.ZoneConfig.SmartRouting != nil {
			if respData.ZoneConfig.SmartRouting.Switch != nil {
				smartRoutingMap["switch"] = respData.ZoneConfig.SmartRouting.Switch
			}

			zoneConfigMap["smart_routing"] = []interface{}{smartRoutingMap}
		}

		cacheMap := map[string]interface{}{}

		if respData.ZoneConfig.Cache != nil {
			followOriginMap := map[string]interface{}{}

			if respData.ZoneConfig.Cache.FollowOrigin != nil {
				if respData.ZoneConfig.Cache.FollowOrigin.Switch != nil {
					followOriginMap["switch"] = respData.ZoneConfig.Cache.FollowOrigin.Switch
				}

				if respData.ZoneConfig.Cache.FollowOrigin.DefaultCache != nil {
					followOriginMap["default_cache"] = respData.ZoneConfig.Cache.FollowOrigin.DefaultCache
				}

				if respData.ZoneConfig.Cache.FollowOrigin.DefaultCacheStrategy != nil {
					followOriginMap["default_cache_strategy"] = respData.ZoneConfig.Cache.FollowOrigin.DefaultCacheStrategy
				}

				if respData.ZoneConfig.Cache.FollowOrigin.DefaultCacheTime != nil {
					followOriginMap["default_cache_time"] = respData.ZoneConfig.Cache.FollowOrigin.DefaultCacheTime
				}

				cacheMap["follow_origin"] = []interface{}{followOriginMap}
			}

			noCacheMap := map[string]interface{}{}

			if respData.ZoneConfig.Cache.NoCache != nil {
				if respData.ZoneConfig.Cache.NoCache.Switch != nil {
					noCacheMap["switch"] = respData.ZoneConfig.Cache.NoCache.Switch
				}

				cacheMap["no_cache"] = []interface{}{noCacheMap}
			}

			customTimeMap := map[string]interface{}{}

			if respData.ZoneConfig.Cache.CustomTime != nil {
				if respData.ZoneConfig.Cache.CustomTime.Switch != nil {
					customTimeMap["switch"] = respData.ZoneConfig.Cache.CustomTime.Switch
				}

				if respData.ZoneConfig.Cache.CustomTime.CacheTime != nil {
					customTimeMap["cache_time"] = respData.ZoneConfig.Cache.CustomTime.CacheTime
				}

				cacheMap["custom_time"] = []interface{}{customTimeMap}
			}

			zoneConfigMap["cache"] = []interface{}{cacheMap}
		}

		maxAgeMap := map[string]interface{}{}

		if respData.ZoneConfig.MaxAge != nil {
			if respData.ZoneConfig.MaxAge.FollowOrigin != nil {
				maxAgeMap["follow_origin"] = respData.ZoneConfig.MaxAge.FollowOrigin
			}

			if respData.ZoneConfig.MaxAge.CacheTime != nil {
				maxAgeMap["cache_time"] = respData.ZoneConfig.MaxAge.CacheTime
			}

			zoneConfigMap["max_age"] = []interface{}{maxAgeMap}
		}

		cacheKeyMap := map[string]interface{}{}

		if respData.ZoneConfig.CacheKey != nil {
			if respData.ZoneConfig.CacheKey.FullURLCache != nil {
				cacheKeyMap["full_url_cache"] = respData.ZoneConfig.CacheKey.FullURLCache
			}

			if respData.ZoneConfig.CacheKey.IgnoreCase != nil {
				cacheKeyMap["ignore_case"] = respData.ZoneConfig.CacheKey.IgnoreCase
			}

			queryStringMap := map[string]interface{}{}

			if respData.ZoneConfig.CacheKey.QueryString != nil {
				if respData.ZoneConfig.CacheKey.QueryString.Switch != nil {
					queryStringMap["switch"] = respData.ZoneConfig.CacheKey.QueryString.Switch
				}

				if respData.ZoneConfig.CacheKey.QueryString.Action != nil {
					queryStringMap["action"] = respData.ZoneConfig.CacheKey.QueryString.Action
				}

				if respData.ZoneConfig.CacheKey.QueryString.Values != nil {
					queryStringMap["values"] = respData.ZoneConfig.CacheKey.QueryString.Values
				}

				cacheKeyMap["query_string"] = []interface{}{queryStringMap}
			}

			zoneConfigMap["cache_key"] = []interface{}{cacheKeyMap}
		}

		cachePrefreshMap := map[string]interface{}{}

		if respData.ZoneConfig.CachePrefresh != nil {
			if respData.ZoneConfig.CachePrefresh.Switch != nil {
				cachePrefreshMap["switch"] = respData.ZoneConfig.CachePrefresh.Switch
			}

			if respData.ZoneConfig.CachePrefresh.CacheTimePercent != nil {
				cachePrefreshMap["cache_time_percent"] = respData.ZoneConfig.CachePrefresh.CacheTimePercent
			}

			zoneConfigMap["cache_prefresh"] = []interface{}{cachePrefreshMap}
		}

		offlineCacheMap := map[string]interface{}{}

		if respData.ZoneConfig.OfflineCache != nil {
			if respData.ZoneConfig.OfflineCache.Switch != nil {
				offlineCacheMap["switch"] = respData.ZoneConfig.OfflineCache.Switch
			}

			zoneConfigMap["offline_cache"] = []interface{}{offlineCacheMap}
		}

		compressionMap := map[string]interface{}{}

		if respData.ZoneConfig.Compression != nil {
			if respData.ZoneConfig.Compression.Switch != nil {
				compressionMap["switch"] = respData.ZoneConfig.Compression.Switch
			}

			if respData.ZoneConfig.Compression.Algorithms != nil {
				compressionMap["algorithms"] = respData.ZoneConfig.Compression.Algorithms
			}

			zoneConfigMap["compression"] = []interface{}{compressionMap}
		}

		forceRedirectHTTPSMap := map[string]interface{}{}

		if respData.ZoneConfig.ForceRedirectHTTPS != nil {
			if respData.ZoneConfig.ForceRedirectHTTPS.Switch != nil {
				forceRedirectHTTPSMap["switch"] = respData.ZoneConfig.ForceRedirectHTTPS.Switch
			}

			if respData.ZoneConfig.ForceRedirectHTTPS.RedirectStatusCode != nil {
				forceRedirectHTTPSMap["redirect_status_code"] = respData.ZoneConfig.ForceRedirectHTTPS.RedirectStatusCode
			}

			zoneConfigMap["force_redirect_https"] = []interface{}{forceRedirectHTTPSMap}
		}

		hSTSMap := map[string]interface{}{}

		if respData.ZoneConfig.HSTS != nil {
			if respData.ZoneConfig.HSTS.Switch != nil {
				hSTSMap["switch"] = respData.ZoneConfig.HSTS.Switch
			}

			if respData.ZoneConfig.HSTS.Timeout != nil {
				hSTSMap["timeout"] = respData.ZoneConfig.HSTS.Timeout
			}

			if respData.ZoneConfig.HSTS.IncludeSubDomains != nil {
				hSTSMap["include_sub_domains"] = respData.ZoneConfig.HSTS.IncludeSubDomains
			}

			if respData.ZoneConfig.HSTS.Preload != nil {
				hSTSMap["preload"] = respData.ZoneConfig.HSTS.Preload
			}

			zoneConfigMap["hsts"] = []interface{}{hSTSMap}
		}

		tLSConfigMap := map[string]interface{}{}

		if respData.ZoneConfig.TLSConfig != nil {
			if respData.ZoneConfig.TLSConfig.Version != nil {
				tLSConfigMap["version"] = respData.ZoneConfig.TLSConfig.Version
			}

			if respData.ZoneConfig.TLSConfig.CipherSuite != nil {
				tLSConfigMap["cipher_suite"] = respData.ZoneConfig.TLSConfig.CipherSuite
			}

			zoneConfigMap["tls_config"] = []interface{}{tLSConfigMap}
		}

		oCSPStaplingMap := map[string]interface{}{}

		if respData.ZoneConfig.OCSPStapling != nil {
			if respData.ZoneConfig.OCSPStapling.Switch != nil {
				oCSPStaplingMap["switch"] = respData.ZoneConfig.OCSPStapling.Switch
			}

			zoneConfigMap["ocsp_stapling"] = []interface{}{oCSPStaplingMap}
		}

		hTTP2Map := map[string]interface{}{}

		if respData.ZoneConfig.HTTP2 != nil {
			if respData.ZoneConfig.HTTP2.Switch != nil {
				hTTP2Map["switch"] = respData.ZoneConfig.HTTP2.Switch
			}

			zoneConfigMap["http2"] = []interface{}{hTTP2Map}
		}

		qUICMap := map[string]interface{}{}

		if respData.ZoneConfig.QUIC != nil {
			if respData.ZoneConfig.QUIC.Switch != nil {
				qUICMap["switch"] = respData.ZoneConfig.QUIC.Switch
			}

			zoneConfigMap["quic"] = []interface{}{qUICMap}
		}

		upstreamHTTP2Map := map[string]interface{}{}

		if respData.ZoneConfig.UpstreamHTTP2 != nil {
			if respData.ZoneConfig.UpstreamHTTP2.Switch != nil {
				upstreamHTTP2Map["switch"] = respData.ZoneConfig.UpstreamHTTP2.Switch
			}

			zoneConfigMap["upstream_http2"] = []interface{}{upstreamHTTP2Map}
		}

		iPv6Map := map[string]interface{}{}

		if respData.ZoneConfig.IPv6 != nil {
			if respData.ZoneConfig.IPv6.Switch != nil {
				iPv6Map["switch"] = respData.ZoneConfig.IPv6.Switch
			}

			zoneConfigMap["ipv6"] = []interface{}{iPv6Map}
		}

		webSocketMap := map[string]interface{}{}

		if respData.ZoneConfig.WebSocket != nil {
			if respData.ZoneConfig.WebSocket.Switch != nil {
				webSocketMap["switch"] = respData.ZoneConfig.WebSocket.Switch
			}

			if respData.ZoneConfig.WebSocket.Timeout != nil {
				webSocketMap["timeout"] = respData.ZoneConfig.WebSocket.Timeout
			}

			zoneConfigMap["web_socket"] = []interface{}{webSocketMap}
		}

		postMaxSizeMap := map[string]interface{}{}

		if respData.ZoneConfig.PostMaxSize != nil {
			if respData.ZoneConfig.PostMaxSize.Switch != nil {
				postMaxSizeMap["switch"] = respData.ZoneConfig.PostMaxSize.Switch
			}

			if respData.ZoneConfig.PostMaxSize.MaxSize != nil {
				postMaxSizeMap["max_size"] = respData.ZoneConfig.PostMaxSize.MaxSize
			}

			zoneConfigMap["post_max_size"] = []interface{}{postMaxSizeMap}
		}

		clientIPHeaderMap := map[string]interface{}{}

		if respData.ZoneConfig.ClientIPHeader != nil {
			if respData.ZoneConfig.ClientIPHeader.Switch != nil {
				clientIPHeaderMap["switch"] = respData.ZoneConfig.ClientIPHeader.Switch
			}

			if respData.ZoneConfig.ClientIPHeader.HeaderName != nil {
				clientIPHeaderMap["header_name"] = respData.ZoneConfig.ClientIPHeader.HeaderName
			}

			zoneConfigMap["client_ip_header"] = []interface{}{clientIPHeaderMap}
		}

		clientIPCountryMap := map[string]interface{}{}

		if respData.ZoneConfig.ClientIPCountry != nil {
			if respData.ZoneConfig.ClientIPCountry.Switch != nil {
				clientIPCountryMap["switch"] = respData.ZoneConfig.ClientIPCountry.Switch
			}

			if respData.ZoneConfig.ClientIPCountry.HeaderName != nil {
				clientIPCountryMap["header_name"] = respData.ZoneConfig.ClientIPCountry.HeaderName
			}

			zoneConfigMap["client_ip_country"] = []interface{}{clientIPCountryMap}
		}

		grpcMap := map[string]interface{}{}

		if respData.ZoneConfig.Grpc != nil {
			if respData.ZoneConfig.Grpc.Switch != nil {
				grpcMap["switch"] = respData.ZoneConfig.Grpc.Switch
			}

			zoneConfigMap["grpc"] = []interface{}{grpcMap}
		}

		accelerateMainlandMap := map[string]interface{}{}

		if respData.ZoneConfig.AccelerateMainland != nil {
			if respData.ZoneConfig.AccelerateMainland.Switch != nil {
				accelerateMainlandMap["switch"] = respData.ZoneConfig.AccelerateMainland.Switch
			}

			zoneConfigMap["accelerate_mainland"] = []interface{}{accelerateMainlandMap}
		}

		standardDebugMap := map[string]interface{}{}

		if respData.ZoneConfig.StandardDebug != nil {
			if respData.ZoneConfig.StandardDebug.Switch != nil {
				standardDebugMap["switch"] = respData.ZoneConfig.StandardDebug.Switch
			}

			if respData.ZoneConfig.StandardDebug.AllowClientIPList != nil {
				standardDebugMap["allow_client_ip_list"] = respData.ZoneConfig.StandardDebug.AllowClientIPList
			}

			if respData.ZoneConfig.StandardDebug.Expires != nil {
				standardDebugMap["expires"] = respData.ZoneConfig.StandardDebug.Expires
			}

			zoneConfigMap["standard_debug"] = []interface{}{standardDebugMap}
		}

		_ = d.Set("zone_config", []interface{}{zoneConfigMap})
	}

	return nil
}

func resourceTencentCloudTeoL7AccSettingUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l7_acc_setting.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	zoneId := d.Id()

	needChange := false
	mutableArgs := []string{"zone_config"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := teov20220901.NewModifyL7AccSettingRequest()

		request.ZoneId = helper.String(zoneId)

		if zoneConfigMap, ok := helper.InterfacesHeadMap(d, "zone_config"); ok {
			zoneConfig := teov20220901.ZoneConfig{}
			if smartRoutingMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["smart_routing"]); ok {
				smartRoutingParameters := teov20220901.SmartRoutingParameters{}
				if v, ok := smartRoutingMap["switch"].(string); ok && v != "" {
					smartRoutingParameters.Switch = helper.String(v)
				}
				zoneConfig.SmartRouting = &smartRoutingParameters
			}
			if cacheMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["cache"]); ok {
				cacheConfigParameters := teov20220901.CacheConfigParameters{}
				if followOriginMap, ok := helper.ConvertInterfacesHeadToMap(cacheMap["follow_origin"]); ok {
					followOrigin := teov20220901.FollowOrigin{}
					if v, ok := followOriginMap["switch"].(string); ok && v != "" {
						followOrigin.Switch = helper.String(v)
					}
					if v, ok := followOriginMap["default_cache"].(string); ok && v != "" {
						followOrigin.DefaultCache = helper.String(v)
					}
					if v, ok := followOriginMap["default_cache_strategy"].(string); ok && v != "" {
						followOrigin.DefaultCacheStrategy = helper.String(v)
					}
					if v, ok := followOriginMap["default_cache_time"].(int); ok {
						followOrigin.DefaultCacheTime = helper.IntInt64(v)
					}
					cacheConfigParameters.FollowOrigin = &followOrigin
				}
				if noCacheMap, ok := helper.ConvertInterfacesHeadToMap(cacheMap["no_cache"]); ok {
					noCache := teov20220901.NoCache{}
					if v, ok := noCacheMap["switch"].(string); ok && v != "" {
						noCache.Switch = helper.String(v)
					}
					cacheConfigParameters.NoCache = &noCache
				}
				if customTimeMap, ok := helper.ConvertInterfacesHeadToMap(cacheMap["custom_time"]); ok {
					cacheConfigCustomTime := teov20220901.CacheConfigCustomTime{}
					if v, ok := customTimeMap["switch"].(string); ok && v != "" {
						cacheConfigCustomTime.Switch = helper.String(v)
					}
					if v, ok := customTimeMap["cache_time"].(int); ok {
						cacheConfigCustomTime.CacheTime = helper.IntInt64(v)
					}
					cacheConfigParameters.CustomTime = &cacheConfigCustomTime
				}
				zoneConfig.Cache = &cacheConfigParameters
			}
			if maxAgeMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["max_age"]); ok {
				maxAgeParameters := teov20220901.MaxAgeParameters{}
				if v, ok := maxAgeMap["follow_origin"].(string); ok && v != "" {
					maxAgeParameters.FollowOrigin = helper.String(v)
				}
				if v, ok := maxAgeMap["cache_time"].(int); ok {
					maxAgeParameters.CacheTime = helper.IntInt64(v)
				}
				zoneConfig.MaxAge = &maxAgeParameters
			}
			if cacheKeyMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["cache_key"]); ok {
				cacheKeyConfigParameters := teov20220901.CacheKeyConfigParameters{}
				if v, ok := cacheKeyMap["full_url_cache"].(string); ok && v != "" {
					cacheKeyConfigParameters.FullURLCache = helper.String(v)
				}
				if v, ok := cacheKeyMap["ignore_case"].(string); ok && v != "" {
					cacheKeyConfigParameters.IgnoreCase = helper.String(v)
				}
				if queryStringMap, ok := helper.ConvertInterfacesHeadToMap(cacheKeyMap["query_string"]); ok {
					cacheKeyQueryString := teov20220901.CacheKeyQueryString{}
					if v, ok := queryStringMap["switch"].(string); ok && v != "" {
						cacheKeyQueryString.Switch = helper.String(v)
					}
					if v, ok := queryStringMap["action"].(string); ok && v != "" {
						cacheKeyQueryString.Action = helper.String(v)
					}
					if v, ok := queryStringMap["values"]; ok {
						valuesSet := v.(*schema.Set).List()
						for i := range valuesSet {
							values := valuesSet[i].(string)
							cacheKeyQueryString.Values = append(cacheKeyQueryString.Values, helper.String(values))
						}
					}
					cacheKeyConfigParameters.QueryString = &cacheKeyQueryString
				}
				zoneConfig.CacheKey = &cacheKeyConfigParameters
			}
			if cachePrefreshMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["cache_prefresh"]); ok {
				cachePrefreshParameters := teov20220901.CachePrefreshParameters{}
				if v, ok := cachePrefreshMap["switch"].(string); ok && v != "" {
					cachePrefreshParameters.Switch = helper.String(v)
				}
				if v, ok := cachePrefreshMap["cache_time_percent"].(int); ok {
					cachePrefreshParameters.CacheTimePercent = helper.IntInt64(v)
				}
				zoneConfig.CachePrefresh = &cachePrefreshParameters
			}
			if offlineCacheMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["offline_cache"]); ok {
				offlineCacheParameters := teov20220901.OfflineCacheParameters{}
				if v, ok := offlineCacheMap["switch"].(string); ok && v != "" {
					offlineCacheParameters.Switch = helper.String(v)
				}
				zoneConfig.OfflineCache = &offlineCacheParameters
			}
			if compressionMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["compression"]); ok {
				compressionParameters := teov20220901.CompressionParameters{}
				if v, ok := compressionMap["switch"].(string); ok && v != "" {
					compressionParameters.Switch = helper.String(v)
				}
				if v, ok := compressionMap["algorithms"]; ok {
					algorithmsSet := v.(*schema.Set).List()
					for i := range algorithmsSet {
						algorithms := algorithmsSet[i].(string)
						compressionParameters.Algorithms = append(compressionParameters.Algorithms, helper.String(algorithms))
					}
				}
				zoneConfig.Compression = &compressionParameters
			}
			if forceRedirectHTTPSMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["force_redirect_https"]); ok {
				forceRedirectHTTPSParameters := teov20220901.ForceRedirectHTTPSParameters{}
				if v, ok := forceRedirectHTTPSMap["switch"].(string); ok && v != "" {
					forceRedirectHTTPSParameters.Switch = helper.String(v)
				}
				if v, ok := forceRedirectHTTPSMap["redirect_status_code"].(int); ok {
					forceRedirectHTTPSParameters.RedirectStatusCode = helper.IntInt64(v)
				}
				zoneConfig.ForceRedirectHTTPS = &forceRedirectHTTPSParameters
			}
			if hSTSMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["hsts"]); ok {
				hSTSParameters := teov20220901.HSTSParameters{}
				if v, ok := hSTSMap["switch"].(string); ok && v != "" {
					hSTSParameters.Switch = helper.String(v)
				}
				if v, ok := hSTSMap["timeout"].(int); ok {
					hSTSParameters.Timeout = helper.IntInt64(v)
				}
				if v, ok := hSTSMap["include_sub_domains"].(string); ok && v != "" {
					hSTSParameters.IncludeSubDomains = helper.String(v)
				}
				if v, ok := hSTSMap["preload"].(string); ok && v != "" {
					hSTSParameters.Preload = helper.String(v)
				}
				zoneConfig.HSTS = &hSTSParameters
			}
			if tLSConfigMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["tls_config"]); ok {
				tLSConfigParameters := teov20220901.TLSConfigParameters{}
				if v, ok := tLSConfigMap["version"]; ok {
					versionSet := v.(*schema.Set).List()
					for i := range versionSet {
						version := versionSet[i].(string)
						tLSConfigParameters.Version = append(tLSConfigParameters.Version, helper.String(version))
					}
				}
				if v, ok := tLSConfigMap["cipher_suite"].(string); ok && v != "" {
					tLSConfigParameters.CipherSuite = helper.String(v)
				}
				zoneConfig.TLSConfig = &tLSConfigParameters
			}
			if oCSPStaplingMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["ocsp_stapling"]); ok {
				oCSPStaplingParameters := teov20220901.OCSPStaplingParameters{}
				if v, ok := oCSPStaplingMap["switch"].(string); ok && v != "" {
					oCSPStaplingParameters.Switch = helper.String(v)
				}
				zoneConfig.OCSPStapling = &oCSPStaplingParameters
			}
			if hTTP2Map, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["http2"]); ok {
				hTTP2Parameters := teov20220901.HTTP2Parameters{}
				if v, ok := hTTP2Map["switch"].(string); ok && v != "" {
					hTTP2Parameters.Switch = helper.String(v)
				}
				zoneConfig.HTTP2 = &hTTP2Parameters
			}
			if qUICMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["quic"]); ok {
				qUICParameters := teov20220901.QUICParameters{}
				if v, ok := qUICMap["switch"].(string); ok && v != "" {
					qUICParameters.Switch = helper.String(v)
				}
				zoneConfig.QUIC = &qUICParameters
			}
			if upstreamHTTP2Map, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["upstream_http2"]); ok {
				upstreamHTTP2Parameters := teov20220901.UpstreamHTTP2Parameters{}
				if v, ok := upstreamHTTP2Map["switch"].(string); ok && v != "" {
					upstreamHTTP2Parameters.Switch = helper.String(v)
				}
				zoneConfig.UpstreamHTTP2 = &upstreamHTTP2Parameters
			}
			if iPv6Map, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["ipv6"]); ok {
				iPv6Parameters := teov20220901.IPv6Parameters{}
				if v, ok := iPv6Map["switch"].(string); ok && v != "" {
					iPv6Parameters.Switch = helper.String(v)
				}
				zoneConfig.IPv6 = &iPv6Parameters
			}
			if webSocketMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["web_socket"]); ok {
				webSocketParameters := teov20220901.WebSocketParameters{}
				if v, ok := webSocketMap["switch"].(string); ok && v != "" {
					webSocketParameters.Switch = helper.String(v)
				}
				if v, ok := webSocketMap["timeout"].(int); ok {
					webSocketParameters.Timeout = helper.IntInt64(v)
				}
				zoneConfig.WebSocket = &webSocketParameters
			}
			if postMaxSizeMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["post_max_size"]); ok {
				postMaxSizeParameters := teov20220901.PostMaxSizeParameters{}
				if v, ok := postMaxSizeMap["switch"].(string); ok && v != "" {
					postMaxSizeParameters.Switch = helper.String(v)
				}
				if v, ok := postMaxSizeMap["max_size"].(int); ok {
					postMaxSizeParameters.MaxSize = helper.IntInt64(v)
				}
				zoneConfig.PostMaxSize = &postMaxSizeParameters
			}
			if clientIPHeaderMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["client_ip_header"]); ok {
				clientIPHeaderParameters := teov20220901.ClientIPHeaderParameters{}
				if v, ok := clientIPHeaderMap["switch"].(string); ok && v != "" {
					clientIPHeaderParameters.Switch = helper.String(v)
				}
				if v, ok := clientIPHeaderMap["header_name"].(string); ok && v != "" {
					clientIPHeaderParameters.HeaderName = helper.String(v)
				}
				zoneConfig.ClientIPHeader = &clientIPHeaderParameters
			}
			if clientIPCountryMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["client_ip_country"]); ok {
				clientIPCountryParameters := teov20220901.ClientIPCountryParameters{}
				if v, ok := clientIPCountryMap["switch"].(string); ok && v != "" {
					clientIPCountryParameters.Switch = helper.String(v)
				}
				if v, ok := clientIPCountryMap["header_name"].(string); ok && v != "" {
					clientIPCountryParameters.HeaderName = helper.String(v)
				}
				zoneConfig.ClientIPCountry = &clientIPCountryParameters
			}
			if grpcMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["grpc"]); ok {
				grpcParameters := teov20220901.GrpcParameters{}
				if v, ok := grpcMap["switch"].(string); ok && v != "" {
					grpcParameters.Switch = helper.String(v)
				}
				zoneConfig.Grpc = &grpcParameters
			}
			if accelerateMainlandMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["accelerate_mainland"]); ok {
				accelerateMainlandParameters := teov20220901.AccelerateMainlandParameters{}
				if v, ok := accelerateMainlandMap["switch"].(string); ok && v != "" {
					accelerateMainlandParameters.Switch = helper.String(v)
				}
				zoneConfig.AccelerateMainland = &accelerateMainlandParameters
			}
			if standardDebugMap, ok := helper.ConvertInterfacesHeadToMap(zoneConfigMap["standard_debug"]); ok {
				standardDebugParameters := teov20220901.StandardDebugParameters{}
				if v, ok := standardDebugMap["switch"].(string); ok && v != "" {
					standardDebugParameters.Switch = helper.String(v)
				}
				if v, ok := standardDebugMap["allow_client_ip_list"]; ok {
					allowClientIPListSet := v.(*schema.Set).List()
					for i := range allowClientIPListSet {
						allowClientIPList := allowClientIPListSet[i].(string)
						standardDebugParameters.AllowClientIPList = append(standardDebugParameters.AllowClientIPList, helper.String(allowClientIPList))
					}
				}
				if v, ok := standardDebugMap["expires"].(string); ok && v != "" {
					standardDebugParameters.Expires = helper.String(v)
				}
				zoneConfig.StandardDebug = &standardDebugParameters
			}
			request.ZoneConfig = &zoneConfig
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().ModifyL7AccSettingWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update teo l7 acc setting failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	return resourceTencentCloudTeoL7AccSettingRead(d, meta)
}

func resourceTencentCloudTeoL7AccSettingDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_l7_acc_setting.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
