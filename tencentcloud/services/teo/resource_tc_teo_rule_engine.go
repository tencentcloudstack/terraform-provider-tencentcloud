// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teov20220901 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTeoRuleEngine() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudTeoRuleEngineCreate,
		Read:   resourceTencentCloudTeoRuleEngineRead,
		Update: resourceTencentCloudTeoRuleEngineUpdate,
		Delete: resourceTencentCloudTeoRuleEngineDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "ID of the site.",
			},

			"rule_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Rule ID.",
			},

			"rule_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The rule name (1 to 255 characters).",
			},

			"status": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Rule status. Values:\n  - `enable`: Enabled.\n  - `disable`: Disabled.",
			},

			"rule_priority": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Rule priority, the larger the value, the higher the priority, the minimum is 1.",
			},

			"tags": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: "rule tag list.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"rules": {
				Type:        schema.TypeList,
				Required:    true,
				Description: "Rule items list.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"or": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "OR Conditions list of the rule. Rule would be triggered if any of the condition is true.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"and": {
										Type:        schema.TypeList,
										Required:    true,
										Description: "AND Conditions list of the rule. Rule would be triggered if all conditions are true.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"operator": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Operator. Valid values:\n  - `equal`: Equal.\n  - `notEqual`: Does not equal.\n  - `exist`: Exists.\n  - `notexist`: Does not exist.",
												},
												"target": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "The match type. Values:\n  - `filename`: File name.\n  - `extension`: File extension.\n  - `host`: Host.\n  - `full_url`: Full URL, which indicates the complete URL path under the current site and must contain the HTTP protocol, host, and path.\n  - `url`: Partial URL under the current site.\n  - `client_country`: Country/Region of the client.\n  - `query_string`: Query string in the request URL.\n  - `request_header`: HTTP request header.\n  - `client_ip`: Client IP.",
												},
												"values": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: "The parameter value of the match type. It can be an empty string only when `Target=query string/request header` and `Operator=exist/notexist`.\n  - When `Target=extension`, enter the file extension, such as \"jpg\" and \"txt\".\n  - When `Target=filename`, enter the file name, such as \"foo\" in \"foo.jpg\".\n  - When `Target=all`, it indicates any site request.\n  - When `Target=host`, enter the host under the current site, such as \"www.maxx55.com\".\n  - When `Target=url`, enter the partial URL path under the current site, such as \"/example\".\n  - When `Target=full_url`, enter the complete URL under the current site. It must contain the HTTP protocol, host, and path, such as \"https://www.maxx55.cn/example\".\n  - When `Target=client_country`, enter the ISO-3166 country/region code.\n  - When `Target=query_string`, enter the value of the query string, such as \"cn\" and \"1\" in \"lang=cn&version=1\".\n  - When `Target=request_header`, enter the HTTP request header value, such as \"zh-CN,zh;q=0.9\" in the \"Accept-Language:zh-CN,zh;q=0.9\" header.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"ignore_case": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: "Whether the parameter value is case insensitive. Default value: false.",
												},
												"name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "The parameter name of the match type. This field is required only when `Target=query_string/request_header`.\n  - `query_string`: Name of the query string, such as \"lang\" and \"version\" in \"lang=cn&version=1\".\n  - `request_header`: Name of the HTTP request header, such as \"Accept-Language\" in the \"Accept-Language:zh-CN,zh;q=0.9\" header.",
												},
											},
										},
									},
								},
							},
						},
						"actions": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Feature to be executed.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"normal_action": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Common operation. Values:\n  - `AccessUrlRedirect`: Access URL rewrite.\n  - `UpstreamUrlRedirect`: Origin-pull URL rewrite.\n  - `QUIC`: QUIC.\n  - `WebSocket`: WebSocket.\n  - `VideoSeek`: Video dragging.\n  - `Authentication`: Token authentication.\n  - `CacheKey`: Custom cache key.\n  - `Cache`: Node cache TTL.\n  - `MaxAge`: Browser cache TTL.\n  - `OfflineCache`: Offline cache.\n  - `SmartRouting`: Smart acceleration.\n  - `RangeOriginPull`: Range GETs.\n  - `UpstreamHttp2`: HTTP/2 forwarding.\n  - `HostHeader`: Host header rewrite.\n  - `ForceRedirect`: Force HTTPS.\n  - `OriginPullProtocol`: Origin-pull HTTPS.\n  - `CachePrefresh`: Cache prefresh.\n  - `Compression`: Smart compression.\n  - `Hsts`.\n  - `ClientIpHeader`.\n  - `SslTlsSecureConf`.\n  - `OcspStapling`.\n  - `Http2`: HTTP/2 access.\n  - `UpstreamFollowRedirect`: Follow origin redirect.\n  - `Origin`: Origin.\nNote: This field may return `null`, indicating that no valid value can be obtained.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"action": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.",
												},
												"parameters": {
													Type:        schema.TypeList,
													Required:    true,
													Description: "Parameter.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name.",
															},
															"values": {
																Type:        schema.TypeSet,
																Required:    true,
																Description: "The parameter value.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
									"rewrite_action": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Feature operation with a request/response header. Features of this type include:\n  - `RequestHeader`: HTTP request header modification.\n  - `ResponseHeader`: HTTP response header modification.\nNote: This field may return null, indicating that no valid values can be obtained.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"action": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.",
												},
												"parameters": {
													Type:        schema.TypeList,
													Required:    true,
													Description: "Parameter.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"action": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Feature parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name, which has three values:\n  - add: Add the HTTP header.\n  - set: Rewrite the HTTP header.\n  - del: Delete the HTTP header.",
															},
															"name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"values": {
																Type:        schema.TypeSet,
																Required:    true,
																Description: "Parameter value.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
									"code_action": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Feature operation with a status code. Features of this type include:\n  - `ErrorPage`: Custom error page.\n  - `StatusCodeCache`: Status code cache TTL.\nNote: This field may return null, indicating that no valid values can be obtained.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"action": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.",
												},
												"parameters": {
													Type:        schema.TypeList,
													Required:    true,
													Description: "Operation parameter.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"status_code": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: "The status code.",
															},
															"name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "The parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name.",
															},
															"values": {
																Type:        schema.TypeSet,
																Required:    true,
																Description: "The parameter value.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"sub_rules": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "The nested rule.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"tags": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "Tag of the rule.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"rules": {
										Type:        schema.TypeList,
										Required:    true,
										Description: "Nested rule settings.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"or": {
													Type:        schema.TypeList,
													Required:    true,
													Description: "The condition that determines if a feature should run.\nNote: If any condition in the array is met, the feature will run.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"and": {
																Type:        schema.TypeList,
																Required:    true,
																Description: "Rule engine condition. This condition will be considered met if all items in the array are met.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"operator": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "Operator. Valid values:\n  - `equal`: Equal.\n  - `notEqual`: Does not equal.\n  - `exist`: Exists.\n  - `notexist`: Does not exist.",
																		},
																		"target": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "The match type. Values:\n  - `filename`: File name.\n  - `extension`: File extension.\n  - `host`: Host.\n  - `full_url`: Full URL, which indicates the complete URL path under the current site and must contain the HTTP protocol, host, and path.\n  - `url`: Partial URL under the current site.  - `client_country`: Country/Region of the client.\n  - `query_string`: Query string in the request URL.\n  - `request_header`: HTTP request header.\n  - `client_ip`: Client IP.",
																		},
																		"values": {
																			Type:        schema.TypeSet,
																			Optional:    true,
																			Description: "The parameter value of the match type. It can be an empty string only when `Target=query string/request header` and `Operator=exist/notexist`.\n  - When `Target=extension`, enter the file extension, such as \"jpg\" and \"txt\".\n  - When `Target=filename`, enter the file name, such as \"foo\" in \"foo.jpg\".\n  - When `Target=all`, it indicates any site request.\n  - When `Target=host`, enter the host under the current site, such as \"www.maxx55.com\".\n  - When `Target=url`, enter the partial URL path under the current site, such as \"/example\".\n  - When `Target=full_url`, enter the complete URL under the current site. It must contain the HTTP protocol, host, and path, such as \"https://www.maxx55.cn/example\".\n  - When `Target=client_country`, enter the ISO-3166 country/region code.\n  - When `Target=query_string`, enter the value of the query string, such as \"cn\" and \"1\" in \"lang=cn&version=1\".\n  - When `Target=request_header`, enter the HTTP request header value, such as \"zh-CN,zh;q=0.9\" in the \"Accept-Language:zh-CN,zh;q=0.9\" header.",
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"ignore_case": {
																			Type:        schema.TypeBool,
																			Optional:    true,
																			Description: "Whether the parameter value is case insensitive. Default value: false.",
																		},
																		"name": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: "The parameter name of the match type. This field is required only when `Target=query_string/request_header`.\n  - `query_string`: Name of the query string, such as \"lang\" and \"version\" in \"lang=cn&version=1\".\n  - `request_header`: Name of the HTTP request header, such as \"Accept-Language\" in the \"Accept-Language:zh-CN,zh;q=0.9\" header.",
																		},
																	},
																},
															},
														},
													},
												},
												"actions": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "The feature to be executed.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"normal_action": {
																Type:        schema.TypeList,
																Optional:    true,
																MaxItems:    1,
																Description: "Common operation. Values:\n  - `AccessUrlRedirect`: Access URL rewrite.\n  - `UpstreamUrlRedirect`: Origin-pull URL rewrite.\n  - `QUIC`: QUIC.\n  - `WebSocket`: WebSocket.\n  - `VideoSeek`: Video dragging.\n  - `Authentication`: Token authentication.\n  - `CacheKey`: Custom cache key.\n  - `Cache`: Node cache TTL.\n  - `MaxAge`: Browser cache TTL.\n  - `OfflineCache`: Offline cache.\n  - `SmartRouting`: Smart acceleration.\n  - `RangeOriginPull`: Range GETs.\n  - `UpstreamHttp2`: HTTP/2 forwarding.\n  - `HostHeader`: Host header rewrite.\n  - `ForceRedirect`: Force HTTPS.\n  - `OriginPullProtocol`: Origin-pull HTTPS.\n  - `CachePrefresh`: Cache prefresh.\n  - `Compression`: Smart compression.\n  - `Hsts`.\n  - `ClientIpHeader`.\n  - `SslTlsSecureConf`.\n  - `OcspStapling`.\n  - `Http2`: HTTP/2 access.\n  - `UpstreamFollowRedirect`: Follow origin redirect.\n  - `Origin`: Origin.\nNote: This field may return `null`, indicating that no valid value can be obtained.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"action": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.",
																		},
																		"parameters": {
																			Type:        schema.TypeList,
																			Required:    true,
																			Description: "Parameter.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"name": {
																						Type:        schema.TypeString,
																						Required:    true,
																						Description: "Parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name.",
																					},
																					"values": {
																						Type:        schema.TypeSet,
																						Required:    true,
																						Description: "The parameter value.",
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															"rewrite_action": {
																Type:        schema.TypeList,
																Optional:    true,
																MaxItems:    1,
																Description: "Feature operation with a request/response header. Features of this type include:\n  - `RequestHeader`: HTTP request header modification.\n  - `ResponseHeader`: HTTP response header modification.\nNote: This field may return null, indicating that no valid values can be obtained.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"action": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.",
																		},
																		"parameters": {
																			Type:        schema.TypeList,
																			Required:    true,
																			Description: "Parameter.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"action": {
																						Type:        schema.TypeString,
																						Required:    true,
																						Description: "Feature parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name, which has three values:\n  - add: Add the HTTP header.\n  - set: Rewrite the HTTP header.\n  - del: Delete the HTTP header.",
																					},
																					"name": {
																						Type:        schema.TypeString,
																						Required:    true,
																						Description: "Parameter name.",
																					},
																					"values": {
																						Type:        schema.TypeSet,
																						Required:    true,
																						Description: "Parameter value.",
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															"code_action": {
																Type:        schema.TypeList,
																Optional:    true,
																MaxItems:    1,
																Description: "Feature operation with a status code. Features of this type include:\n  - `ErrorPage`: Custom error page.\n  - `StatusCodeCache`: Status code cache TTL.\nNote: This field may return null, indicating that no valid values can be obtained.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"action": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "Feature name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the feature name.",
																		},
																		"parameters": {
																			Type:        schema.TypeList,
																			Required:    true,
																			Description: "Operation parameter.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"name": {
																						Type:        schema.TypeString,
																						Required:    true,
																						Description: "The parameter name. You can call the [DescribeRulesSetting](https://tcloud4api.woa.com/document/product/1657/79433?!preview&!document=1) API to view the requirements for entering the parameter name.",
																					},
																					"values": {
																						Type:        schema.TypeSet,
																						Required:    true,
																						Description: "The parameter value.",
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},
																					"status_code": {
																						Type:        schema.TypeInt,
																						Required:    true,
																						Description: "The status code.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudTeoRuleEngineCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_rule_engine.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		zoneId string
		ruleId string
	)
	var (
		request  = teov20220901.NewCreateRuleRequest()
		response = teov20220901.NewCreateRuleResponse()
	)

	if v, ok := d.GetOk("zone_id"); ok {
		zoneId = v.(string)
	}

	request.ZoneId = helper.String(zoneId)

	if v, ok := d.GetOk("rule_name"); ok {
		request.RuleName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("status"); ok {
		request.Status = helper.String(v.(string))
	}

	if v, ok := d.GetOk("tags"); ok {
		tagsSet := v.(*schema.Set).List()
		for i := range tagsSet {
			tags := tagsSet[i].(string)
			request.Tags = append(request.Tags, helper.String(tags))
		}
	}

	if v, ok := d.GetOk("rules"); ok {
		for _, item := range v.([]interface{}) {
			rulesMap := item.(map[string]interface{})
			rule := teov20220901.Rule{}
			if v, ok := rulesMap["or"]; ok {
				for _, item := range v.([]interface{}) {
					conditionsMap := item.(map[string]interface{})
					ruleAndConditions := teov20220901.RuleAndConditions{}
					if v, ok := conditionsMap["and"]; ok {
						for _, item := range v.([]interface{}) {
							conditionsMap := item.(map[string]interface{})
							ruleCondition := teov20220901.RuleCondition{}
							if v, ok := conditionsMap["operator"]; ok {
								ruleCondition.Operator = helper.String(v.(string))
							}
							if v, ok := conditionsMap["target"]; ok {
								ruleCondition.Target = helper.String(v.(string))
							}
							if v, ok := conditionsMap["values"]; ok {
								valuesSet := v.(*schema.Set).List()
								for i := range valuesSet {
									values := valuesSet[i].(string)
									ruleCondition.Values = append(ruleCondition.Values, helper.String(values))
								}
							}
							if v, ok := conditionsMap["ignore_case"]; ok {
								ruleCondition.IgnoreCase = helper.Bool(v.(bool))
							}
							if v, ok := conditionsMap["name"]; ok {
								ruleCondition.Name = helper.String(v.(string))
							}
							ruleAndConditions.Conditions = append(ruleAndConditions.Conditions, &ruleCondition)
						}
					}
					rule.Conditions = append(rule.Conditions, &ruleAndConditions)
				}
			}
			if v, ok := rulesMap["actions"]; ok {
				for _, item := range v.([]interface{}) {
					actionsMap := item.(map[string]interface{})
					action := teov20220901.Action{}
					if normalActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["normal_action"]); ok {
						normalAction := teov20220901.NormalAction{}
						if v, ok := normalActionMap["action"]; ok {
							normalAction.Action = helper.String(v.(string))
						}
						if v, ok := normalActionMap["parameters"]; ok {
							for _, item := range v.([]interface{}) {
								parametersMap := item.(map[string]interface{})
								ruleNormalActionParams := teov20220901.RuleNormalActionParams{}
								if v, ok := parametersMap["name"]; ok {
									ruleNormalActionParams.Name = helper.String(v.(string))
								}
								if v, ok := parametersMap["values"]; ok {
									valuesSet := v.(*schema.Set).List()
									for i := range valuesSet {
										values := valuesSet[i].(string)
										ruleNormalActionParams.Values = append(ruleNormalActionParams.Values, helper.String(values))
									}
								}
								normalAction.Parameters = append(normalAction.Parameters, &ruleNormalActionParams)
							}
						}
						action.NormalAction = &normalAction
					}
					if rewriteActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["rewrite_action"]); ok {
						rewriteAction := teov20220901.RewriteAction{}
						if v, ok := rewriteActionMap["action"]; ok {
							rewriteAction.Action = helper.String(v.(string))
						}
						if v, ok := rewriteActionMap["parameters"]; ok {
							for _, item := range v.([]interface{}) {
								parametersMap := item.(map[string]interface{})
								ruleRewriteActionParams := teov20220901.RuleRewriteActionParams{}
								if v, ok := parametersMap["action"]; ok {
									ruleRewriteActionParams.Action = helper.String(v.(string))
								}
								if v, ok := parametersMap["name"]; ok {
									ruleRewriteActionParams.Name = helper.String(v.(string))
								}
								if v, ok := parametersMap["values"]; ok {
									valuesSet := v.(*schema.Set).List()
									for i := range valuesSet {
										values := valuesSet[i].(string)
										ruleRewriteActionParams.Values = append(ruleRewriteActionParams.Values, helper.String(values))
									}
								}
								rewriteAction.Parameters = append(rewriteAction.Parameters, &ruleRewriteActionParams)
							}
						}
						action.RewriteAction = &rewriteAction
					}
					if codeActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["code_action"]); ok {
						codeAction := teov20220901.CodeAction{}
						if v, ok := codeActionMap["action"]; ok {
							codeAction.Action = helper.String(v.(string))
						}
						if v, ok := codeActionMap["parameters"]; ok {
							for _, item := range v.([]interface{}) {
								parametersMap := item.(map[string]interface{})
								ruleCodeActionParams := teov20220901.RuleCodeActionParams{}
								if v, ok := parametersMap["status_code"]; ok {
									ruleCodeActionParams.StatusCode = helper.IntInt64(v.(int))
								}
								if v, ok := parametersMap["name"]; ok {
									ruleCodeActionParams.Name = helper.String(v.(string))
								}
								if v, ok := parametersMap["values"]; ok {
									valuesSet := v.(*schema.Set).List()
									for i := range valuesSet {
										values := valuesSet[i].(string)
										ruleCodeActionParams.Values = append(ruleCodeActionParams.Values, helper.String(values))
									}
								}
								codeAction.Parameters = append(codeAction.Parameters, &ruleCodeActionParams)
							}
						}
						action.CodeAction = &codeAction
					}
					rule.Actions = append(rule.Actions, &action)
				}
			}
			if v, ok := rulesMap["sub_rules"]; ok {
				for _, item := range v.([]interface{}) {
					subRulesMap := item.(map[string]interface{})
					subRuleItem := teov20220901.SubRuleItem{}
					if v, ok := subRulesMap["rules"]; ok {
						for _, item := range v.([]interface{}) {
							rulesMap := item.(map[string]interface{})
							subRule := teov20220901.SubRule{}
							if v, ok := rulesMap["or"]; ok {
								for _, item := range v.([]interface{}) {
									conditionsMap := item.(map[string]interface{})
									ruleAndConditions := teov20220901.RuleAndConditions{}
									if v, ok := conditionsMap["and"]; ok {
										for _, item := range v.([]interface{}) {
											conditionsMap := item.(map[string]interface{})
											ruleCondition := teov20220901.RuleCondition{}
											if v, ok := conditionsMap["operator"]; ok {
												ruleCondition.Operator = helper.String(v.(string))
											}
											if v, ok := conditionsMap["target"]; ok {
												ruleCondition.Target = helper.String(v.(string))
											}
											if v, ok := conditionsMap["values"]; ok {
												valuesSet := v.(*schema.Set).List()
												for i := range valuesSet {
													values := valuesSet[i].(string)
													ruleCondition.Values = append(ruleCondition.Values, helper.String(values))
												}
											}
											if v, ok := conditionsMap["ignore_case"]; ok {
												ruleCondition.IgnoreCase = helper.Bool(v.(bool))
											}
											if v, ok := conditionsMap["name"]; ok {
												ruleCondition.Name = helper.String(v.(string))
											}
											ruleAndConditions.Conditions = append(ruleAndConditions.Conditions, &ruleCondition)
										}
									}
									subRule.Conditions = append(subRule.Conditions, &ruleAndConditions)
								}
							}
							if v, ok := rulesMap["actions"]; ok {
								for _, item := range v.([]interface{}) {
									actionsMap := item.(map[string]interface{})
									action := teov20220901.Action{}
									if normalActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["normal_action"]); ok {
										normalAction2 := teov20220901.NormalAction{}
										if v, ok := normalActionMap["action"]; ok {
											normalAction2.Action = helper.String(v.(string))
										}
										if v, ok := normalActionMap["parameters"]; ok {
											for _, item := range v.([]interface{}) {
												parametersMap := item.(map[string]interface{})
												ruleNormalActionParams := teov20220901.RuleNormalActionParams{}
												if v, ok := parametersMap["name"]; ok {
													ruleNormalActionParams.Name = helper.String(v.(string))
												}
												if v, ok := parametersMap["values"]; ok {
													valuesSet := v.(*schema.Set).List()
													for i := range valuesSet {
														values := valuesSet[i].(string)
														ruleNormalActionParams.Values = append(ruleNormalActionParams.Values, helper.String(values))
													}
												}
												normalAction2.Parameters = append(normalAction2.Parameters, &ruleNormalActionParams)
											}
										}
										action.NormalAction = &normalAction2
									}
									if rewriteActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["rewrite_action"]); ok {
										rewriteAction2 := teov20220901.RewriteAction{}
										if v, ok := rewriteActionMap["action"]; ok {
											rewriteAction2.Action = helper.String(v.(string))
										}
										if v, ok := rewriteActionMap["parameters"]; ok {
											for _, item := range v.([]interface{}) {
												parametersMap := item.(map[string]interface{})
												ruleRewriteActionParams := teov20220901.RuleRewriteActionParams{}
												if v, ok := parametersMap["action"]; ok {
													ruleRewriteActionParams.Action = helper.String(v.(string))
												}
												if v, ok := parametersMap["name"]; ok {
													ruleRewriteActionParams.Name = helper.String(v.(string))
												}
												if v, ok := parametersMap["values"]; ok {
													valuesSet := v.(*schema.Set).List()
													for i := range valuesSet {
														values := valuesSet[i].(string)
														ruleRewriteActionParams.Values = append(ruleRewriteActionParams.Values, helper.String(values))
													}
												}
												rewriteAction2.Parameters = append(rewriteAction2.Parameters, &ruleRewriteActionParams)
											}
										}
										action.RewriteAction = &rewriteAction2
									}
									if codeActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["code_action"]); ok {
										codeAction2 := teov20220901.CodeAction{}
										if v, ok := codeActionMap["action"]; ok {
											codeAction2.Action = helper.String(v.(string))
										}
										if v, ok := codeActionMap["parameters"]; ok {
											for _, item := range v.([]interface{}) {
												parametersMap := item.(map[string]interface{})
												ruleCodeActionParams := teov20220901.RuleCodeActionParams{}
												if v, ok := parametersMap["status_code"]; ok {
													ruleCodeActionParams.StatusCode = helper.IntInt64(v.(int))
												}
												if v, ok := parametersMap["name"]; ok {
													ruleCodeActionParams.Name = helper.String(v.(string))
												}
												if v, ok := parametersMap["values"]; ok {
													valuesSet := v.(*schema.Set).List()
													for i := range valuesSet {
														values := valuesSet[i].(string)
														ruleCodeActionParams.Values = append(ruleCodeActionParams.Values, helper.String(values))
													}
												}
												codeAction2.Parameters = append(codeAction2.Parameters, &ruleCodeActionParams)
											}
										}
										action.CodeAction = &codeAction2
									}
									subRule.Actions = append(subRule.Actions, &action)
								}
							}
							subRuleItem.Rules = append(subRuleItem.Rules, &subRule)
						}
					}
					if v, ok := subRulesMap["tags"]; ok {
						tagsSet := v.(*schema.Set).List()
						for i := range tagsSet {
							tags := tagsSet[i].(string)
							subRuleItem.Tags = append(subRuleItem.Tags, helper.String(tags))
						}
					}
					rule.SubRules = append(rule.SubRules, &subRuleItem)
				}
			}
			request.Rules = append(request.Rules, &rule)
		}
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().CreateRuleWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create teo rule engine failed, reason:%+v", logId, err)
		return err
	}

	ruleId = *response.Response.RuleId

	d.SetId(strings.Join([]string{zoneId, ruleId}, tccommon.FILED_SP))

	return resourceTencentCloudTeoRuleEngineRead(d, meta)
}

func resourceTencentCloudTeoRuleEngineRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_rule_engine.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	ruleId := idSplit[1]

	_ = d.Set("zone_id", zoneId)

	respData, err := service.DescribeTeoRuleEngineById(ctx, zoneId, ruleId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `teo_rule_engine` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.RuleId != nil {
		_ = d.Set("rule_id", respData.RuleId)
		ruleId = *respData.RuleId
	}

	if respData.RuleName != nil {
		_ = d.Set("rule_name", respData.RuleName)
	}

	if respData.Status != nil {
		_ = d.Set("status", respData.Status)
	}

	if respData.RulePriority != nil {
		_ = d.Set("rule_priority", respData.RulePriority)
	}

	if respData.Tags != nil {
		_ = d.Set("tags", respData.Tags)
	}

	rulesList := make([]map[string]interface{}, 0, len(respData.Rules))
	if respData.Rules != nil {
		for _, rules := range respData.Rules {
			rulesMap := map[string]interface{}{}

			conditionsList := make([]map[string]interface{}, 0, len(rules.Conditions))
			if rules.Conditions != nil {
				for _, conditions := range rules.Conditions {
					conditionsMap := map[string]interface{}{}

					conditionsList2 := make([]map[string]interface{}, 0, len(conditions.Conditions))
					if conditions.Conditions != nil {
						for _, conditions := range conditions.Conditions {
							conditionsMap2 := map[string]interface{}{}

							if conditions.Operator != nil {
								conditionsMap2["operator"] = conditions.Operator
							}

							if conditions.Target != nil {
								conditionsMap2["target"] = conditions.Target
							}

							if conditions.Values != nil {
								conditionsMap2["values"] = conditions.Values
							}

							if conditions.IgnoreCase != nil {
								conditionsMap2["ignore_case"] = conditions.IgnoreCase
							}

							if conditions.Name != nil {
								conditionsMap2["name"] = conditions.Name
							}

							conditionsList2 = append(conditionsList2, conditionsMap2)
						}

						conditionsMap["and"] = conditionsList2
					}
					conditionsList = append(conditionsList, conditionsMap)
				}

				rulesMap["or"] = conditionsList
			}
			actionsList := make([]map[string]interface{}, 0, len(rules.Actions))
			if rules.Actions != nil {
				for _, actions := range rules.Actions {
					actionsMap := map[string]interface{}{}

					normalActionMap := map[string]interface{}{}

					if actions.NormalAction != nil {
						if actions.NormalAction.Action != nil {
							normalActionMap["action"] = actions.NormalAction.Action
						}

						parametersList := make([]map[string]interface{}, 0, len(actions.NormalAction.Parameters))
						if actions.NormalAction.Parameters != nil {
							for _, parameters := range actions.NormalAction.Parameters {
								parametersMap := map[string]interface{}{}

								if parameters.Name != nil {
									parametersMap["name"] = parameters.Name
								}

								if parameters.Values != nil {
									parametersMap["values"] = parameters.Values
								}

								parametersList = append(parametersList, parametersMap)
							}

							normalActionMap["parameters"] = parametersList
						}
						actionsMap["normal_action"] = []interface{}{normalActionMap}
					}

					rewriteActionMap := map[string]interface{}{}

					if actions.RewriteAction != nil {
						if actions.RewriteAction.Action != nil {
							rewriteActionMap["action"] = actions.RewriteAction.Action
						}

						parametersList := make([]map[string]interface{}, 0, len(actions.RewriteAction.Parameters))
						if actions.RewriteAction.Parameters != nil {
							for _, parameters := range actions.RewriteAction.Parameters {
								parametersMap := map[string]interface{}{}

								if parameters.Action != nil {
									parametersMap["action"] = parameters.Action
								}

								if parameters.Name != nil {
									parametersMap["name"] = parameters.Name
								}

								if parameters.Values != nil {
									parametersMap["values"] = parameters.Values
								}

								parametersList = append(parametersList, parametersMap)
							}

							rewriteActionMap["parameters"] = parametersList
						}
						actionsMap["rewrite_action"] = []interface{}{rewriteActionMap}
					}

					codeActionMap := map[string]interface{}{}

					if actions.CodeAction != nil {
						if actions.CodeAction.Action != nil {
							codeActionMap["action"] = actions.CodeAction.Action
						}

						parametersList := make([]map[string]interface{}, 0, len(actions.CodeAction.Parameters))
						if actions.CodeAction.Parameters != nil {
							for _, parameters := range actions.CodeAction.Parameters {
								parametersMap := map[string]interface{}{}

								if parameters.StatusCode != nil {
									parametersMap["status_code"] = parameters.StatusCode
								}

								if parameters.Name != nil {
									parametersMap["name"] = parameters.Name
								}

								if parameters.Values != nil {
									parametersMap["values"] = parameters.Values
								}

								parametersList = append(parametersList, parametersMap)
							}

							codeActionMap["parameters"] = parametersList
						}
						actionsMap["code_action"] = []interface{}{codeActionMap}
					}

					actionsList = append(actionsList, actionsMap)
				}

				rulesMap["actions"] = actionsList
			}
			subRulesList := make([]map[string]interface{}, 0, len(rules.SubRules))
			if rules.SubRules != nil {
				for _, subRules := range rules.SubRules {
					subRulesMap := map[string]interface{}{}

					rulesList2 := make([]map[string]interface{}, 0, len(subRules.Rules))
					if subRules.Rules != nil {
						for _, rules := range subRules.Rules {
							rulesMap2 := map[string]interface{}{}

							conditionsList := make([]map[string]interface{}, 0, len(rules.Conditions))
							if rules.Conditions != nil {
								for _, conditions := range rules.Conditions {
									conditionsMap := map[string]interface{}{}

									conditionsList2 := make([]map[string]interface{}, 0, len(conditions.Conditions))
									if conditions.Conditions != nil {
										for _, conditions := range conditions.Conditions {
											conditionsMap2 := map[string]interface{}{}

											if conditions.Operator != nil {
												conditionsMap2["operator"] = conditions.Operator
											}

											if conditions.Target != nil {
												conditionsMap2["target"] = conditions.Target
											}

											if conditions.Values != nil {
												conditionsMap2["values"] = conditions.Values
											}

											if conditions.IgnoreCase != nil {
												conditionsMap2["ignore_case"] = conditions.IgnoreCase
											}

											if conditions.Name != nil {
												conditionsMap2["name"] = conditions.Name
											}

											conditionsList2 = append(conditionsList2, conditionsMap2)
										}

										conditionsMap["and"] = conditionsList2
									}
									conditionsList = append(conditionsList, conditionsMap)
								}

								rulesMap2["or"] = conditionsList
							}
							actionsList := make([]map[string]interface{}, 0, len(rules.Actions))
							if rules.Actions != nil {
								for _, actions := range rules.Actions {
									actionsMap := map[string]interface{}{}

									normalActionMap := map[string]interface{}{}

									if actions.NormalAction != nil {
										if actions.NormalAction.Action != nil {
											normalActionMap["action"] = actions.NormalAction.Action
										}

										parametersList := make([]map[string]interface{}, 0, len(actions.NormalAction.Parameters))
										if actions.NormalAction.Parameters != nil {
											for _, parameters := range actions.NormalAction.Parameters {
												parametersMap := map[string]interface{}{}

												if parameters.Name != nil {
													parametersMap["name"] = parameters.Name
												}

												if parameters.Values != nil {
													parametersMap["values"] = parameters.Values
												}

												parametersList = append(parametersList, parametersMap)
											}

											normalActionMap["parameters"] = parametersList
										}
										actionsMap["normal_action"] = []interface{}{normalActionMap}
									}

									rewriteActionMap := map[string]interface{}{}

									if actions.RewriteAction != nil {
										if actions.RewriteAction.Action != nil {
											rewriteActionMap["action"] = actions.RewriteAction.Action
										}

										parametersList := make([]map[string]interface{}, 0, len(actions.RewriteAction.Parameters))
										if actions.RewriteAction.Parameters != nil {
											for _, parameters := range actions.RewriteAction.Parameters {
												parametersMap := map[string]interface{}{}

												if parameters.Action != nil {
													parametersMap["action"] = parameters.Action
												}

												if parameters.Name != nil {
													parametersMap["name"] = parameters.Name
												}

												if parameters.Values != nil {
													parametersMap["values"] = parameters.Values
												}

												parametersList = append(parametersList, parametersMap)
											}

											rewriteActionMap["parameters"] = parametersList
										}
										actionsMap["rewrite_action"] = []interface{}{rewriteActionMap}
									}

									codeActionMap := map[string]interface{}{}

									if actions.CodeAction != nil {
										if actions.CodeAction.Action != nil {
											codeActionMap["action"] = actions.CodeAction.Action
										}

										parametersList := make([]map[string]interface{}, 0, len(actions.CodeAction.Parameters))
										if actions.CodeAction.Parameters != nil {
											for _, parameters := range actions.CodeAction.Parameters {
												parametersMap := map[string]interface{}{}

												if parameters.StatusCode != nil {
													parametersMap["status_code"] = parameters.StatusCode
												}

												if parameters.Name != nil {
													parametersMap["name"] = parameters.Name
												}

												if parameters.Values != nil {
													parametersMap["values"] = parameters.Values
												}

												parametersList = append(parametersList, parametersMap)
											}

											codeActionMap["parameters"] = parametersList
										}
										actionsMap["code_action"] = []interface{}{codeActionMap}
									}

									actionsList = append(actionsList, actionsMap)
								}

								rulesMap2["actions"] = actionsList
							}
							rulesList2 = append(rulesList2, rulesMap2)
						}

						subRulesMap["rules"] = rulesList2
					}
					if subRules.Tags != nil {
						subRulesMap["tags"] = subRules.Tags
					}

					subRulesList = append(subRulesList, subRulesMap)
				}

				rulesMap["sub_rules"] = subRulesList
			}
			rulesList = append(rulesList, rulesMap)
		}

		_ = d.Set("rules", rulesList)
	}

	return nil
}

func resourceTencentCloudTeoRuleEngineUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_rule_engine.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	ruleId := idSplit[1]

	needChange := false
	mutableArgs := []string{"rule_name", "status", "tags", "rules"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := teov20220901.NewModifyRuleRequest()

		request.ZoneId = helper.String(zoneId)

		request.RuleId = helper.String(ruleId)

		if v, ok := d.GetOk("rule_name"); ok {
			request.RuleName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("status"); ok {
			request.Status = helper.String(v.(string))
		}

		if v, ok := d.GetOk("tags"); ok {
			tagsSet := v.(*schema.Set).List()
			for i := range tagsSet {
				tags := tagsSet[i].(string)
				request.Tags = append(request.Tags, helper.String(tags))
			}
		}

		if v, ok := d.GetOk("rules"); ok {
			for _, item := range v.([]interface{}) {
				rulesMap := item.(map[string]interface{})
				rule := teov20220901.Rule{}
				if v, ok := rulesMap["actions"]; ok {
					for _, item := range v.([]interface{}) {
						actionsMap := item.(map[string]interface{})
						action := teov20220901.Action{}
						if normalActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["normal_action"]); ok {
							normalAction := teov20220901.NormalAction{}
							if v, ok := normalActionMap["action"]; ok {
								normalAction.Action = helper.String(v.(string))
							}
							if v, ok := normalActionMap["parameters"]; ok {
								for _, item := range v.([]interface{}) {
									parametersMap := item.(map[string]interface{})
									ruleNormalActionParams := teov20220901.RuleNormalActionParams{}
									if v, ok := parametersMap["name"]; ok {
										ruleNormalActionParams.Name = helper.String(v.(string))
									}
									if v, ok := parametersMap["values"]; ok {
										valuesSet := v.(*schema.Set).List()
										for i := range valuesSet {
											values := valuesSet[i].(string)
											ruleNormalActionParams.Values = append(ruleNormalActionParams.Values, helper.String(values))
										}
									}
									normalAction.Parameters = append(normalAction.Parameters, &ruleNormalActionParams)
								}
							}
							action.NormalAction = &normalAction
						}
						if rewriteActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["rewrite_action"]); ok {
							rewriteAction := teov20220901.RewriteAction{}
							if v, ok := rewriteActionMap["action"]; ok {
								rewriteAction.Action = helper.String(v.(string))
							}
							if v, ok := rewriteActionMap["parameters"]; ok {
								for _, item := range v.([]interface{}) {
									parametersMap := item.(map[string]interface{})
									ruleRewriteActionParams := teov20220901.RuleRewriteActionParams{}
									if v, ok := parametersMap["action"]; ok {
										ruleRewriteActionParams.Action = helper.String(v.(string))
									}
									if v, ok := parametersMap["name"]; ok {
										ruleRewriteActionParams.Name = helper.String(v.(string))
									}
									if v, ok := parametersMap["values"]; ok {
										valuesSet := v.(*schema.Set).List()
										for i := range valuesSet {
											values := valuesSet[i].(string)
											ruleRewriteActionParams.Values = append(ruleRewriteActionParams.Values, helper.String(values))
										}
									}
									rewriteAction.Parameters = append(rewriteAction.Parameters, &ruleRewriteActionParams)
								}
							}
							action.RewriteAction = &rewriteAction
						}
						if codeActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["code_action"]); ok {
							codeAction := teov20220901.CodeAction{}
							if v, ok := codeActionMap["action"]; ok {
								codeAction.Action = helper.String(v.(string))
							}
							if v, ok := codeActionMap["parameters"]; ok {
								for _, item := range v.([]interface{}) {
									parametersMap := item.(map[string]interface{})
									ruleCodeActionParams := teov20220901.RuleCodeActionParams{}
									if v, ok := parametersMap["status_code"]; ok {
										ruleCodeActionParams.StatusCode = helper.IntInt64(v.(int))
									}
									if v, ok := parametersMap["name"]; ok {
										ruleCodeActionParams.Name = helper.String(v.(string))
									}
									if v, ok := parametersMap["values"]; ok {
										valuesSet := v.(*schema.Set).List()
										for i := range valuesSet {
											values := valuesSet[i].(string)
											ruleCodeActionParams.Values = append(ruleCodeActionParams.Values, helper.String(values))
										}
									}
									codeAction.Parameters = append(codeAction.Parameters, &ruleCodeActionParams)
								}
							}
							action.CodeAction = &codeAction
						}
						rule.Actions = append(rule.Actions, &action)
					}
				}
				if v, ok := rulesMap["or"]; ok {
					for _, item := range v.([]interface{}) {
						conditionsMap := item.(map[string]interface{})
						ruleAndConditions := teov20220901.RuleAndConditions{}
						if v, ok := conditionsMap["and"]; ok {
							for _, item := range v.([]interface{}) {
								conditionsMap := item.(map[string]interface{})
								ruleCondition := teov20220901.RuleCondition{}
								if v, ok := conditionsMap["operator"]; ok {
									ruleCondition.Operator = helper.String(v.(string))
								}
								if v, ok := conditionsMap["target"]; ok {
									ruleCondition.Target = helper.String(v.(string))
								}
								if v, ok := conditionsMap["values"]; ok {
									valuesSet := v.(*schema.Set).List()
									for i := range valuesSet {
										values := valuesSet[i].(string)
										ruleCondition.Values = append(ruleCondition.Values, helper.String(values))
									}
								}
								if v, ok := conditionsMap["ignore_case"]; ok {
									ruleCondition.IgnoreCase = helper.Bool(v.(bool))
								}
								if v, ok := conditionsMap["name"]; ok {
									ruleCondition.Name = helper.String(v.(string))
								}
								ruleAndConditions.Conditions = append(ruleAndConditions.Conditions, &ruleCondition)
							}
						}
						rule.Conditions = append(rule.Conditions, &ruleAndConditions)
					}
				}
				if v, ok := rulesMap["sub_rules"]; ok {
					for _, item := range v.([]interface{}) {
						subRulesMap := item.(map[string]interface{})
						subRuleItem := teov20220901.SubRuleItem{}
						if v, ok := subRulesMap["rules"]; ok {
							for _, item := range v.([]interface{}) {
								rulesMap := item.(map[string]interface{})
								subRule := teov20220901.SubRule{}
								if v, ok := rulesMap["or"]; ok {
									for _, item := range v.([]interface{}) {
										conditionsMap := item.(map[string]interface{})
										ruleAndConditions := teov20220901.RuleAndConditions{}
										if v, ok := conditionsMap["and"]; ok {
											for _, item := range v.([]interface{}) {
												conditionsMap := item.(map[string]interface{})
												ruleCondition := teov20220901.RuleCondition{}
												if v, ok := conditionsMap["operator"]; ok {
													ruleCondition.Operator = helper.String(v.(string))
												}
												if v, ok := conditionsMap["target"]; ok {
													ruleCondition.Target = helper.String(v.(string))
												}
												if v, ok := conditionsMap["values"]; ok {
													valuesSet := v.(*schema.Set).List()
													for i := range valuesSet {
														values := valuesSet[i].(string)
														ruleCondition.Values = append(ruleCondition.Values, helper.String(values))
													}
												}
												if v, ok := conditionsMap["ignore_case"]; ok {
													ruleCondition.IgnoreCase = helper.Bool(v.(bool))
												}
												if v, ok := conditionsMap["name"]; ok {
													ruleCondition.Name = helper.String(v.(string))
												}
												ruleAndConditions.Conditions = append(ruleAndConditions.Conditions, &ruleCondition)
											}
										}
										subRule.Conditions = append(subRule.Conditions, &ruleAndConditions)
									}
								}
								if v, ok := rulesMap["actions"]; ok {
									for _, item := range v.([]interface{}) {
										actionsMap := item.(map[string]interface{})
										action := teov20220901.Action{}
										if normalActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["normal_action"]); ok {
											normalAction2 := teov20220901.NormalAction{}
											if v, ok := normalActionMap["action"]; ok {
												normalAction2.Action = helper.String(v.(string))
											}
											if v, ok := normalActionMap["parameters"]; ok {
												for _, item := range v.([]interface{}) {
													parametersMap := item.(map[string]interface{})
													ruleNormalActionParams := teov20220901.RuleNormalActionParams{}
													if v, ok := parametersMap["name"]; ok {
														ruleNormalActionParams.Name = helper.String(v.(string))
													}
													if v, ok := parametersMap["values"]; ok {
														valuesSet := v.(*schema.Set).List()
														for i := range valuesSet {
															values := valuesSet[i].(string)
															ruleNormalActionParams.Values = append(ruleNormalActionParams.Values, helper.String(values))
														}
													}
													normalAction2.Parameters = append(normalAction2.Parameters, &ruleNormalActionParams)
												}
											}
											action.NormalAction = &normalAction2
										}
										if rewriteActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["rewrite_action"]); ok {
											rewriteAction2 := teov20220901.RewriteAction{}
											if v, ok := rewriteActionMap["action"]; ok {
												rewriteAction2.Action = helper.String(v.(string))
											}
											if v, ok := rewriteActionMap["parameters"]; ok {
												for _, item := range v.([]interface{}) {
													parametersMap := item.(map[string]interface{})
													ruleRewriteActionParams := teov20220901.RuleRewriteActionParams{}
													if v, ok := parametersMap["action"]; ok {
														ruleRewriteActionParams.Action = helper.String(v.(string))
													}
													if v, ok := parametersMap["name"]; ok {
														ruleRewriteActionParams.Name = helper.String(v.(string))
													}
													if v, ok := parametersMap["values"]; ok {
														valuesSet := v.(*schema.Set).List()
														for i := range valuesSet {
															values := valuesSet[i].(string)
															ruleRewriteActionParams.Values = append(ruleRewriteActionParams.Values, helper.String(values))
														}
													}
													rewriteAction2.Parameters = append(rewriteAction2.Parameters, &ruleRewriteActionParams)
												}
											}
											action.RewriteAction = &rewriteAction2
										}
										if codeActionMap, ok := helper.ConvertInterfacesHeadToMap(actionsMap["code_action"]); ok {
											codeAction2 := teov20220901.CodeAction{}
											if v, ok := codeActionMap["action"]; ok {
												codeAction2.Action = helper.String(v.(string))
											}
											if v, ok := codeActionMap["parameters"]; ok {
												for _, item := range v.([]interface{}) {
													parametersMap := item.(map[string]interface{})
													ruleCodeActionParams := teov20220901.RuleCodeActionParams{}
													if v, ok := parametersMap["status_code"]; ok {
														ruleCodeActionParams.StatusCode = helper.IntInt64(v.(int))
													}
													if v, ok := parametersMap["name"]; ok {
														ruleCodeActionParams.Name = helper.String(v.(string))
													}
													if v, ok := parametersMap["values"]; ok {
														valuesSet := v.(*schema.Set).List()
														for i := range valuesSet {
															values := valuesSet[i].(string)
															ruleCodeActionParams.Values = append(ruleCodeActionParams.Values, helper.String(values))
														}
													}
													codeAction2.Parameters = append(codeAction2.Parameters, &ruleCodeActionParams)
												}
											}
											action.CodeAction = &codeAction2
										}
										subRule.Actions = append(subRule.Actions, &action)
									}
								}
								subRuleItem.Rules = append(subRuleItem.Rules, &subRule)
							}
						}
						if v, ok := subRulesMap["tags"]; ok {
							tagsSet := v.(*schema.Set).List()
							for i := range tagsSet {
								tags := tagsSet[i].(string)
								subRuleItem.Tags = append(subRuleItem.Tags, helper.String(tags))
							}
						}
						rule.SubRules = append(rule.SubRules, &subRuleItem)
					}
				}
				request.Rules = append(request.Rules, &rule)
			}
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().ModifyRuleWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update teo rule engine failed, reason:%+v", logId, err)
			return err
		}
	}

	return resourceTencentCloudTeoRuleEngineRead(d, meta)
}

func resourceTencentCloudTeoRuleEngineDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_rule_engine.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	ruleId := idSplit[1]

	var (
		request  = teov20220901.NewDeleteRulesRequest()
		response = teov20220901.NewDeleteRulesResponse()
	)

	request.ZoneId = helper.String(zoneId)

	request.RuleIds = []*string{helper.String(ruleId)}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoV20220901Client().DeleteRulesWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete teo rule engine failed, reason:%+v", logId, err)
		return err
	}

	_ = response
	return nil
}
