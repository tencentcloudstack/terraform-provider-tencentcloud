// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teov20220901 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudTeoEnvironments() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudTeoEnvironmentsRead,
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Zone ID.",
			},

			"env_infos": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Environment list.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"env_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Environment ID.",
						},
						"env_type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Environment type. Valid values: production (Production environment), staging (Test environment).",
						},
						"status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Environment status. Valid values: creating (Being created), running (The environment is stable, with version changes allowed), version_deploying (The version is currently being deployed, with no more changes allowed).",
						},
						"scope": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "Effective scope of the configuration in the current environment. Valid values: ALL (It takes effect on the entire network when EnvType is set to production), It returns the IP address of the test node for host binding during testing when EnvType is set to staging.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"current_config_group_version_infos": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "For the effective versions of each configuration group in the current environment, there are two possible scenarios based on the value of Status: When Status is set to version_deploying, the returned value of this field represents the previously effective version. In other words, during the deployment of the new version, the effective version is the one that was in effect before any changes were made. When Status is set to running, the value returned by this field is the currently effective version.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"version_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Version ID.",
									},
									"version_number": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Version No.",
									},
									"group_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Configuraration group ID.",
									},
									"group_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Configuration group type. Valid values: l7_acceleration (L7 acceleration configuration group), edge_functions (Edge function configuration group).",
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Version description.",
									},
									"status": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Version status. Valid values: creating (Being created), inactive (Not effective), active (Effective).",
									},
									"create_time": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Version creation time. The time format follows the ISO 8601 standard and is represented in Coordinated Universal Time (UTC).",
									},
								},
							},
						},
						"create_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Creation time. The time format follows the ISO 8601 standard and is represented in Coordinated Universal Time (UTC).",
						},
						"update_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Update time. The time format follows the ISO 8601 standard and is represented in Coordinated Universal Time (UTC).",
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudTeoEnvironmentsRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_teo_environments.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("zone_id"); ok {
		paramMap["ZoneId"] = helper.String(v.(string))
	}

	var respData []*teov20220901.EnvInfo
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeTeoEnvironmentsByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	ids := make([]string, 0, len(respData))
	envInfosList := make([]map[string]interface{}, 0, len(respData))
	if respData != nil {
		for _, envInfos := range respData {
			envInfosMap := map[string]interface{}{}

			if envInfos.EnvId != nil {
				envInfosMap["env_id"] = envInfos.EnvId
				ids = append(ids, *envInfos.EnvId)
			}

			if envInfos.EnvType != nil {
				envInfosMap["env_type"] = envInfos.EnvType
			}

			if envInfos.Status != nil {
				envInfosMap["status"] = envInfos.Status
			}

			if envInfos.Scope != nil {
				envInfosMap["scope"] = envInfos.Scope
			}

			currentConfigGroupVersionInfosList := make([]map[string]interface{}, 0, len(envInfos.CurrentConfigGroupVersionInfos))
			if envInfos.CurrentConfigGroupVersionInfos != nil {
				for _, currentConfigGroupVersionInfos := range envInfos.CurrentConfigGroupVersionInfos {
					currentConfigGroupVersionInfosMap := map[string]interface{}{}

					if currentConfigGroupVersionInfos.VersionId != nil {
						currentConfigGroupVersionInfosMap["version_id"] = currentConfigGroupVersionInfos.VersionId
					}

					if currentConfigGroupVersionInfos.VersionNumber != nil {
						currentConfigGroupVersionInfosMap["version_number"] = currentConfigGroupVersionInfos.VersionNumber
					}

					if currentConfigGroupVersionInfos.GroupId != nil {
						currentConfigGroupVersionInfosMap["group_id"] = currentConfigGroupVersionInfos.GroupId
					}

					if currentConfigGroupVersionInfos.GroupType != nil {
						currentConfigGroupVersionInfosMap["group_type"] = currentConfigGroupVersionInfos.GroupType
					}

					if currentConfigGroupVersionInfos.Description != nil {
						currentConfigGroupVersionInfosMap["description"] = currentConfigGroupVersionInfos.Description
					}

					if currentConfigGroupVersionInfos.Status != nil {
						currentConfigGroupVersionInfosMap["status"] = currentConfigGroupVersionInfos.Status
					}

					if currentConfigGroupVersionInfos.CreateTime != nil {
						currentConfigGroupVersionInfosMap["create_time"] = currentConfigGroupVersionInfos.CreateTime
					}

					currentConfigGroupVersionInfosList = append(currentConfigGroupVersionInfosList, currentConfigGroupVersionInfosMap)
				}

				envInfosMap["current_config_group_version_infos"] = currentConfigGroupVersionInfosList
			}
			if envInfos.CreateTime != nil {
				envInfosMap["create_time"] = envInfos.CreateTime
			}

			if envInfos.UpdateTime != nil {
				envInfosMap["update_time"] = envInfos.UpdateTime
			}

			envInfosList = append(envInfosList, envInfosMap)
		}

		_ = d.Set("env_infos", envInfosList)
	}

	d.SetId(helper.DataResourceIdsHash(ids))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), envInfosList); e != nil {
			return e
		}
	}

	return nil
}
