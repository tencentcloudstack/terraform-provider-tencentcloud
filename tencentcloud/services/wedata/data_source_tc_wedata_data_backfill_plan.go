// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataDataBackfillPlan() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataDataBackfillPlanRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"data_backfill_plan_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Backfill Plan ID.",
			},

			"time_zone": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Display time zone, default UTC+8.",
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Backfill details.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"project_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Project ID.",
						},
						"data_backfill_plan_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Data Backfill Plan ID.",
						},
						"data_backfill_plan_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Data Backfill Plan Name.",
						},
						"task_ids": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "Set of backfill tasks.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"data_backfill_range_list": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "List of data configuration for backfill tasks.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"start_date": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Start date, format yyyy-MM-dd, indicating start from 00:00:00 of the specified date.",
									},
									"end_date": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "End date, format yyyy-MM-dd, indicating end at 23:59:59 of the specified date.",
									},
									"execution_start_time": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Daily start time point within [StartDate, EndDate], format HH:mm, only effective for tasks with hour or sub-hour cycles.",
									},
									"execution_end_time": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Daily end time point within [StartDate, EndDate], format HH:mm, only effective for tasks with hour or sub-hour cycles.",
									},
								},
							},
						},
						"check_parent_type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Parent task check type, valid values: - NONE - Do not check all - ALL - Check all upstream parent tasks - MAKE_SCOPE - Only check within the tasks selected in (the current backfill plan).",
						},
						"skip_event_listening": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: "Whether the backfill ignores event dependencies.",
						},
						"redefine_parallel_num": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Custom instance run concurrency, returns null or not returned indicates the task's original self-dependency.",
						},
						"redefine_self_workflow_dependency": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Custom workflow self-dependency, yes or no; if not configured, the workflow's original self-dependency is used.",
						},
						"scheduler_resource_group_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Scheduler resource group ID.",
						},
						"integration_resource_group_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Integration resource group ID.",
						},
						"redefine_cycle_type": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Backfill custom generation cycle.",
						},
						"redefine_param_list": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Custom parameters.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"k": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Key name.",
									},
									"v": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Value, do not pass SQL (request will be treated as an attack interface). If necessary, Base64 encode and decode the SQL.",
									},
								},
							},
						},
						"start_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Execution start time of the backfill task.",
						},
						"end_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Execution end time of the backfill task.",
						},
						"create_user_uin": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Creator user ID.",
						},
						"complete_percent": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Backfill plan instance completion percentage.",
						},
						"success_percent": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Backfill plan instance success percentage.",
						},
						"data_time_order": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Data time order of backfill instances. Effective only if two conditions are met: 1. Must be same-cycle tasks. 2. Prioritize execution based on dependencies; if no dependency impact, execute according to the configured order. Valid values: - NORMAL: Not set - ORDER: Sequential - REVERSE: Reverse order. Default is NORMAL if not set.",
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataDataBackfillPlanRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_data_backfill_plan.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		paramMap["ProjectId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("data_backfill_plan_id"); ok {
		paramMap["DataBackfillPlanId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("time_zone"); ok {
		paramMap["TimeZone"] = helper.String(v.(string))
	}

	var respData *wedatav20250806.GetDataBackfillPlanResponseParams
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataDataBackfillPlanByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	var projectId string
	var dataBackfillPlanId string
	dataMap := map[string]interface{}{}

	if respData.Data != nil {
		if respData.Data.ProjectId != nil {
			dataMap["project_id"] = respData.Data.ProjectId
		}

		if respData.Data.DataBackfillPlanId != nil {
			dataMap["data_backfill_plan_id"] = respData.Data.DataBackfillPlanId
		}

		if respData.Data.DataBackfillPlanName != nil {
			dataMap["data_backfill_plan_name"] = respData.Data.DataBackfillPlanName
		}

		if respData.Data.TaskIds != nil {
			dataMap["task_ids"] = respData.Data.TaskIds
		}

		dataBackfillRangeListList := make([]map[string]interface{}, 0, len(respData.Data.DataBackfillRangeList))
		if respData.Data.DataBackfillRangeList != nil {
			for _, dataBackfillRangeList := range respData.Data.DataBackfillRangeList {
				dataBackfillRangeListMap := map[string]interface{}{}

				if dataBackfillRangeList.StartDate != nil {
					dataBackfillRangeListMap["start_date"] = dataBackfillRangeList.StartDate
				}

				if dataBackfillRangeList.EndDate != nil {
					dataBackfillRangeListMap["end_date"] = dataBackfillRangeList.EndDate
				}

				if dataBackfillRangeList.ExecutionStartTime != nil {
					dataBackfillRangeListMap["execution_start_time"] = dataBackfillRangeList.ExecutionStartTime
				}

				if dataBackfillRangeList.ExecutionEndTime != nil {
					dataBackfillRangeListMap["execution_end_time"] = dataBackfillRangeList.ExecutionEndTime
				}

				dataBackfillRangeListList = append(dataBackfillRangeListList, dataBackfillRangeListMap)
			}

			dataMap["data_backfill_range_list"] = dataBackfillRangeListList
		}
		if respData.Data.CheckParentType != nil {
			dataMap["check_parent_type"] = respData.Data.CheckParentType
		}

		if respData.Data.SkipEventListening != nil {
			dataMap["skip_event_listening"] = respData.Data.SkipEventListening
		}

		if respData.Data.RedefineParallelNum != nil {
			dataMap["redefine_parallel_num"] = respData.Data.RedefineParallelNum
		}

		if respData.Data.RedefineSelfWorkflowDependency != nil {
			dataMap["redefine_self_workflow_dependency"] = respData.Data.RedefineSelfWorkflowDependency
		}

		if respData.Data.SchedulerResourceGroupId != nil {
			dataMap["scheduler_resource_group_id"] = respData.Data.SchedulerResourceGroupId
		}

		if respData.Data.IntegrationResourceGroupId != nil {
			dataMap["integration_resource_group_id"] = respData.Data.IntegrationResourceGroupId
		}

		if respData.Data.RedefineCycleType != nil {
			dataMap["redefine_cycle_type"] = respData.Data.RedefineCycleType
		}

		redefineParamListList := make([]map[string]interface{}, 0, len(respData.Data.RedefineParamList))
		if respData.Data.RedefineParamList != nil {
			for _, redefineParamList := range respData.Data.RedefineParamList {
				redefineParamListMap := map[string]interface{}{}

				if redefineParamList.K != nil {
					redefineParamListMap["k"] = redefineParamList.K
				}

				if redefineParamList.V != nil {
					redefineParamListMap["v"] = redefineParamList.V
				}

				redefineParamListList = append(redefineParamListList, redefineParamListMap)
			}

			dataMap["redefine_param_list"] = redefineParamListList
		}
		if respData.Data.StartTime != nil {
			dataMap["start_time"] = respData.Data.StartTime
		}

		if respData.Data.EndTime != nil {
			dataMap["end_time"] = respData.Data.EndTime
		}

		if respData.Data.CreateUserUin != nil {
			dataMap["create_user_uin"] = respData.Data.CreateUserUin
		}

		if respData.Data.CompletePercent != nil {
			dataMap["complete_percent"] = respData.Data.CompletePercent
		}

		if respData.Data.SuccessPercent != nil {
			dataMap["success_percent"] = respData.Data.SuccessPercent
		}

		if respData.Data.DataTimeOrder != nil {
			dataMap["data_time_order"] = respData.Data.DataTimeOrder
		}

		_ = d.Set("data", []interface{}{dataMap})
	}

	d.SetId(strings.Join([]string{projectId, dataBackfillPlanId}, tccommon.FILED_SP))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
