// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudWedataOpsAlarmRule() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudWedataOpsAlarmRuleCreate,
		Read:   resourceTencentCloudWedataOpsAlarmRuleRead,
		Update: resourceTencentCloudWedataOpsAlarmRuleUpdate,
		Delete: resourceTencentCloudWedataOpsAlarmRuleDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Project id.",
			},

			"alarm_rule_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Alert rule name.",
			},

			"monitor_object_ids": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: "A list of monitored object business IDs. Different business IDs are passed in based on the MonitorType setting. For example, 1 (Task) - MonitorObjectIds is a list of task IDs; 2 (Workflow) - MonitorObjectIds is a list of workflow IDs (workflow IDs can be obtained from the ListWorkflows interface); 3 (Project) - MonitorObjectIds is a list of project IDs. Example value: [\"ddc\"].",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"alarm_types": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: "Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold. Example value: [\"failure\"].",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"alarm_groups": {
				Type:        schema.TypeList,
				Required:    true,
				Description: "Alarm receiver configuration information.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"alarm_escalation_recipient_ids": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"alarm_escalation_interval": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Alarm escalation interval.",
						},
						"notification_fatigue": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Alarm notification fatigue configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"notify_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Number of alarms.",
									},
									"notify_interval": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Alarm interval, in minutes.",
									},
									"quiet_intervals": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: "Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: \"00:00:00\", EndTime: \"09:00:00\"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"days_of_week": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: "According to the ISO standard, 1 represents Monday and 7 represents Sunday.",
													Elem: &schema.Schema{
														Type: schema.TypeInt,
													},
												},
												"start_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.",
												},
												"end_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.",
												},
											},
										},
									},
								},
							},
						},
						"alarm_ways": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"web_hooks": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "List of webhook addresses for corporate WeChat groups, Feishu groups, DingTalk groups, Slack groups, and Teams groups.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"alarm_way": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.",
									},
									"web_hooks": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "List of webhook addresses for the alarm group.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"alarm_recipient_type": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).",
						},
						"alarm_recipient_ids": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"monitor_object_type": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Monitoring object type, Task-based monitoring: Configurable by task/workflow/project: 1. Task, 2. Workflow, 3. Project (default is 1. Task). Project-based monitoring: Alerts for overall project task fluctuations, 7: Project fluctuation monitoring alerts.",
			},

			"alarm_rule_detail": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "Alarm rule configuration information: Success alarms do not require configuration. Failure alarms can be configured as either first-failure alarms or all retry failure alarms. Timeout configuration requires the timeout type and timeout threshold. Project fluctuation alarms require the fluctuation rate and anti-shake period.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"trigger": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).",
						},
						"data_backfill_or_rerun_trigger": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.",
						},
						"time_out_ext_info": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Periodic instance timeout configuration details.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rule_type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.",
									},
									"type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout value configuration type: 1-Specified value; 2-Average value.",
									},
									"hour": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Specify the timeout value in hours. The default value is 0.",
									},
									"min": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The timeout value is specified in minutes. The default value is 1.",
									},
									"schedule_time_zone": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.",
									},
								},
							},
						},
						"data_backfill_or_rerun_time_out_ext_info": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Detailed configuration of re-running and re-recording instance timeout.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rule_type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.",
									},
									"type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Timeout value configuration type: 1-Specified value; 2-Average value.",
									},
									"hour": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Specify the timeout value in hours. The default value is 0.",
									},
									"min": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The timeout value is specified in minutes. The default value is 1.",
									},
									"schedule_time_zone": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.",
									},
								},
							},
						},
						"project_instance_statistics_alarm_info_list": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Project fluctuation alarm configuration details.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"alarm_type": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.",
									},
									"instance_threshold_count_percent": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.",
									},
									"instance_threshold_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The cumulative instance number fluctuation threshold.",
									},
									"stabilize_threshold": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Stability threshold (number of statistical cycles for anti-shake configuration).",
									},
									"stabilize_statistics_cycle": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Stability statistics period (number of anti-shake configuration statistics periods).",
									},
									"is_cumulant": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "Whether to calculate cumulatively, false: continuous, true: cumulative.",
									},
									"instance_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.",
									},
								},
							},
						},
						"reconciliation_ext_info": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Offline integrated reconciliation alarm configuration information.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rule_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).",
									},
									"mismatch_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.",
									},
									"hour": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Reconciliation task timeout threshold: hours, default is 0.",
									},
									"min": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Reconciliation task timeout threshold: minutes, default is 1.",
									},
								},
							},
						},
					},
				},
			},

			"alarm_level": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Alarm level: 1. Normal, 2. Major, 3. Urgent (default 1. Normal).",
			},

			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Alarm rule description.",
			},
		},
	}
}

func resourceTencentCloudWedataOpsAlarmRuleCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_ops_alarm_rule.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		projectId   string
		alarmRuleId string
	)
	var (
		request  = wedatav20250806.NewCreateOpsAlarmRuleRequest()
		response = wedatav20250806.NewCreateOpsAlarmRuleResponse()
	)

	if v, ok := d.GetOk("project_id"); ok {
		projectId = v.(string)
		request.ProjectId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("alarm_rule_name"); ok {
		request.AlarmRuleName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("monitor_object_ids"); ok {
		monitorObjectIdsSet := v.(*schema.Set).List()
		for i := range monitorObjectIdsSet {
			monitorObjectIds := monitorObjectIdsSet[i].(string)
			request.MonitorObjectIds = append(request.MonitorObjectIds, helper.String(monitorObjectIds))
		}
	}

	if v, ok := d.GetOk("alarm_types"); ok {
		alarmTypesSet := v.(*schema.Set).List()
		for i := range alarmTypesSet {
			alarmTypes := alarmTypesSet[i].(string)
			request.AlarmTypes = append(request.AlarmTypes, helper.String(alarmTypes))
		}
	}

	if v, ok := d.GetOk("alarm_groups"); ok {
		for _, item := range v.([]interface{}) {
			alarmGroupsMap := item.(map[string]interface{})
			alarmGroup := wedatav20250806.AlarmGroup{}
			if v, ok := alarmGroupsMap["alarm_escalation_recipient_ids"]; ok {
				alarmEscalationRecipientIdsSet := v.(*schema.Set).List()
				for i := range alarmEscalationRecipientIdsSet {
					alarmEscalationRecipientIds := alarmEscalationRecipientIdsSet[i].(string)
					alarmGroup.AlarmEscalationRecipientIds = append(alarmGroup.AlarmEscalationRecipientIds, helper.String(alarmEscalationRecipientIds))
				}
			}
			if v, ok := alarmGroupsMap["alarm_escalation_interval"].(int); ok {
				alarmGroup.AlarmEscalationInterval = helper.IntInt64(v)
			}
			if notificationFatigueMap, ok := helper.ConvertInterfacesHeadToMap(alarmGroupsMap["notification_fatigue"]); ok {
				notificationFatigue := wedatav20250806.NotificationFatigue{}
				if v, ok := notificationFatigueMap["notify_count"].(int); ok {
					notificationFatigue.NotifyCount = helper.IntUint64(v)
				}
				if v, ok := notificationFatigueMap["notify_interval"].(int); ok {
					notificationFatigue.NotifyInterval = helper.IntUint64(v)
				}
				if v, ok := notificationFatigueMap["quiet_intervals"]; ok {
					for _, item := range v.([]interface{}) {
						quietIntervalsMap := item.(map[string]interface{})
						alarmQuietInterval := wedatav20250806.AlarmQuietInterval{}
						if v, ok := quietIntervalsMap["days_of_week"]; ok {
							daysOfWeekSet := v.(*schema.Set).List()
							for i := range daysOfWeekSet {
								daysOfWeek := daysOfWeekSet[i].(int)
								alarmQuietInterval.DaysOfWeek = append(alarmQuietInterval.DaysOfWeek, helper.IntUint64(daysOfWeek))
							}
						}
						if v, ok := quietIntervalsMap["start_time"].(string); ok && v != "" {
							alarmQuietInterval.StartTime = helper.String(v)
						}
						if v, ok := quietIntervalsMap["end_time"].(string); ok && v != "" {
							alarmQuietInterval.EndTime = helper.String(v)
						}
						notificationFatigue.QuietIntervals = append(notificationFatigue.QuietIntervals, &alarmQuietInterval)
					}
				}
				alarmGroup.NotificationFatigue = &notificationFatigue
			}
			if v, ok := alarmGroupsMap["alarm_ways"]; ok {
				alarmWaysSet := v.(*schema.Set).List()
				for i := range alarmWaysSet {
					alarmWays := alarmWaysSet[i].(string)
					alarmGroup.AlarmWays = append(alarmGroup.AlarmWays, helper.String(alarmWays))
				}
			}
			if v, ok := alarmGroupsMap["web_hooks"]; ok {
				for _, item := range v.([]interface{}) {
					webHooksMap := item.(map[string]interface{})
					alarmWayWebHook := wedatav20250806.AlarmWayWebHook{}
					if v, ok := webHooksMap["alarm_way"].(string); ok && v != "" {
						alarmWayWebHook.AlarmWay = helper.String(v)
					}
					if v, ok := webHooksMap["web_hooks"]; ok {
						webHooksSet := v.(*schema.Set).List()
						for i := range webHooksSet {
							webHooks := webHooksSet[i].(string)
							alarmWayWebHook.WebHooks = append(alarmWayWebHook.WebHooks, helper.String(webHooks))
						}
					}
					alarmGroup.WebHooks = append(alarmGroup.WebHooks, &alarmWayWebHook)
				}
			}
			if v, ok := alarmGroupsMap["alarm_recipient_type"].(int); ok {
				alarmGroup.AlarmRecipientType = helper.IntInt64(v)
			}
			if v, ok := alarmGroupsMap["alarm_recipient_ids"]; ok {
				alarmRecipientIdsSet := v.(*schema.Set).List()
				for i := range alarmRecipientIdsSet {
					alarmRecipientIds := alarmRecipientIdsSet[i].(string)
					alarmGroup.AlarmRecipientIds = append(alarmGroup.AlarmRecipientIds, helper.String(alarmRecipientIds))
				}
			}
			request.AlarmGroups = append(request.AlarmGroups, &alarmGroup)
		}
	}

	if v, ok := d.GetOkExists("monitor_object_type"); ok {
		request.MonitorObjectType = helper.IntUint64(v.(int))
	}

	if alarmRuleDetailMap, ok := helper.InterfacesHeadMap(d, "alarm_rule_detail"); ok {
		alarmRuleDetail := wedatav20250806.AlarmRuleDetail{}
		if v, ok := alarmRuleDetailMap["trigger"].(int); ok {
			alarmRuleDetail.Trigger = helper.IntInt64(v)
		}
		if v, ok := alarmRuleDetailMap["data_backfill_or_rerun_trigger"].(int); ok {
			alarmRuleDetail.DataBackfillOrRerunTrigger = helper.IntInt64(v)
		}
		if v, ok := alarmRuleDetailMap["time_out_ext_info"]; ok {
			for _, item := range v.([]interface{}) {
				timeOutExtInfoMap := item.(map[string]interface{})
				timeOutStrategyInfo := wedatav20250806.TimeOutStrategyInfo{}
				if v, ok := timeOutExtInfoMap["rule_type"].(int); ok {
					timeOutStrategyInfo.RuleType = helper.IntInt64(v)
				}
				if v, ok := timeOutExtInfoMap["type"].(int); ok {
					timeOutStrategyInfo.Type = helper.IntInt64(v)
				}
				if v, ok := timeOutExtInfoMap["hour"].(int); ok {
					timeOutStrategyInfo.Hour = helper.IntUint64(v)
				}
				if v, ok := timeOutExtInfoMap["min"].(int); ok {
					timeOutStrategyInfo.Min = helper.IntInt64(v)
				}
				if v, ok := timeOutExtInfoMap["schedule_time_zone"].(string); ok && v != "" {
					timeOutStrategyInfo.ScheduleTimeZone = helper.String(v)
				}
				alarmRuleDetail.TimeOutExtInfo = append(alarmRuleDetail.TimeOutExtInfo, &timeOutStrategyInfo)
			}
		}
		if v, ok := alarmRuleDetailMap["data_backfill_or_rerun_time_out_ext_info"]; ok {
			for _, item := range v.([]interface{}) {
				dataBackfillOrRerunTimeOutExtInfoMap := item.(map[string]interface{})
				timeOutStrategyInfo := wedatav20250806.TimeOutStrategyInfo{}
				if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["rule_type"].(int); ok {
					timeOutStrategyInfo.RuleType = helper.IntInt64(v)
				}
				if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["type"].(int); ok {
					timeOutStrategyInfo.Type = helper.IntInt64(v)
				}
				if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["hour"].(int); ok {
					timeOutStrategyInfo.Hour = helper.IntUint64(v)
				}
				if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["min"].(int); ok {
					timeOutStrategyInfo.Min = helper.IntInt64(v)
				}
				if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["schedule_time_zone"].(string); ok && v != "" {
					timeOutStrategyInfo.ScheduleTimeZone = helper.String(v)
				}
				alarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo = append(alarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo, &timeOutStrategyInfo)
			}
		}
		if v, ok := alarmRuleDetailMap["project_instance_statistics_alarm_info_list"]; ok {
			for _, item := range v.([]interface{}) {
				projectInstanceStatisticsAlarmInfoListMap := item.(map[string]interface{})
				projectInstanceStatisticsAlarmInfo := wedatav20250806.ProjectInstanceStatisticsAlarmInfo{}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["alarm_type"].(string); ok && v != "" {
					projectInstanceStatisticsAlarmInfo.AlarmType = helper.String(v)
				}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count_percent"].(int); ok {
					projectInstanceStatisticsAlarmInfo.InstanceThresholdCountPercent = helper.IntUint64(v)
				}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count"].(int); ok {
					projectInstanceStatisticsAlarmInfo.InstanceThresholdCount = helper.IntUint64(v)
				}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["stabilize_threshold"].(int); ok {
					projectInstanceStatisticsAlarmInfo.StabilizeThreshold = helper.IntUint64(v)
				}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["stabilize_statistics_cycle"].(int); ok {
					projectInstanceStatisticsAlarmInfo.StabilizeStatisticsCycle = helper.IntUint64(v)
				}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["is_cumulant"].(bool); ok {
					projectInstanceStatisticsAlarmInfo.IsCumulant = helper.Bool(v)
				}
				if v, ok := projectInstanceStatisticsAlarmInfoListMap["instance_count"].(int); ok {
					projectInstanceStatisticsAlarmInfo.InstanceCount = helper.IntUint64(v)
				}
				alarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList = append(alarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList, &projectInstanceStatisticsAlarmInfo)
			}
		}
		if v, ok := alarmRuleDetailMap["reconciliation_ext_info"]; ok {
			for _, item := range v.([]interface{}) {
				reconciliationExtInfoMap := item.(map[string]interface{})
				reconciliationStrategyInfo := wedatav20250806.ReconciliationStrategyInfo{}
				if v, ok := reconciliationExtInfoMap["rule_type"].(string); ok && v != "" {
					reconciliationStrategyInfo.RuleType = helper.String(v)
				}
				if v, ok := reconciliationExtInfoMap["mismatch_count"].(int); ok {
					reconciliationStrategyInfo.MismatchCount = helper.IntUint64(v)
				}
				if v, ok := reconciliationExtInfoMap["hour"].(int); ok {
					reconciliationStrategyInfo.Hour = helper.IntInt64(v)
				}
				if v, ok := reconciliationExtInfoMap["min"].(int); ok {
					reconciliationStrategyInfo.Min = helper.IntInt64(v)
				}
				alarmRuleDetail.ReconciliationExtInfo = append(alarmRuleDetail.ReconciliationExtInfo, &reconciliationStrategyInfo)
			}
		}
		request.AlarmRuleDetail = &alarmRuleDetail
	}

	if v, ok := d.GetOkExists("alarm_level"); ok {
		request.AlarmLevel = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOk("description"); ok {
		request.Description = helper.String(v.(string))
	}

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().CreateOpsAlarmRuleWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s create wedata ops alarm rule failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	if response == nil || response.Response == nil || response.Response.Data == nil || response.Response.Data.AlarmRuleId == nil {
		return fmt.Errorf("Create an alarm rule. AlarmRuleId is empty.")
	}

	alarmRuleId = *response.Response.Data.AlarmRuleId

	d.SetId(strings.Join([]string{projectId, alarmRuleId}, tccommon.FILED_SP))

	return resourceTencentCloudWedataOpsAlarmRuleRead(d, meta)
}

func resourceTencentCloudWedataOpsAlarmRuleRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_ops_alarm_rule.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	alarmRuleId := idSplit[1]

	respData, err := service.DescribeWedataOpsAlarmRuleById(ctx, projectId, alarmRuleId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `wedata_ops_alarm_rule` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}

	_ = d.Set("project_id", projectId)

	if respData.AlarmRuleName != nil {
		_ = d.Set("alarm_rule_name", respData.AlarmRuleName)
	}

	if respData.Description != nil {
		_ = d.Set("description", respData.Description)
	}

	if respData.MonitorObjectType != nil {
		_ = d.Set("monitor_object_type", respData.MonitorObjectType)
	}

	if respData.MonitorObjectIds != nil {
		_ = d.Set("monitor_object_ids", respData.MonitorObjectIds)
	}

	if respData.AlarmTypes != nil {
		_ = d.Set("alarm_types", respData.AlarmTypes)
	}

	alarmRuleDetailMap := map[string]interface{}{}

	if respData.AlarmRuleDetail != nil {
		if respData.AlarmRuleDetail.Trigger != nil {
			alarmRuleDetailMap["trigger"] = respData.AlarmRuleDetail.Trigger
		}

		if respData.AlarmRuleDetail.DataBackfillOrRerunTrigger != nil {
			alarmRuleDetailMap["data_backfill_or_rerun_trigger"] = respData.AlarmRuleDetail.DataBackfillOrRerunTrigger
		}

		timeOutExtInfoList := make([]map[string]interface{}, 0, len(respData.AlarmRuleDetail.TimeOutExtInfo))
		if respData.AlarmRuleDetail.TimeOutExtInfo != nil {
			for _, timeOutExtInfo := range respData.AlarmRuleDetail.TimeOutExtInfo {
				timeOutExtInfoMap := map[string]interface{}{}

				if timeOutExtInfo.RuleType != nil {
					timeOutExtInfoMap["rule_type"] = timeOutExtInfo.RuleType
				}

				if timeOutExtInfo.Type != nil {
					timeOutExtInfoMap["type"] = timeOutExtInfo.Type
				}

				if timeOutExtInfo.Hour != nil {
					timeOutExtInfoMap["hour"] = timeOutExtInfo.Hour
				}

				if timeOutExtInfo.Min != nil {
					timeOutExtInfoMap["min"] = timeOutExtInfo.Min
				}

				if timeOutExtInfo.ScheduleTimeZone != nil {
					timeOutExtInfoMap["schedule_time_zone"] = timeOutExtInfo.ScheduleTimeZone
				}

				timeOutExtInfoList = append(timeOutExtInfoList, timeOutExtInfoMap)
			}

			alarmRuleDetailMap["time_out_ext_info"] = timeOutExtInfoList
		}
		dataBackfillOrRerunTimeOutExtInfoList := make([]map[string]interface{}, 0, len(respData.AlarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo))
		if respData.AlarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo != nil {
			for _, dataBackfillOrRerunTimeOutExtInfo := range respData.AlarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo {
				dataBackfillOrRerunTimeOutExtInfoMap := map[string]interface{}{}

				if dataBackfillOrRerunTimeOutExtInfo.RuleType != nil {
					dataBackfillOrRerunTimeOutExtInfoMap["rule_type"] = dataBackfillOrRerunTimeOutExtInfo.RuleType
				}

				if dataBackfillOrRerunTimeOutExtInfo.Type != nil {
					dataBackfillOrRerunTimeOutExtInfoMap["type"] = dataBackfillOrRerunTimeOutExtInfo.Type
				}

				if dataBackfillOrRerunTimeOutExtInfo.Hour != nil {
					dataBackfillOrRerunTimeOutExtInfoMap["hour"] = dataBackfillOrRerunTimeOutExtInfo.Hour
				}

				if dataBackfillOrRerunTimeOutExtInfo.Min != nil {
					dataBackfillOrRerunTimeOutExtInfoMap["min"] = dataBackfillOrRerunTimeOutExtInfo.Min
				}

				if dataBackfillOrRerunTimeOutExtInfo.ScheduleTimeZone != nil {
					dataBackfillOrRerunTimeOutExtInfoMap["schedule_time_zone"] = dataBackfillOrRerunTimeOutExtInfo.ScheduleTimeZone
				}

				dataBackfillOrRerunTimeOutExtInfoList = append(dataBackfillOrRerunTimeOutExtInfoList, dataBackfillOrRerunTimeOutExtInfoMap)
			}

			alarmRuleDetailMap["data_backfill_or_rerun_time_out_ext_info"] = dataBackfillOrRerunTimeOutExtInfoList
		}
		projectInstanceStatisticsAlarmInfoListList := make([]map[string]interface{}, 0, len(respData.AlarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList))
		if respData.AlarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList != nil {
			for _, projectInstanceStatisticsAlarmInfoList := range respData.AlarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList {
				projectInstanceStatisticsAlarmInfoListMap := map[string]interface{}{}

				if projectInstanceStatisticsAlarmInfoList.AlarmType != nil {
					projectInstanceStatisticsAlarmInfoListMap["alarm_type"] = projectInstanceStatisticsAlarmInfoList.AlarmType
				}

				if projectInstanceStatisticsAlarmInfoList.InstanceThresholdCountPercent != nil {
					projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count_percent"] = projectInstanceStatisticsAlarmInfoList.InstanceThresholdCountPercent
				}

				if projectInstanceStatisticsAlarmInfoList.InstanceThresholdCount != nil {
					projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count"] = projectInstanceStatisticsAlarmInfoList.InstanceThresholdCount
				}

				if projectInstanceStatisticsAlarmInfoList.StabilizeThreshold != nil {
					projectInstanceStatisticsAlarmInfoListMap["stabilize_threshold"] = projectInstanceStatisticsAlarmInfoList.StabilizeThreshold
				}

				if projectInstanceStatisticsAlarmInfoList.StabilizeStatisticsCycle != nil {
					projectInstanceStatisticsAlarmInfoListMap["stabilize_statistics_cycle"] = projectInstanceStatisticsAlarmInfoList.StabilizeStatisticsCycle
				}

				if projectInstanceStatisticsAlarmInfoList.IsCumulant != nil {
					projectInstanceStatisticsAlarmInfoListMap["is_cumulant"] = projectInstanceStatisticsAlarmInfoList.IsCumulant
				}

				if projectInstanceStatisticsAlarmInfoList.InstanceCount != nil {
					projectInstanceStatisticsAlarmInfoListMap["instance_count"] = projectInstanceStatisticsAlarmInfoList.InstanceCount
				}

				projectInstanceStatisticsAlarmInfoListList = append(projectInstanceStatisticsAlarmInfoListList, projectInstanceStatisticsAlarmInfoListMap)
			}

			alarmRuleDetailMap["project_instance_statistics_alarm_info_list"] = projectInstanceStatisticsAlarmInfoListList
		}
		reconciliationExtInfoList := make([]map[string]interface{}, 0, len(respData.AlarmRuleDetail.ReconciliationExtInfo))
		if respData.AlarmRuleDetail.ReconciliationExtInfo != nil {
			for _, reconciliationExtInfo := range respData.AlarmRuleDetail.ReconciliationExtInfo {
				reconciliationExtInfoMap := map[string]interface{}{}

				if reconciliationExtInfo.RuleType != nil {
					reconciliationExtInfoMap["rule_type"] = reconciliationExtInfo.RuleType
				}

				if reconciliationExtInfo.MismatchCount != nil {
					reconciliationExtInfoMap["mismatch_count"] = reconciliationExtInfo.MismatchCount
				}

				if reconciliationExtInfo.Hour != nil {
					reconciliationExtInfoMap["hour"] = reconciliationExtInfo.Hour
				}

				if reconciliationExtInfo.Min != nil {
					reconciliationExtInfoMap["min"] = reconciliationExtInfo.Min
				}

				reconciliationExtInfoList = append(reconciliationExtInfoList, reconciliationExtInfoMap)
			}

			alarmRuleDetailMap["reconciliation_ext_info"] = reconciliationExtInfoList
		}
		_ = d.Set("alarm_rule_detail", []interface{}{alarmRuleDetailMap})
	}

	if respData.AlarmLevel != nil {
		_ = d.Set("alarm_level", respData.AlarmLevel)
	}

	alarmGroupsList := make([]map[string]interface{}, 0, len(respData.AlarmGroups))
	if respData.AlarmGroups != nil {
		for _, alarmGroups := range respData.AlarmGroups {
			alarmGroupsMap := map[string]interface{}{}

			if alarmGroups.AlarmEscalationRecipientIds != nil {
				alarmGroupsMap["alarm_escalation_recipient_ids"] = alarmGroups.AlarmEscalationRecipientIds
			}

			if alarmGroups.AlarmEscalationInterval != nil {
				alarmGroupsMap["alarm_escalation_interval"] = alarmGroups.AlarmEscalationInterval
			}

			notificationFatigueMap := map[string]interface{}{}

			if alarmGroups.NotificationFatigue != nil {
				if alarmGroups.NotificationFatigue.NotifyCount != nil {
					notificationFatigueMap["notify_count"] = alarmGroups.NotificationFatigue.NotifyCount
				}

				if alarmGroups.NotificationFatigue.NotifyInterval != nil {
					notificationFatigueMap["notify_interval"] = alarmGroups.NotificationFatigue.NotifyInterval
				}

				quietIntervalsList := make([]map[string]interface{}, 0, len(alarmGroups.NotificationFatigue.QuietIntervals))
				if alarmGroups.NotificationFatigue.QuietIntervals != nil {
					for _, quietIntervals := range alarmGroups.NotificationFatigue.QuietIntervals {
						quietIntervalsMap := map[string]interface{}{}

						if quietIntervals.DaysOfWeek != nil {
							quietIntervalsMap["days_of_week"] = quietIntervals.DaysOfWeek
						}

						if quietIntervals.StartTime != nil {
							quietIntervalsMap["start_time"] = quietIntervals.StartTime
						}

						if quietIntervals.EndTime != nil {
							quietIntervalsMap["end_time"] = quietIntervals.EndTime
						}

						quietIntervalsList = append(quietIntervalsList, quietIntervalsMap)
					}

					notificationFatigueMap["quiet_intervals"] = quietIntervalsList
				}
				alarmGroupsMap["notification_fatigue"] = []interface{}{notificationFatigueMap}
			}

			if alarmGroups.AlarmWays != nil {
				alarmGroupsMap["alarm_ways"] = alarmGroups.AlarmWays
			}

			webHooksList := make([]map[string]interface{}, 0, len(alarmGroups.WebHooks))
			if alarmGroups.WebHooks != nil {
				for _, webHooks := range alarmGroups.WebHooks {
					webHooksMap := map[string]interface{}{}

					if webHooks.AlarmWay != nil {
						webHooksMap["alarm_way"] = webHooks.AlarmWay
					}

					if webHooks.WebHooks != nil {
						webHooksMap["web_hooks"] = webHooks.WebHooks
					}

					webHooksList = append(webHooksList, webHooksMap)
				}

				alarmGroupsMap["web_hooks"] = webHooksList
			}
			if alarmGroups.AlarmRecipientType != nil {
				alarmGroupsMap["alarm_recipient_type"] = alarmGroups.AlarmRecipientType
			}

			if alarmGroups.AlarmRecipientIds != nil {
				alarmGroupsMap["alarm_recipient_ids"] = alarmGroups.AlarmRecipientIds
			}

			alarmGroupsList = append(alarmGroupsList, alarmGroupsMap)
		}

		_ = d.Set("alarm_groups", alarmGroupsList)
	}

	return nil
}

func resourceTencentCloudWedataOpsAlarmRuleUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_ops_alarm_rule.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	alarmRuleId := idSplit[1]

	needChange := false
	mutableArgs := []string{"alarm_rule_name", "monitor_object_type", "monitor_object_ids", "alarm_types", "alarm_rule_detail", "status", "alarm_level", "alarm_groups", "description"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := wedatav20250806.NewUpdateOpsAlarmRuleRequest()
		request.ProjectId = helper.String(projectId)
		request.AlarmRuleId = helper.String(alarmRuleId)

		if v, ok := d.GetOk("alarm_rule_name"); ok {
			request.AlarmRuleName = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("monitor_object_type"); ok {
			request.MonitorObjectType = helper.IntInt64(v.(int))
		}

		if v, ok := d.GetOk("monitor_object_ids"); ok {
			monitorObjectIdsSet := v.(*schema.Set).List()
			for i := range monitorObjectIdsSet {
				monitorObjectIds := monitorObjectIdsSet[i].(string)
				request.MonitorObjectIds = append(request.MonitorObjectIds, helper.String(monitorObjectIds))
			}
		}

		if v, ok := d.GetOk("alarm_types"); ok {
			alarmTypesSet := v.(*schema.Set).List()
			for i := range alarmTypesSet {
				alarmTypes := alarmTypesSet[i].(string)
				request.AlarmTypes = append(request.AlarmTypes, helper.String(alarmTypes))
			}
		}

		if alarmRuleDetailMap, ok := helper.InterfacesHeadMap(d, "alarm_rule_detail"); ok {
			alarmRuleDetail := wedatav20250806.AlarmRuleDetail{}
			if v, ok := alarmRuleDetailMap["trigger"].(int); ok {
				alarmRuleDetail.Trigger = helper.IntInt64(v)
			}
			if v, ok := alarmRuleDetailMap["data_backfill_or_rerun_trigger"].(int); ok {
				alarmRuleDetail.DataBackfillOrRerunTrigger = helper.IntInt64(v)
			}
			if v, ok := alarmRuleDetailMap["time_out_ext_info"]; ok {
				for _, item := range v.([]interface{}) {
					timeOutExtInfoMap := item.(map[string]interface{})
					timeOutStrategyInfo := wedatav20250806.TimeOutStrategyInfo{}
					if v, ok := timeOutExtInfoMap["rule_type"].(int); ok {
						timeOutStrategyInfo.RuleType = helper.IntInt64(v)
					}
					if v, ok := timeOutExtInfoMap["type"].(int); ok {
						timeOutStrategyInfo.Type = helper.IntInt64(v)
					}
					if v, ok := timeOutExtInfoMap["hour"].(int); ok {
						timeOutStrategyInfo.Hour = helper.IntUint64(v)
					}
					if v, ok := timeOutExtInfoMap["min"].(int); ok {
						timeOutStrategyInfo.Min = helper.IntInt64(v)
					}
					if v, ok := timeOutExtInfoMap["schedule_time_zone"].(string); ok && v != "" {
						timeOutStrategyInfo.ScheduleTimeZone = helper.String(v)
					}
					alarmRuleDetail.TimeOutExtInfo = append(alarmRuleDetail.TimeOutExtInfo, &timeOutStrategyInfo)
				}
			}
			if v, ok := alarmRuleDetailMap["data_backfill_or_rerun_time_out_ext_info"]; ok {
				for _, item := range v.([]interface{}) {
					dataBackfillOrRerunTimeOutExtInfoMap := item.(map[string]interface{})
					timeOutStrategyInfo := wedatav20250806.TimeOutStrategyInfo{}
					if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["rule_type"].(int); ok {
						timeOutStrategyInfo.RuleType = helper.IntInt64(v)
					}
					if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["type"].(int); ok {
						timeOutStrategyInfo.Type = helper.IntInt64(v)
					}
					if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["hour"].(int); ok {
						timeOutStrategyInfo.Hour = helper.IntUint64(v)
					}
					if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["min"].(int); ok {
						timeOutStrategyInfo.Min = helper.IntInt64(v)
					}
					if v, ok := dataBackfillOrRerunTimeOutExtInfoMap["schedule_time_zone"].(string); ok && v != "" {
						timeOutStrategyInfo.ScheduleTimeZone = helper.String(v)
					}
					alarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo = append(alarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo, &timeOutStrategyInfo)
				}
			}
			if v, ok := alarmRuleDetailMap["project_instance_statistics_alarm_info_list"]; ok {
				for _, item := range v.([]interface{}) {
					projectInstanceStatisticsAlarmInfoListMap := item.(map[string]interface{})
					projectInstanceStatisticsAlarmInfo := wedatav20250806.ProjectInstanceStatisticsAlarmInfo{}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["alarm_type"].(string); ok && v != "" {
						projectInstanceStatisticsAlarmInfo.AlarmType = helper.String(v)
					}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count_percent"].(int); ok {
						projectInstanceStatisticsAlarmInfo.InstanceThresholdCountPercent = helper.IntUint64(v)
					}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count"].(int); ok {
						projectInstanceStatisticsAlarmInfo.InstanceThresholdCount = helper.IntUint64(v)
					}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["stabilize_threshold"].(int); ok {
						projectInstanceStatisticsAlarmInfo.StabilizeThreshold = helper.IntUint64(v)
					}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["stabilize_statistics_cycle"].(int); ok {
						projectInstanceStatisticsAlarmInfo.StabilizeStatisticsCycle = helper.IntUint64(v)
					}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["is_cumulant"].(bool); ok {
						projectInstanceStatisticsAlarmInfo.IsCumulant = helper.Bool(v)
					}
					if v, ok := projectInstanceStatisticsAlarmInfoListMap["instance_count"].(int); ok {
						projectInstanceStatisticsAlarmInfo.InstanceCount = helper.IntUint64(v)
					}
					alarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList = append(alarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList, &projectInstanceStatisticsAlarmInfo)
				}
			}
			if v, ok := alarmRuleDetailMap["reconciliation_ext_info"]; ok {
				for _, item := range v.([]interface{}) {
					reconciliationExtInfoMap := item.(map[string]interface{})
					reconciliationStrategyInfo := wedatav20250806.ReconciliationStrategyInfo{}
					if v, ok := reconciliationExtInfoMap["rule_type"].(string); ok && v != "" {
						reconciliationStrategyInfo.RuleType = helper.String(v)
					}
					if v, ok := reconciliationExtInfoMap["mismatch_count"].(int); ok {
						reconciliationStrategyInfo.MismatchCount = helper.IntUint64(v)
					}
					if v, ok := reconciliationExtInfoMap["hour"].(int); ok {
						reconciliationStrategyInfo.Hour = helper.IntInt64(v)
					}
					if v, ok := reconciliationExtInfoMap["min"].(int); ok {
						reconciliationStrategyInfo.Min = helper.IntInt64(v)
					}
					alarmRuleDetail.ReconciliationExtInfo = append(alarmRuleDetail.ReconciliationExtInfo, &reconciliationStrategyInfo)
				}
			}
			request.AlarmRuleDetail = &alarmRuleDetail
		}

		if v, ok := d.GetOkExists("status"); ok {
			request.Status = helper.IntInt64(v.(int))
		}

		if v, ok := d.GetOkExists("alarm_level"); ok {
			request.AlarmLevel = helper.IntInt64(v.(int))
		}

		if v, ok := d.GetOk("alarm_groups"); ok {
			for _, item := range v.([]interface{}) {
				alarmGroupsMap := item.(map[string]interface{})
				alarmGroup := wedatav20250806.AlarmGroup{}
				if v, ok := alarmGroupsMap["alarm_escalation_recipient_ids"]; ok {
					alarmEscalationRecipientIdsSet := v.(*schema.Set).List()
					for i := range alarmEscalationRecipientIdsSet {
						alarmEscalationRecipientIds := alarmEscalationRecipientIdsSet[i].(string)
						alarmGroup.AlarmEscalationRecipientIds = append(alarmGroup.AlarmEscalationRecipientIds, helper.String(alarmEscalationRecipientIds))
					}
				}
				if v, ok := alarmGroupsMap["alarm_escalation_interval"].(int); ok {
					alarmGroup.AlarmEscalationInterval = helper.IntInt64(v)
				}
				if notificationFatigueMap, ok := helper.ConvertInterfacesHeadToMap(alarmGroupsMap["notification_fatigue"]); ok {
					notificationFatigue := wedatav20250806.NotificationFatigue{}
					if v, ok := notificationFatigueMap["notify_count"].(int); ok {
						notificationFatigue.NotifyCount = helper.IntUint64(v)
					}
					if v, ok := notificationFatigueMap["notify_interval"].(int); ok {
						notificationFatigue.NotifyInterval = helper.IntUint64(v)
					}
					if v, ok := notificationFatigueMap["quiet_intervals"]; ok {
						for _, item := range v.([]interface{}) {
							quietIntervalsMap := item.(map[string]interface{})
							alarmQuietInterval := wedatav20250806.AlarmQuietInterval{}
							if v, ok := quietIntervalsMap["days_of_week"]; ok {
								daysOfWeekSet := v.(*schema.Set).List()
								for i := range daysOfWeekSet {
									daysOfWeek := daysOfWeekSet[i].(int)
									alarmQuietInterval.DaysOfWeek = append(alarmQuietInterval.DaysOfWeek, helper.IntUint64(daysOfWeek))
								}
							}
							if v, ok := quietIntervalsMap["start_time"].(string); ok && v != "" {
								alarmQuietInterval.StartTime = helper.String(v)
							}
							if v, ok := quietIntervalsMap["end_time"].(string); ok && v != "" {
								alarmQuietInterval.EndTime = helper.String(v)
							}
							notificationFatigue.QuietIntervals = append(notificationFatigue.QuietIntervals, &alarmQuietInterval)
						}
					}
					alarmGroup.NotificationFatigue = &notificationFatigue
				}
				if v, ok := alarmGroupsMap["alarm_ways"]; ok {
					alarmWaysSet := v.(*schema.Set).List()
					for i := range alarmWaysSet {
						alarmWays := alarmWaysSet[i].(string)
						alarmGroup.AlarmWays = append(alarmGroup.AlarmWays, helper.String(alarmWays))
					}
				}
				if v, ok := alarmGroupsMap["web_hooks"]; ok {
					for _, item := range v.([]interface{}) {
						webHooksMap := item.(map[string]interface{})
						alarmWayWebHook := wedatav20250806.AlarmWayWebHook{}
						if v, ok := webHooksMap["alarm_way"].(string); ok && v != "" {
							alarmWayWebHook.AlarmWay = helper.String(v)
						}
						if v, ok := webHooksMap["web_hooks"]; ok {
							webHooksSet := v.(*schema.Set).List()
							for i := range webHooksSet {
								webHooks := webHooksSet[i].(string)
								alarmWayWebHook.WebHooks = append(alarmWayWebHook.WebHooks, helper.String(webHooks))
							}
						}
						alarmGroup.WebHooks = append(alarmGroup.WebHooks, &alarmWayWebHook)
					}
				}
				if v, ok := alarmGroupsMap["alarm_recipient_type"].(int); ok {
					alarmGroup.AlarmRecipientType = helper.IntInt64(v)
				}
				if v, ok := alarmGroupsMap["alarm_recipient_ids"]; ok {
					alarmRecipientIdsSet := v.(*schema.Set).List()
					for i := range alarmRecipientIdsSet {
						alarmRecipientIds := alarmRecipientIdsSet[i].(string)
						alarmGroup.AlarmRecipientIds = append(alarmGroup.AlarmRecipientIds, helper.String(alarmRecipientIds))
					}
				}
				request.AlarmGroups = append(request.AlarmGroups, &alarmGroup)
			}
		}

		if v, ok := d.GetOk("description"); ok {
			request.Description = helper.String(v.(string))
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().UpdateOpsAlarmRuleWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update wedata ops alarm rule failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	_ = projectId
	_ = alarmRuleId
	return resourceTencentCloudWedataOpsAlarmRuleRead(d, meta)
}

func resourceTencentCloudWedataOpsAlarmRuleDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_ops_alarm_rule.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	alarmRuleId := idSplit[1]

	var (
		request  = wedatav20250806.NewDeleteOpsAlarmRuleRequest()
		response = wedatav20250806.NewDeleteOpsAlarmRuleResponse()
	)
	request.ProjectId = helper.String(projectId)
	request.AlarmRuleId = helper.String(alarmRuleId)

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().DeleteOpsAlarmRuleWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s delete wedata ops alarm rule failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	_ = response
	_ = projectId
	_ = alarmRuleId
	return nil
}
