// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataQualityRuleTemplates() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataQualityRuleTemplatesRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Workspace ID.",
			},

			"order_fields": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "General sorting, supported sorting fields: `CitationCount` - Sort by citation count; `UpdateTime` - Sort by update time. Sort direction: `1` - Ascending (ASC); `2` - Descending (DESC).",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Sort field name.",
						},
						"direction": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Sort direction: ASC|DESC.",
						},
					},
				},
			},

			"filters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "General filter conditions 1. `Id` Description: Template ID, Value: Unique identifier of the template; 2. `Keyword` Description: Keyword search, supports fuzzy search of template names, Value: String; 3. `Type` Description: Template type, Value: `1` - System template; `2` - Custom template; supports multiple values (OR relationship); 4. `QualityDim` Description: Quality detection dimension, Value: `1` - Accuracy; `2` - Uniqueness; `3` - Completeness; `4` - Consistency; `5` - Timeliness; `6` - Validity; supports multiple values (OR relationship); 5. `SourceObjectType` Description: Source data object type applicable to the rule, Value: `1` - Constant; `2` - Offline table level; `3` - Offline field level; `4` - Database level; supports multiple values (OR relationship); 6. `SourceEngineTypes` Description: Source data engine type applicable to the template, Value: `1` - MySQL; `2` - Hive; `4` - Spark; `8` - Livy; `16` - DLC; `32` - Gbase; `64` - TCHouse-P; `128` - Doris; `256` - TCHouse-D; `512` - EMR_StarRocks; `1024` - TCHouse-X; supports multiple values (OR relationship).",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Filter field name.",
						},
						"values": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Filter value list.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Result.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"total_count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Total count.",
						},
						"items": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Template list.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rule_template_id": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Rule template ID.",
									},
									"name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Rule template name.",
									},
									"description": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Rule template description.",
									},
									"type": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Template type (1: System template, 2: Custom template).",
									},
									"source_object_type": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Source data object type applicable to the rule (1: Constant, 2: Offline table level, 3: Offline field level).",
									},
									"source_object_data_type": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Source data object data type applicable to the rule (1: Numeric, 2: String).",
									},
									"source_content": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Rule template source content, differentiated by engine, JSON structure.",
									},
									"source_engine_types": {
										Type:        schema.TypeSet,
										Required:    true,
										Description: "Source data applicable types.",
										Elem: &schema.Schema{
											Type: schema.TypeInt,
										},
									},
									"quality_dim": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Quality dimension of the rule (1: Accuracy, 2: Uniqueness, 3: Completeness, 4: Consistency, 5: Timeliness, 6: Validity).",
									},
									"compare_type": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Comparison type supported by the rule (1: Fixed value comparison, greater than, less than, greater than or equal to, etc. 2: Fluctuation value comparison, absolute value, increase, decrease).",
									},
									"citation_count": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Citation count.",
									},
									"user_id": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Creator user ID.",
									},
									"user_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Creator username.",
									},
									"update_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Update time yyyy-MM-dd HH:mm:ss.",
									},
									"where_flag": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: "Whether to add where parameter.",
									},
									"multi_source_flag": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: "Whether to associate multiple database tables.",
									},
									"sql_expression": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Custom template SQL expression.",
									},
									"sub_quality_dim": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Template sub-dimension, 0. Parent dimension type, 1. Consistency: Enumeration range consistency, 2. Consistency: Numeric range consistency, 3. Consistency: Field data correlation.",
									},
									"resolved_sql_expression": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "SQL expression parsing object.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"table_expressions": {
													Type:        schema.TypeList,
													Required:    true,
													Description: "SQL expression table names.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"table_expression": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "SQL expression table name.",
															},
															"column_expression": {
																Type:        schema.TypeSet,
																Required:    true,
																Description: "SQL expression field names.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
												"param_expressions": {
													Type:        schema.TypeSet,
													Required:    true,
													Description: "SQL expression field names.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"system_template_expressions": {
													Type:        schema.TypeSet,
													Required:    true,
													Description: "Placeholder collection in system template SQL for new model detection.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"datasource_types": {
										Type:        schema.TypeSet,
										Required:    true,
										Description: "Supported data source types.",
										Elem: &schema.Schema{
											Type: schema.TypeInt,
										},
									},
									"user_id_str": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Creator user ID string.",
									},
								},
							},
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataQualityRuleTemplatesRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_quality_rule_templates.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		paramMap["ProjectId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("order_fields"); ok {
		orderFieldsSet := v.([]interface{})
		tmpSet := make([]*wedatav20250806.OrderField, 0, len(orderFieldsSet))
		for _, item := range orderFieldsSet {
			orderFieldsMap := item.(map[string]interface{})
			orderField := wedatav20250806.OrderField{}
			if v, ok := orderFieldsMap["name"].(string); ok && v != "" {
				orderField.Name = helper.String(v)
			}
			if v, ok := orderFieldsMap["direction"].(string); ok && v != "" {
				orderField.Direction = helper.String(v)
			}
			tmpSet = append(tmpSet, &orderField)
		}
		paramMap["OrderFields"] = tmpSet
	}

	if v, ok := d.GetOk("filters"); ok {
		filtersSet := v.([]interface{})
		tmpSet := make([]*wedatav20250806.Filter, 0, len(filtersSet))
		for _, item := range filtersSet {
			filtersMap := item.(map[string]interface{})
			filter := wedatav20250806.Filter{}
			if v, ok := filtersMap["name"].(string); ok && v != "" {
				filter.Name = helper.String(v)
			}
			if v, ok := filtersMap["values"]; ok {
				valuesSet := v.(*schema.Set).List()
				for i := range valuesSet {
					values := valuesSet[i].(string)
					filter.Values = append(filter.Values, helper.String(values))
				}
			}
			tmpSet = append(tmpSet, &filter)
		}
		paramMap["Filters"] = tmpSet
	}

	var respData *wedatav20250806.ListQualityRuleTemplatesResponseParams
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataQualityRuleTemplatesByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	dataMap := map[string]interface{}{}
	ids := []string{}

	if respData.Data != nil {
		if respData.Data.TotalCount != nil {
			dataMap["total_count"] = respData.Data.TotalCount
		}

		itemsList := make([]map[string]interface{}, 0, len(respData.Data.Items))
		if respData.Data.Items != nil {
			for _, items := range respData.Data.Items {
				itemsMap := map[string]interface{}{}

				if items.RuleTemplateId != nil {
					itemsMap["rule_template_id"] = items.RuleTemplateId
					ids = append(ids, strconv.FormatUint(*items.RuleTemplateId, 10))
				}

				if items.Name != nil {
					itemsMap["name"] = items.Name
				}

				if items.Description != nil {
					itemsMap["description"] = items.Description
				}

				if items.Type != nil {
					itemsMap["type"] = items.Type
				}

				if items.SourceObjectType != nil {
					itemsMap["source_object_type"] = items.SourceObjectType
				}

				if items.SourceObjectDataType != nil {
					itemsMap["source_object_data_type"] = items.SourceObjectDataType
				}

				if items.SourceContent != nil {
					itemsMap["source_content"] = items.SourceContent
				}

				if items.SourceEngineTypes != nil {
					itemsMap["source_engine_types"] = items.SourceEngineTypes
				}

				if items.QualityDim != nil {
					itemsMap["quality_dim"] = items.QualityDim
				}

				if items.CompareType != nil {
					itemsMap["compare_type"] = items.CompareType
				}

				if items.CitationCount != nil {
					itemsMap["citation_count"] = items.CitationCount
				}

				if items.UserId != nil {
					itemsMap["user_id"] = items.UserId
				}

				if items.UserName != nil {
					itemsMap["user_name"] = items.UserName
				}

				if items.UpdateTime != nil {
					itemsMap["update_time"] = items.UpdateTime
				}

				if items.WhereFlag != nil {
					itemsMap["where_flag"] = items.WhereFlag
				}

				if items.MultiSourceFlag != nil {
					itemsMap["multi_source_flag"] = items.MultiSourceFlag
				}

				if items.SqlExpression != nil {
					itemsMap["sql_expression"] = items.SqlExpression
				}

				if items.SubQualityDim != nil {
					itemsMap["sub_quality_dim"] = items.SubQualityDim
				}

				resolvedSqlExpressionMap := map[string]interface{}{}

				if items.ResolvedSqlExpression != nil {
					tableExpressionsList := make([]map[string]interface{}, 0, len(items.ResolvedSqlExpression.TableExpressions))
					if items.ResolvedSqlExpression.TableExpressions != nil {
						for _, tableExpressions := range items.ResolvedSqlExpression.TableExpressions {
							tableExpressionsMap := map[string]interface{}{}

							if tableExpressions.TableExpression != nil {
								tableExpressionsMap["table_expression"] = tableExpressions.TableExpression
							}

							if tableExpressions.ColumnExpression != nil {
								tableExpressionsMap["column_expression"] = tableExpressions.ColumnExpression
							}

							tableExpressionsList = append(tableExpressionsList, tableExpressionsMap)
						}

						resolvedSqlExpressionMap["table_expressions"] = tableExpressionsList
					}
					if items.ResolvedSqlExpression.ParamExpressions != nil {
						resolvedSqlExpressionMap["param_expressions"] = items.ResolvedSqlExpression.ParamExpressions
					}

					if items.ResolvedSqlExpression.SystemTemplateExpressions != nil {
						resolvedSqlExpressionMap["system_template_expressions"] = items.ResolvedSqlExpression.SystemTemplateExpressions
					}

					itemsMap["resolved_sql_expression"] = []interface{}{resolvedSqlExpressionMap}
				}

				if items.DatasourceTypes != nil {
					itemsMap["datasource_types"] = items.DatasourceTypes
				}

				if items.UserIdStr != nil {
					itemsMap["user_id_str"] = items.UserIdStr
				}

				itemsList = append(itemsList, itemsMap)
			}

			dataMap["items"] = itemsList
		}
		_ = d.Set("data", []interface{}{dataMap})
	}

	d.SetId(helper.DataResourceIdsHash(ids))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
