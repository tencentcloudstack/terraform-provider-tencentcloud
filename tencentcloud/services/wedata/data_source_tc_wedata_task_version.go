// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataTaskVersion() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataTaskVersionRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"task_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Task ID.",
			},

			"version_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Submit version ID. If not specified, the latest submit version will be used by default.",
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Version detail.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"create_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Creation time.",
						},
						"version_num": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Version number.",
						},
						"create_user_uin": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specifies the version creator.",
						},
						"version_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Specifies the version Id to save.",
						},
						"version_remark": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Version description.",
						},
						"approve_status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Approval status (only for submit version).",
						},
						"approve_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Production status  (only for submit version).",
						},
						"task": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Describes the task detail of the version.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"task_base_attribute": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Describes the basic attributes of the task.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"task_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Task ID.",
												},
												"task_type_id": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: "Specifies the task type ID.\n\n* 21:JDBC SQL\n* 23:TDSQL-PostgreSQL\n* 26:OfflineSynchronization\n* 30:Python\n* 31:PySpark\n* 33:Impala\n* 34:Hive SQL\n* 35:Shell\n* 36:Spark SQL\n* 38:Shell Form Mode\n* 39:Spark\n* 40:TCHouse-P\n* 41:Kettle\n* 42:Tchouse-X\n* 43:TCHouse-X SQL\n* 46:DLC Spark\n* 47:TiOne\n* 48:Trino\n* 50:DLC PySpark\n* 92:MapReduce\n* 130:Branch Node\n* 131:Merged Node\n* 132:Notebook\n* 133:SSH\n* 134:StarRocks\n* 137:For-each\n* 138:Setats SQL.",
												},
												"workflow_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Workflow ID.",
												},
												"task_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task name.",
												},
												"task_latest_version_no": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last save version number.",
												},
												"task_latest_submit_version_no": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last submit version number.",
												},
												"workflow_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Workflow name.",
												},
												"status": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task Status:\n\n* N: New\n* Y: Scheduling\n* F: Offline\n* O: Paused\n* T: Offlining (in the process of being taken offline)\n* INVALID: Invalid.",
												},
												"submit": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: "Latest submission status of the task. Specifies whether it has been submitted: true/false.",
												},
												"create_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task creation time. example: 2022-02-12 11:13:41.",
												},
												"last_update_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last update time. example: 2025-08-13 16:34:06.",
												},
												"last_update_user_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last Updated By (Name).",
												},
												"last_ops_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last operation time.",
												},
												"last_ops_user_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last operator name.",
												},
												"owner_uin": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task owner ID.",
												},
												"task_description": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task description.",
												},
												"update_user_uin": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last Updated User ID.",
												},
												"create_user_uin": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Created By User ID.",
												},
											},
										},
									},
									"task_configuration": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Task configurations.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"code_content": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Base64 encoding of the code content.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"task_ext_configuration_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Extended attribute configuration list of the task.\nNote: This field may return null, indicating that no valid values can be obtained.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_value": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter value.",
															},
														},
													},
												},
												"data_cluster": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Cluster ID\n\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"broker_ip": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Specifies the specified running node.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"yarn_queue": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Resource pool queue name. need to pass through DescribeProjectClusterQueues to obtain.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"source_service_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Source data source ID, separated by;, obtained through DescribeDataSourceWithoutInfo.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"source_service_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Data source type. use semicolon to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"source_service_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Data source name. use semicolons to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"target_service_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "TargetTarget data source ID, separated by semicolons. need to pass through DescribeDataSourceWithoutInfo to obtain.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"target_service_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Target data source type. uses ; for separation. needs to pass through DescribeDataSourceWithoutInfo for retrieval.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"target_service_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Target data source name. use semicolon to separate. need to pass through DescribeDataSourceWithoutInfo to obtain.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"resource_group": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Resource group ID: need to pass through DescribeNormalSchedulerExecutorGroups to obtain ExecutorGroupId.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"resource_group_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Resource group name: need to pass through DescribeNormalSchedulerExecutorGroups to obtain ExecutorGroupName.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"task_scheduling_parameter_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Specifies the scheduling parameter.\nNote: This field may return null, indicating that no valid values can be obtained.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_value": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter value.",
															},
														},
													},
												},
												"bundle_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "ID used by the Bundle.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
												"bundle_info": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Bundle info.\nNote: This field may return null, indicating that no valid values can be obtained.",
												},
											},
										},
									},
									"task_scheduler_configuration": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Specifies task scheduling configuration.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"cycle_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Period type. Supported types:\n\nONEOFF_CYCLE: specifies a one-time cycle.\nYEAR_CYCLE: specifies the year cycle.\nMONTH_CYCLE: specifies the monthly cycle.\nWEEK_CYCLE: specifies the week cycle.\nDAY_CYCLE: specifies the day cycle.\nHOUR_CYCLE: specifies the hour cycle.\nMINUTE_CYCLE: specifies the minute cycle.\nCRONTAB_CYCLE: specifies the crontab expression type.",
												},
												"schedule_time_zone": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Time zone.",
												},
												"crontab_expression": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "0 2 3 1,L,2 * ?\t",
												},
												"start_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Effective date.",
												},
												"end_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "End date",
												},
												"execution_start_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Execution time. the left-closed interval.",
												},
												"execution_end_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Execution time. right closed interval.",
												},
												"schedule_run_type": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Scheduling type: 0 for normal scheduling, 1 for dry-run scheduling.",
												},
												"calendar_open": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Whether calendar scheduling is enabled. Valid values: 1 (enabled), 0 (disabled).",
												},
												"calendar_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Calendar id.",
												},
												"calendar_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Calendar name, which needs to be obtained from DescribeScheduleCalendarPageList API.",
												},
												"self_depend": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Self-Dependent. Valid values: parallel, serial, orderly. Default value: serial. ",
												},
												"upstream_dependency_config_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Specifies the upstream dependency array.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"task_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Task ID",
															},
															"main_cyclic_config": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Main dependency configuration. Valid values:\n\n* CRONTAB\n* DAY\n* HOUR\n* LIST_DAY\n* LIST_HOUR\n* LIST_MINUTE\n* MINUTE\n* MONTH\n* RANGE_DAY\n* RANGE_HOUR\n* RANGE_MINUTE\n* WEEK\n* YEAR",
															},
															"subordinate_cyclic_config": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Configures secondary dependencies.  Valid values:\n* ALL_DAY_OF_YEAR\n* ALL_MONTH_OF_YEAR\n* CURRENT\n* CURRENT_DAY\n* CURRENT_HOUR\n* CURRENT_MINUTE\n* CURRENT_MONTH\n* CURRENT_WEEK\n* CURRENT_YEAR\n* PREVIOUS_BEGIN_OF_MONTH\n* PREVIOUS_DAY\n* PREVIOUS_DAY_LATER_OFFSET_HOUR\n* PREVIOUS_DAY_LATER_OFFSET_MINUTE\n* PREVIOUS_END_OF_MONTH\n* PREVIOUS_FRIDAY\n* PREVIOUS_HOUR\n* PREVIOUS_HOUR_CYCLE\n* PREVIOUS_HOUR_LATER_OFFSET_MINUTE\n* PREVIOUS_MINUTE_CYCLE\n* PREVIOUS_MONTH\n* PREVIOUS_WEEK\n* PREVIOUS_WEEKEND\n* RECENT_DATE",
															},
															"offset": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Offset in Range/List Mode",
															},
															"dependency_strategy": {
																Type:        schema.TypeList,
																Optional:    true,
																MaxItems:    1,
																Description: "Dependency Execution Policy",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"polling_null_strategy": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: "Wait upstream task instance policy: EXECUTING (execute); WAITING (wait).",
																		},
																		"task_dependency_executing_strategies": {
																			Type:        schema.TypeSet,
																			Optional:    true,
																			Description: "This field is required only when PollingNullStrategy is set to EXECUTING.\nType: List\n\nNOT_EXIST (default) - In cases where minute depends on minute / hour depends on hour, the parent instance does not fall within the scheduling time range of the downstream instance.\n\nPARENT_EXPIRED - The parent instance failed.\n\nPARENT_TIMEOUT - The parent instance timed out.\n\nIf any of the above conditions are met, the dependency check for that parent task instance is considered satisfied. In all other cases, the system must wait for the parent instance.",
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"task_dependency_executing_timeout_value": {
																			Type:        schema.TypeInt,
																			Optional:    true,
																			Description: "This field is required only when TaskDependencyExecutingStrategies includes PARENT_TIMEOUT.\nSpecifies the timeout duration (in minutes) for the downstream task's dependency on the parent instance execution.",
																		},
																	},
																},
															},
														},
													},
												},
												"down_stream_dependency_config_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "SpecSpecifies the downstream dependency array.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"task_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Task ID",
															},
															"main_cyclic_config": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Main dependency configuration. Valid values:\n\n* CRONTAB\n* DAY\n* HOUR\n* LIST_DAY\n* LIST_HOUR\n* LIST_MINUTE\n* MINUTE\n* MONTH\n* RANGE_DAY\n* RANGE_HOUR\n* RANGE_MINUTE\n* WEEK\n* YEAR",
															},
															"subordinate_cyclic_config": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Configures secondary dependencies.  Valid values:\n* ALL_DAY_OF_YEAR\n* ALL_MONTH_OF_YEAR\n* CURRENT\n* CURRENT_DAY\n* CURRENT_HOUR\n* CURRENT_MINUTE\n* CURRENT_MONTH\n* CURRENT_WEEK\n* CURRENT_YEAR\n* PREVIOUS_BEGIN_OF_MONTH\n* PREVIOUS_DAY\n* PREVIOUS_DAY_LATER_OFFSET_HOUR\n* PREVIOUS_DAY_LATER_OFFSET_MINUTE\n* PREVIOUS_END_OF_MONTH\n* PREVIOUS_FRIDAY\n* PREVIOUS_HOUR\n* PREVIOUS_HOUR_CYCLE\n* PREVIOUS_HOUR_LATER_OFFSET_MINUTE\n* PREVIOUS_MINUTE_CYCLE\n* PREVIOUS_MONTH\n* PREVIOUS_WEEK\n* PREVIOUS_WEEKEND\n* RECENT_DATE",
															},
															"offset": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Offset in Range/List Mode",
															},
															"dependency_strategy": {
																Type:        schema.TypeList,
																Optional:    true,
																MaxItems:    1,
																Description: "Dependency Execution Policy",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"polling_null_strategy": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: "Wait upstream task instance policy: EXECUTING (execute); WAITING (wait).",
																		},
																		"task_dependency_executing_strategies": {
																			Type:        schema.TypeSet,
																			Optional:    true,
																			Description: "This field is required only when PollingNullStrategy is set to EXECUTING.\nType: List\n\nNOT_EXIST (default) - In cases where minute depends on minute / hour depends on hour, the parent instance does not fall within the scheduling time range of the downstream instance.\n\nPARENT_EXPIRED - The parent instance failed.\n\nPARENT_TIMEOUT - The parent instance timed out.\n\nIf any of the above conditions are met, the dependency check for that parent task instance is considered satisfied. In all other cases, the system must wait for the parent instance.",
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"task_dependency_executing_timeout_value": {
																			Type:        schema.TypeInt,
																			Optional:    true,
																			Description: "This field is required only when TaskDependencyExecutingStrategies includes PARENT_TIMEOUT.\nSpecifies the timeout duration (in minutes) for the downstream task's dependency on the parent instance execution.",
																		},
																	},
																},
															},
														},
													},
												},
												"event_listener_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Array of Events",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"event_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Event name",
															},
															"event_sub_type": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Event cycle. valid values: SECOND, MIN, HOUR, DAY.",
															},
															"event_broadcast_type": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Event BROADCAST type: SINGLE, BROADCAST.",
															},
															"properties_list": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: "Extension Information\n",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"param_key": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "Parameter name.",
																		},
																		"param_value": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: "Parameter value.",
																		},
																	},
																},
															},
														},
													},
												},
												"run_priority": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Task scheduling priority. valid values: 4 (high), 5 (medium), 6 (low). default: 6.",
												},
												"retry_wait": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Retry policy. retry wait time in minutes. default: 5.",
												},
												"max_retry_attempts": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Specifies the maximum attempts of the retry policy. default: 4.",
												},
												"execution_ttl": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Timeout Handling Policy: Execution Timeout (in minutes), default: -1",
												},
												"wait_execution_total_ttl": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Timeout Handling Policy: Wait Duration Timeout  (in minutes), default: -1",
												},
												"allow_redo_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Rerun & Refill Configuration: Default: ALL;\n\n* ALL: Rerun or refill is allowed regardless of whether the task succeeds or fails.\n\n* FAILURE: Rerun or refill is allowed only if the task fails; not allowed if the task succeeds.\n\n* NONE: Rerun or refill is not allowed regardless of success or failure.",
												},
												"param_task_out_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Output parameter list.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_value": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter definition.",
															},
														},
													},
												},
												"param_task_in_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Input parameter list.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_desc": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter Description: The format is ProjectIdentifier.TaskName.ParameterName\nExample: project_wedata_1.sh_250820_104107.pp_out",
															},
															"from_task_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parent Task ID",
															},
															"from_param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parent task parameter key.",
															},
														},
													},
												},
												"task_output_registry_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Output registration.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"datasource_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Data source ID.",
															},
															"database_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Database name.",
															},
															"table_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Table name",
															},
															"partition_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Partition name",
															},
															"data_flow_type": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Input output table data type.\nInput stream:\n UPSTREAM,\nOutput stream:\n  DOWNSTREAM;.",
															},
															"table_physical_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Physical unique ID..",
															},
															"db_guid": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Database unique id..",
															},
															"table_guid": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Unique id of the table.",
															},
														},
													},
												},
												"init_strategy": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "**Instance generation policy**.\nT_PLUS_0: specifies t+0 generation. default policy.\nT_PLUS_1: specifies t+1 generation.",
												},
											},
										},
									},
								},
							},
						},
						"approve_user_uin": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Approver Id.",
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataTaskVersionRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_task_version.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		projectId string
		taskId    string
	)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		projectId = v.(string)
		paramMap["ProjectId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("task_id"); ok {
		taskId = v.(string)
		paramMap["TaskId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("version_id"); ok {
		paramMap["VersionId"] = helper.String(v.(string))
	}

	var respData *wedatav20250806.GetTaskVersionResponseParams
	err := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataTaskVersionByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if err != nil {
		return err
	}

	dataMap := map[string]interface{}{}

	if respData.Data != nil {
		if respData.Data.CreateTime != nil {
			dataMap["create_time"] = respData.Data.CreateTime
		}

		if respData.Data.VersionNum != nil {
			dataMap["version_num"] = respData.Data.VersionNum
		}

		if respData.Data.CreateUserUin != nil {
			dataMap["create_user_uin"] = respData.Data.CreateUserUin
		}

		if respData.Data.VersionId != nil {
			dataMap["version_id"] = respData.Data.VersionId
		}

		if respData.Data.VersionRemark != nil {
			dataMap["version_remark"] = respData.Data.VersionRemark
		}

		if respData.Data.ApproveStatus != nil {
			dataMap["approve_status"] = respData.Data.ApproveStatus
		}

		if respData.Data.ApproveTime != nil {
			dataMap["approve_time"] = respData.Data.ApproveTime
		}

		taskMap := map[string]interface{}{}

		if respData.Data.Task != nil {
			taskBaseAttributeMap := map[string]interface{}{}

			if respData.Data.Task.TaskBaseAttribute != nil {
				if respData.Data.Task.TaskBaseAttribute.TaskId != nil {
					taskBaseAttributeMap["task_id"] = respData.Data.Task.TaskBaseAttribute.TaskId
				}

				if respData.Data.Task.TaskBaseAttribute.TaskTypeId != nil {
					taskBaseAttributeMap["task_type_id"] = respData.Data.Task.TaskBaseAttribute.TaskTypeId
				}

				if respData.Data.Task.TaskBaseAttribute.WorkflowId != nil {
					taskBaseAttributeMap["workflow_id"] = respData.Data.Task.TaskBaseAttribute.WorkflowId
				}

				if respData.Data.Task.TaskBaseAttribute.TaskName != nil {
					taskBaseAttributeMap["task_name"] = respData.Data.Task.TaskBaseAttribute.TaskName
				}

				if respData.Data.Task.TaskBaseAttribute.TaskLatestVersionNo != nil {
					taskBaseAttributeMap["task_latest_version_no"] = respData.Data.Task.TaskBaseAttribute.TaskLatestVersionNo
				}

				if respData.Data.Task.TaskBaseAttribute.TaskLatestSubmitVersionNo != nil {
					taskBaseAttributeMap["task_latest_submit_version_no"] = respData.Data.Task.TaskBaseAttribute.TaskLatestSubmitVersionNo
				}

				if respData.Data.Task.TaskBaseAttribute.WorkflowName != nil {
					taskBaseAttributeMap["workflow_name"] = respData.Data.Task.TaskBaseAttribute.WorkflowName
				}

				if respData.Data.Task.TaskBaseAttribute.Status != nil {
					taskBaseAttributeMap["status"] = respData.Data.Task.TaskBaseAttribute.Status
				}

				if respData.Data.Task.TaskBaseAttribute.Submit != nil {
					taskBaseAttributeMap["submit"] = respData.Data.Task.TaskBaseAttribute.Submit
				}

				if respData.Data.Task.TaskBaseAttribute.CreateTime != nil {
					taskBaseAttributeMap["create_time"] = respData.Data.Task.TaskBaseAttribute.CreateTime
				}

				if respData.Data.Task.TaskBaseAttribute.LastUpdateTime != nil {
					taskBaseAttributeMap["last_update_time"] = respData.Data.Task.TaskBaseAttribute.LastUpdateTime
				}

				if respData.Data.Task.TaskBaseAttribute.LastUpdateUserName != nil {
					taskBaseAttributeMap["last_update_user_name"] = respData.Data.Task.TaskBaseAttribute.LastUpdateUserName
				}

				if respData.Data.Task.TaskBaseAttribute.LastOpsTime != nil {
					taskBaseAttributeMap["last_ops_time"] = respData.Data.Task.TaskBaseAttribute.LastOpsTime
				}

				if respData.Data.Task.TaskBaseAttribute.LastOpsUserName != nil {
					taskBaseAttributeMap["last_ops_user_name"] = respData.Data.Task.TaskBaseAttribute.LastOpsUserName
				}

				if respData.Data.Task.TaskBaseAttribute.OwnerUin != nil {
					taskBaseAttributeMap["owner_uin"] = respData.Data.Task.TaskBaseAttribute.OwnerUin
				}

				if respData.Data.Task.TaskBaseAttribute.TaskDescription != nil {
					taskBaseAttributeMap["task_description"] = respData.Data.Task.TaskBaseAttribute.TaskDescription
				}

				if respData.Data.Task.TaskBaseAttribute.UpdateUserUin != nil {
					taskBaseAttributeMap["update_user_uin"] = respData.Data.Task.TaskBaseAttribute.UpdateUserUin
				}

				if respData.Data.Task.TaskBaseAttribute.CreateUserUin != nil {
					taskBaseAttributeMap["create_user_uin"] = respData.Data.Task.TaskBaseAttribute.CreateUserUin
				}

				taskMap["task_base_attribute"] = []interface{}{taskBaseAttributeMap}
			}

			taskConfigurationMap := map[string]interface{}{}

			if respData.Data.Task.TaskConfiguration != nil {
				if respData.Data.Task.TaskConfiguration.CodeContent != nil {
					taskConfigurationMap["code_content"] = respData.Data.Task.TaskConfiguration.CodeContent
				}

				taskExtConfigurationListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskConfiguration.TaskExtConfigurationList))
				if respData.Data.Task.TaskConfiguration.TaskExtConfigurationList != nil {
					for _, taskExtConfigurationList := range respData.Data.Task.TaskConfiguration.TaskExtConfigurationList {
						taskExtConfigurationListMap := map[string]interface{}{}

						if taskExtConfigurationList.ParamKey != nil {
							taskExtConfigurationListMap["param_key"] = taskExtConfigurationList.ParamKey
						}

						if taskExtConfigurationList.ParamValue != nil {
							taskExtConfigurationListMap["param_value"] = taskExtConfigurationList.ParamValue
						}

						taskExtConfigurationListList = append(taskExtConfigurationListList, taskExtConfigurationListMap)
					}

					taskConfigurationMap["task_ext_configuration_list"] = taskExtConfigurationListList
				}
				if respData.Data.Task.TaskConfiguration.DataCluster != nil {
					taskConfigurationMap["data_cluster"] = respData.Data.Task.TaskConfiguration.DataCluster
				}

				if respData.Data.Task.TaskConfiguration.BrokerIp != nil {
					taskConfigurationMap["broker_ip"] = respData.Data.Task.TaskConfiguration.BrokerIp
				}

				if respData.Data.Task.TaskConfiguration.YarnQueue != nil {
					taskConfigurationMap["yarn_queue"] = respData.Data.Task.TaskConfiguration.YarnQueue
				}

				if respData.Data.Task.TaskConfiguration.SourceServiceId != nil {
					taskConfigurationMap["source_service_id"] = respData.Data.Task.TaskConfiguration.SourceServiceId
				}

				if respData.Data.Task.TaskConfiguration.SourceServiceType != nil {
					taskConfigurationMap["source_service_type"] = respData.Data.Task.TaskConfiguration.SourceServiceType
				}

				if respData.Data.Task.TaskConfiguration.SourceServiceName != nil {
					taskConfigurationMap["source_service_name"] = respData.Data.Task.TaskConfiguration.SourceServiceName
				}

				if respData.Data.Task.TaskConfiguration.TargetServiceId != nil {
					taskConfigurationMap["target_service_id"] = respData.Data.Task.TaskConfiguration.TargetServiceId
				}

				if respData.Data.Task.TaskConfiguration.TargetServiceType != nil {
					taskConfigurationMap["target_service_type"] = respData.Data.Task.TaskConfiguration.TargetServiceType
				}

				if respData.Data.Task.TaskConfiguration.TargetServiceName != nil {
					taskConfigurationMap["target_service_name"] = respData.Data.Task.TaskConfiguration.TargetServiceName
				}

				if respData.Data.Task.TaskConfiguration.ResourceGroup != nil {
					taskConfigurationMap["resource_group"] = respData.Data.Task.TaskConfiguration.ResourceGroup
				}

				if respData.Data.Task.TaskConfiguration.ResourceGroupName != nil {
					taskConfigurationMap["resource_group_name"] = respData.Data.Task.TaskConfiguration.ResourceGroupName
				}

				taskSchedulingParameterListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskConfiguration.TaskSchedulingParameterList))
				if respData.Data.Task.TaskConfiguration.TaskSchedulingParameterList != nil {
					for _, taskSchedulingParameterList := range respData.Data.Task.TaskConfiguration.TaskSchedulingParameterList {
						taskSchedulingParameterListMap := map[string]interface{}{}

						if taskSchedulingParameterList.ParamKey != nil {
							taskSchedulingParameterListMap["param_key"] = taskSchedulingParameterList.ParamKey
						}

						if taskSchedulingParameterList.ParamValue != nil {
							taskSchedulingParameterListMap["param_value"] = taskSchedulingParameterList.ParamValue
						}

						taskSchedulingParameterListList = append(taskSchedulingParameterListList, taskSchedulingParameterListMap)
					}

					taskConfigurationMap["task_scheduling_parameter_list"] = taskSchedulingParameterListList
				}
				if respData.Data.Task.TaskConfiguration.BundleId != nil {
					taskConfigurationMap["bundle_id"] = respData.Data.Task.TaskConfiguration.BundleId
				}

				if respData.Data.Task.TaskConfiguration.BundleInfo != nil {
					taskConfigurationMap["bundle_info"] = respData.Data.Task.TaskConfiguration.BundleInfo
				}

				taskMap["task_configuration"] = []interface{}{taskConfigurationMap}
			}

			taskSchedulerConfigurationMap := map[string]interface{}{}

			if respData.Data.Task.TaskSchedulerConfiguration != nil {
				if respData.Data.Task.TaskSchedulerConfiguration.CycleType != nil {
					taskSchedulerConfigurationMap["cycle_type"] = respData.Data.Task.TaskSchedulerConfiguration.CycleType
				}

				if respData.Data.Task.TaskSchedulerConfiguration.ScheduleTimeZone != nil {
					taskSchedulerConfigurationMap["schedule_time_zone"] = respData.Data.Task.TaskSchedulerConfiguration.ScheduleTimeZone
				}

				if respData.Data.Task.TaskSchedulerConfiguration.CrontabExpression != nil {
					taskSchedulerConfigurationMap["crontab_expression"] = respData.Data.Task.TaskSchedulerConfiguration.CrontabExpression
				}

				if respData.Data.Task.TaskSchedulerConfiguration.StartTime != nil {
					taskSchedulerConfigurationMap["start_time"] = respData.Data.Task.TaskSchedulerConfiguration.StartTime
				}

				if respData.Data.Task.TaskSchedulerConfiguration.EndTime != nil {
					taskSchedulerConfigurationMap["end_time"] = respData.Data.Task.TaskSchedulerConfiguration.EndTime
				}

				if respData.Data.Task.TaskSchedulerConfiguration.ExecutionStartTime != nil {
					taskSchedulerConfigurationMap["execution_start_time"] = respData.Data.Task.TaskSchedulerConfiguration.ExecutionStartTime
				}

				if respData.Data.Task.TaskSchedulerConfiguration.ExecutionEndTime != nil {
					taskSchedulerConfigurationMap["execution_end_time"] = respData.Data.Task.TaskSchedulerConfiguration.ExecutionEndTime
				}

				if respData.Data.Task.TaskSchedulerConfiguration.ScheduleRunType != nil {
					taskSchedulerConfigurationMap["schedule_run_type"] = respData.Data.Task.TaskSchedulerConfiguration.ScheduleRunType
				}

				if respData.Data.Task.TaskSchedulerConfiguration.CalendarOpen != nil {
					taskSchedulerConfigurationMap["calendar_open"] = respData.Data.Task.TaskSchedulerConfiguration.CalendarOpen
				}

				if respData.Data.Task.TaskSchedulerConfiguration.CalendarId != nil {
					taskSchedulerConfigurationMap["calendar_id"] = respData.Data.Task.TaskSchedulerConfiguration.CalendarId
				}

				if respData.Data.Task.TaskSchedulerConfiguration.CalendarName != nil {
					taskSchedulerConfigurationMap["calendar_name"] = respData.Data.Task.TaskSchedulerConfiguration.CalendarName
				}

				if respData.Data.Task.TaskSchedulerConfiguration.SelfDepend != nil {
					taskSchedulerConfigurationMap["self_depend"] = respData.Data.Task.TaskSchedulerConfiguration.SelfDepend
				}

				upstreamDependencyConfigListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskSchedulerConfiguration.UpstreamDependencyConfigList))
				if respData.Data.Task.TaskSchedulerConfiguration.UpstreamDependencyConfigList != nil {
					for _, upstreamDependencyConfigList := range respData.Data.Task.TaskSchedulerConfiguration.UpstreamDependencyConfigList {
						upstreamDependencyConfigListMap := map[string]interface{}{}

						if upstreamDependencyConfigList.TaskId != nil {
							upstreamDependencyConfigListMap["task_id"] = upstreamDependencyConfigList.TaskId
						}

						if upstreamDependencyConfigList.MainCyclicConfig != nil {
							upstreamDependencyConfigListMap["main_cyclic_config"] = upstreamDependencyConfigList.MainCyclicConfig
						}

						if upstreamDependencyConfigList.SubordinateCyclicConfig != nil {
							upstreamDependencyConfigListMap["subordinate_cyclic_config"] = upstreamDependencyConfigList.SubordinateCyclicConfig
						}

						if upstreamDependencyConfigList.Offset != nil {
							upstreamDependencyConfigListMap["offset"] = upstreamDependencyConfigList.Offset
						}

						dependencyStrategyMap := map[string]interface{}{}

						if upstreamDependencyConfigList.DependencyStrategy != nil {
							if upstreamDependencyConfigList.DependencyStrategy.PollingNullStrategy != nil {
								dependencyStrategyMap["polling_null_strategy"] = upstreamDependencyConfigList.DependencyStrategy.PollingNullStrategy
							}

							if upstreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingStrategies != nil {
								dependencyStrategyMap["task_dependency_executing_strategies"] = upstreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingStrategies
							}

							if upstreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingTimeoutValue != nil {
								dependencyStrategyMap["task_dependency_executing_timeout_value"] = upstreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingTimeoutValue
							}

							upstreamDependencyConfigListMap["dependency_strategy"] = []interface{}{dependencyStrategyMap}
						}

						upstreamDependencyConfigListList = append(upstreamDependencyConfigListList, upstreamDependencyConfigListMap)
					}

					taskSchedulerConfigurationMap["upstream_dependency_config_list"] = upstreamDependencyConfigListList
				}
				downStreamDependencyConfigListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskSchedulerConfiguration.DownStreamDependencyConfigList))
				if respData.Data.Task.TaskSchedulerConfiguration.DownStreamDependencyConfigList != nil {
					for _, downStreamDependencyConfigList := range respData.Data.Task.TaskSchedulerConfiguration.DownStreamDependencyConfigList {
						downStreamDependencyConfigListMap := map[string]interface{}{}

						if downStreamDependencyConfigList.TaskId != nil {
							downStreamDependencyConfigListMap["task_id"] = downStreamDependencyConfigList.TaskId
						}

						if downStreamDependencyConfigList.MainCyclicConfig != nil {
							downStreamDependencyConfigListMap["main_cyclic_config"] = downStreamDependencyConfigList.MainCyclicConfig
						}

						if downStreamDependencyConfigList.SubordinateCyclicConfig != nil {
							downStreamDependencyConfigListMap["subordinate_cyclic_config"] = downStreamDependencyConfigList.SubordinateCyclicConfig
						}

						if downStreamDependencyConfigList.Offset != nil {
							downStreamDependencyConfigListMap["offset"] = downStreamDependencyConfigList.Offset
						}

						dependencyStrategyMap := map[string]interface{}{}

						if downStreamDependencyConfigList.DependencyStrategy != nil {
							if downStreamDependencyConfigList.DependencyStrategy.PollingNullStrategy != nil {
								dependencyStrategyMap["polling_null_strategy"] = downStreamDependencyConfigList.DependencyStrategy.PollingNullStrategy
							}

							if downStreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingStrategies != nil {
								dependencyStrategyMap["task_dependency_executing_strategies"] = downStreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingStrategies
							}

							if downStreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingTimeoutValue != nil {
								dependencyStrategyMap["task_dependency_executing_timeout_value"] = downStreamDependencyConfigList.DependencyStrategy.TaskDependencyExecutingTimeoutValue
							}

							downStreamDependencyConfigListMap["dependency_strategy"] = []interface{}{dependencyStrategyMap}
						}

						downStreamDependencyConfigListList = append(downStreamDependencyConfigListList, downStreamDependencyConfigListMap)
					}

					taskSchedulerConfigurationMap["down_stream_dependency_config_list"] = downStreamDependencyConfigListList
				}
				eventListenerListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskSchedulerConfiguration.EventListenerList))
				if respData.Data.Task.TaskSchedulerConfiguration.EventListenerList != nil {
					for _, eventListenerList := range respData.Data.Task.TaskSchedulerConfiguration.EventListenerList {
						eventListenerListMap := map[string]interface{}{}

						if eventListenerList.EventName != nil {
							eventListenerListMap["event_name"] = eventListenerList.EventName
						}

						if eventListenerList.EventSubType != nil {
							eventListenerListMap["event_sub_type"] = eventListenerList.EventSubType
						}

						if eventListenerList.EventBroadcastType != nil {
							eventListenerListMap["event_broadcast_type"] = eventListenerList.EventBroadcastType
						}

						propertiesListList := make([]map[string]interface{}, 0, len(eventListenerList.PropertiesList))
						if eventListenerList.PropertiesList != nil {
							for _, propertiesList := range eventListenerList.PropertiesList {
								propertiesListMap := map[string]interface{}{}

								if propertiesList.ParamKey != nil {
									propertiesListMap["param_key"] = propertiesList.ParamKey
								}

								if propertiesList.ParamValue != nil {
									propertiesListMap["param_value"] = propertiesList.ParamValue
								}

								propertiesListList = append(propertiesListList, propertiesListMap)
							}

							eventListenerListMap["properties_list"] = propertiesListList
						}
						eventListenerListList = append(eventListenerListList, eventListenerListMap)
					}

					taskSchedulerConfigurationMap["event_listener_list"] = eventListenerListList
				}
				if respData.Data.Task.TaskSchedulerConfiguration.RunPriority != nil {
					taskSchedulerConfigurationMap["run_priority"] = respData.Data.Task.TaskSchedulerConfiguration.RunPriority
				}

				if respData.Data.Task.TaskSchedulerConfiguration.RetryWait != nil {
					taskSchedulerConfigurationMap["retry_wait"] = respData.Data.Task.TaskSchedulerConfiguration.RetryWait
				}

				if respData.Data.Task.TaskSchedulerConfiguration.MaxRetryAttempts != nil {
					taskSchedulerConfigurationMap["max_retry_attempts"] = respData.Data.Task.TaskSchedulerConfiguration.MaxRetryAttempts
				}

				if respData.Data.Task.TaskSchedulerConfiguration.ExecutionTTL != nil {
					taskSchedulerConfigurationMap["execution_ttl"] = respData.Data.Task.TaskSchedulerConfiguration.ExecutionTTL
				}

				if respData.Data.Task.TaskSchedulerConfiguration.WaitExecutionTotalTTL != nil {
					taskSchedulerConfigurationMap["wait_execution_total_ttl"] = respData.Data.Task.TaskSchedulerConfiguration.WaitExecutionTotalTTL
				}

				if respData.Data.Task.TaskSchedulerConfiguration.AllowRedoType != nil {
					taskSchedulerConfigurationMap["allow_redo_type"] = respData.Data.Task.TaskSchedulerConfiguration.AllowRedoType
				}

				paramTaskOutListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskSchedulerConfiguration.ParamTaskOutList))
				if respData.Data.Task.TaskSchedulerConfiguration.ParamTaskOutList != nil {
					for _, paramTaskOutList := range respData.Data.Task.TaskSchedulerConfiguration.ParamTaskOutList {
						paramTaskOutListMap := map[string]interface{}{}

						if paramTaskOutList.ParamKey != nil {
							paramTaskOutListMap["param_key"] = paramTaskOutList.ParamKey
						}

						if paramTaskOutList.ParamValue != nil {
							paramTaskOutListMap["param_value"] = paramTaskOutList.ParamValue
						}

						paramTaskOutListList = append(paramTaskOutListList, paramTaskOutListMap)
					}

					taskSchedulerConfigurationMap["param_task_out_list"] = paramTaskOutListList
				}
				paramTaskInListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskSchedulerConfiguration.ParamTaskInList))
				if respData.Data.Task.TaskSchedulerConfiguration.ParamTaskInList != nil {
					for _, paramTaskInList := range respData.Data.Task.TaskSchedulerConfiguration.ParamTaskInList {
						paramTaskInListMap := map[string]interface{}{}

						if paramTaskInList.ParamKey != nil {
							paramTaskInListMap["param_key"] = paramTaskInList.ParamKey
						}

						if paramTaskInList.ParamDesc != nil {
							paramTaskInListMap["param_desc"] = paramTaskInList.ParamDesc
						}

						if paramTaskInList.FromTaskId != nil {
							paramTaskInListMap["from_task_id"] = paramTaskInList.FromTaskId
						}

						if paramTaskInList.FromParamKey != nil {
							paramTaskInListMap["from_param_key"] = paramTaskInList.FromParamKey
						}

						paramTaskInListList = append(paramTaskInListList, paramTaskInListMap)
					}

					taskSchedulerConfigurationMap["param_task_in_list"] = paramTaskInListList
				}
				taskOutputRegistryListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TaskSchedulerConfiguration.TaskOutputRegistryList))
				if respData.Data.Task.TaskSchedulerConfiguration.TaskOutputRegistryList != nil {
					for _, taskOutputRegistryList := range respData.Data.Task.TaskSchedulerConfiguration.TaskOutputRegistryList {
						taskOutputRegistryListMap := map[string]interface{}{}

						if taskOutputRegistryList.DatasourceId != nil {
							taskOutputRegistryListMap["datasource_id"] = taskOutputRegistryList.DatasourceId
						}

						if taskOutputRegistryList.DatabaseName != nil {
							taskOutputRegistryListMap["database_name"] = taskOutputRegistryList.DatabaseName
						}

						if taskOutputRegistryList.TableName != nil {
							taskOutputRegistryListMap["table_name"] = taskOutputRegistryList.TableName
						}

						if taskOutputRegistryList.PartitionName != nil {
							taskOutputRegistryListMap["partition_name"] = taskOutputRegistryList.PartitionName
						}

						if taskOutputRegistryList.DataFlowType != nil {
							taskOutputRegistryListMap["data_flow_type"] = taskOutputRegistryList.DataFlowType
						}

						if taskOutputRegistryList.TablePhysicalId != nil {
							taskOutputRegistryListMap["table_physical_id"] = taskOutputRegistryList.TablePhysicalId
						}

						if taskOutputRegistryList.DbGuid != nil {
							taskOutputRegistryListMap["db_guid"] = taskOutputRegistryList.DbGuid
						}

						if taskOutputRegistryList.TableGuid != nil {
							taskOutputRegistryListMap["table_guid"] = taskOutputRegistryList.TableGuid
						}

						taskOutputRegistryListList = append(taskOutputRegistryListList, taskOutputRegistryListMap)
					}

					taskSchedulerConfigurationMap["task_output_registry_list"] = taskOutputRegistryListList
				}
				if respData.Data.Task.TaskSchedulerConfiguration.InitStrategy != nil {
					taskSchedulerConfigurationMap["init_strategy"] = respData.Data.Task.TaskSchedulerConfiguration.InitStrategy
				}

				taskMap["task_scheduler_configuration"] = []interface{}{taskSchedulerConfigurationMap}
			}

			dataMap["task"] = []interface{}{taskMap}
		}

		if respData.Data.ApproveUserUin != nil {
			dataMap["approve_user_uin"] = respData.Data.ApproveUserUin
		}

		_ = d.Set("data", []interface{}{dataMap})
	}

	d.SetId(projectId + tccommon.FILED_SP + taskId)

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
