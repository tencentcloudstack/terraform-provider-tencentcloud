// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudWedataQualityRuleGroup() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudWedataQualityRuleGroupCreate,
		Read:   resourceTencentCloudWedataQualityRuleGroupRead,
		Update: resourceTencentCloudWedataQualityRuleGroupUpdate,
		Delete: resourceTencentCloudWedataQualityRuleGroupDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"rule_group_exec_strategy_bo_list": {
				Type:        schema.TypeList,
				Required:    true,
				Description: "Task parameters.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"monitor_type": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Monitor type `2`. Associated production scheduling, `3`. Offline periodic detection.",
						},
						"executor_group_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Execution resource group ID.",
						},
						"rule_group_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Monitor task name.",
						},
						"database_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Database name.",
						},
						"datasource_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Data source ID.",
						},
						"table_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Table name.",
						},
						"rule_group_id": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Monitor task ID, required when editing and updating monitor tasks.",
						},
						"exec_queue": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Compute queue, required when data source is HIVE, ICEBERG, DLC. When data source is DLC, this field should be filled with DLC data engine name.",
						},
						"executor_group_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Execution resource group name.",
						},
						"tasks": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Associated production scheduling task list, required when MonitorType=2.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"workflow_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Production scheduling task workflow ID.",
									},
									"task_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Production scheduling task ID.",
									},
									"task_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Production scheduling task name.",
									},
									"cycle_type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Production scheduling task cycle type.",
									},
									"task_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Production task type.",
									},
									"schedule_time_zone": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Time zone.",
									},
									"in_charge_id_list": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "Person in charge ID.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"in_charge_name_list": {
										Type:        schema.TypeSet,
										Optional:    true,
										Description: "Person in charge name.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"start_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Cycle start time, required when MonitorType=3.",
						},
						"end_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Cycle end time, required when MonitorType=3.",
						},
						"cycle_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Scheduling cycle type, required when MonitorType=3, specific values: `I`: Schedule by minute; `H`: Schedule by hour; `D`: Schedule by day; `W`: Schedule by week; `M`: Schedule by month.",
						},
						"delay_time": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Delayed scheduling time, required when MonitorType=3, mainly used for day/week/month tasks, measured in minutes. For example, if a day task needs to be delayed to 02:00, this field value is 120, indicating a delay of 2 hours (120 minutes). For hour/minute tasks, this field is meaningless, fill in fixed value 0, otherwise field validation will fail.",
						},
						"cycle_step": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Interval, required when MonitorType=3, indicates the interval time of periodic tasks; Week/Month/Day tasks can choose: `1`; Minute tasks can choose: `10`, `20`, `30`; Hour tasks can choose: `1`, `2`, `3`, `4`, `6`, `8`, `12`.",
						},
						"task_action": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Time specification, mainly used for week/month scheduling cycle tasks. For week scheduling cycle: means specifying which day of the week to run, multiple options separated by English commas, can fill 1,2...7, representing Sunday, Monday...Saturday respectively, for example fill \"1,2\", means execute on Sunday and Monday; For month scheduling cycle: means specifying which day of the month to run, multiple options separated by English commas, can fill 1,2,...,31, representing 1st, 2nd...31st respectively, for example fill \"1,2\", means execute on 1st and 2nd of each month.",
						},
						"exec_engine_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Running execution engine, if not passed, will request the default execution engine under this data source.",
						},
						"exec_plan": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Execution plan.",
						},
						"rule_id": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Rule ID.",
						},
						"rule_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Rule name.",
						},
						"trigger_types": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "Trigger type, mainly used for \"Associated production scheduling\" (MonitorType=2) monitoring tasks, optional values: `CYCLE`: Periodic scheduling; `MAKE_UP`: Backfill; `RERUN`: Rerun.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"dlc_group_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "When data source is DLC, corresponds to DLC resource group. According to the DLC engine name filled in ExecQueue, select the resource group under the corresponding engine.",
						},
						"schema_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Schema name.",
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Task description.",
						},
						"schedule_time_zone": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Time zone, default is UTC+8.",
						},
						"group_config": {
							Type:        schema.TypeList,
							Optional:    true,
							MaxItems:    1,
							Description: "Task monitoring parameters.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"analysis_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Analysis type, optional values: `INFERENCE`-inference table; `TIME_SERIES`-time series table; `SNAPSHOT`-snapshot table.",
									},
									"model_monitor_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Model detection type, required when analysis type is inference table (INFERENCE), optional values: `CLAASSIFICATION`-classification; `REGRESSION`-regression.",
									},
									"predict_column": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Prediction column.",
									},
									"predict_column_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Prediction column type.",
									},
									"label_column": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Label column.",
									},
									"label_column_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Label column type.",
									},
									"model_id_column": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Model ID column.",
									},
									"model_id_column_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Model ID column type.",
									},
									"timestamp_column": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Timestamp column.",
									},
									"timestamp_column_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Timestamp column type.",
									},
									"granularity": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Metric granularity.",
									},
									"granularity_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Metric granularity unit.",
									},
									"base_table": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Base table.",
									},
									"base_db": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Base database.",
									},
									"comparison_column": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Comparison column.",
									},
									"comparison_column_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Comparison column type.",
									},
									"protection_value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Protection group.",
									},
									"positive_value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Positive class value.",
									},
									"feature_column": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Feature column.",
									},
								},
							},
						},
						"engine_param": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Engine parameters.",
						},
						"catalog_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Data catalog name, defaults to DataLakeCatalog if not filled (this parameter is invalid when updating quality monitoring).",
						},
					},
				},
			},

			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"rule_group_id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Rule group ID.",
			},
		},
	}
}

func resourceTencentCloudWedataQualityRuleGroupCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule_group.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		projectId   string
		ruleGroupId uint64
	)
	var (
		request  = wedatav20250806.NewCreateQualityRuleGroupRequest()
		response = wedatav20250806.NewCreateQualityRuleGroupResponse()
	)

	if v, ok := d.GetOk("rule_group_exec_strategy_bo_list"); ok {
		for _, item := range v.([]interface{}) {
			ruleGroupExecStrategyBOListMap := item.(map[string]interface{})
			qualityRuleGroupExecStrategy := wedatav20250806.QualityRuleGroupExecStrategy{}
			if v, ok := ruleGroupExecStrategyBOListMap["monitor_type"].(int); ok {
				qualityRuleGroupExecStrategy.MonitorType = helper.IntUint64(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["executor_group_id"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.ExecutorGroupId = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["rule_group_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.RuleGroupName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["database_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.DatabaseName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["datasource_id"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.DatasourceId = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["table_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.TableName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["rule_group_id"].(int); ok {
				qualityRuleGroupExecStrategy.RuleGroupId = helper.IntUint64(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["exec_queue"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.ExecQueue = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["executor_group_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.ExecutorGroupName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["tasks"]; ok {
				for _, item := range v.([]interface{}) {
					tasksMap := item.(map[string]interface{})
					qualityProdSchedulerTask := wedatav20250806.QualityProdSchedulerTask{}
					if v, ok := tasksMap["workflow_id"].(string); ok && v != "" {
						qualityProdSchedulerTask.WorkflowId = helper.String(v)
					}
					if v, ok := tasksMap["task_id"].(string); ok && v != "" {
						qualityProdSchedulerTask.TaskId = helper.String(v)
					}
					if v, ok := tasksMap["task_name"].(string); ok && v != "" {
						qualityProdSchedulerTask.TaskName = helper.String(v)
					}
					if v, ok := tasksMap["cycle_type"].(int); ok {
						qualityProdSchedulerTask.CycleType = helper.IntInt64(v)
					}
					if v, ok := tasksMap["task_type"].(string); ok && v != "" {
						qualityProdSchedulerTask.TaskType = helper.String(v)
					}
					if v, ok := tasksMap["schedule_time_zone"].(string); ok && v != "" {
						qualityProdSchedulerTask.ScheduleTimeZone = helper.String(v)
					}
					if v, ok := tasksMap["in_charge_id_list"]; ok {
						inChargeIdListSet := v.(*schema.Set).List()
						for i := range inChargeIdListSet {
							inChargeIdList := inChargeIdListSet[i].(string)
							qualityProdSchedulerTask.InChargeIdList = append(qualityProdSchedulerTask.InChargeIdList, helper.String(inChargeIdList))
						}
					}
					if v, ok := tasksMap["in_charge_name_list"]; ok {
						inChargeNameListSet := v.(*schema.Set).List()
						for i := range inChargeNameListSet {
							inChargeNameList := inChargeNameListSet[i].(string)
							qualityProdSchedulerTask.InChargeNameList = append(qualityProdSchedulerTask.InChargeNameList, helper.String(inChargeNameList))
						}
					}
					qualityRuleGroupExecStrategy.Tasks = append(qualityRuleGroupExecStrategy.Tasks, &qualityProdSchedulerTask)
				}
			}
			if v, ok := ruleGroupExecStrategyBOListMap["start_time"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.StartTime = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["end_time"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.EndTime = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["cycle_type"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.CycleType = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["delay_time"].(int); ok {
				qualityRuleGroupExecStrategy.DelayTime = helper.IntUint64(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["cycle_step"].(int); ok {
				qualityRuleGroupExecStrategy.CycleStep = helper.IntUint64(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["task_action"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.TaskAction = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["exec_engine_type"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.ExecEngineType = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["exec_plan"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.ExecPlan = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["rule_id"].(int); ok {
				qualityRuleGroupExecStrategy.RuleId = helper.IntUint64(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["rule_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.RuleName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["trigger_types"]; ok {
				triggerTypesSet := v.(*schema.Set).List()
				for i := range triggerTypesSet {
					triggerTypes := triggerTypesSet[i].(string)
					qualityRuleGroupExecStrategy.TriggerTypes = append(qualityRuleGroupExecStrategy.TriggerTypes, helper.String(triggerTypes))
				}
			}
			if v, ok := ruleGroupExecStrategyBOListMap["dlc_group_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.DlcGroupName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["schema_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.SchemaName = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["description"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.Description = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["schedule_time_zone"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.ScheduleTimeZone = helper.String(v)
			}
			if groupConfigMap, ok := helper.ConvertInterfacesHeadToMap(ruleGroupExecStrategyBOListMap["group_config"]); ok {
				qualityRuleGroupConfig := wedatav20250806.QualityRuleGroupConfig{}
				if v, ok := groupConfigMap["analysis_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.AnalysisType = helper.String(v)
				}
				if v, ok := groupConfigMap["model_monitor_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.ModelMonitorType = helper.String(v)
				}
				if v, ok := groupConfigMap["predict_column"].(string); ok && v != "" {
					qualityRuleGroupConfig.PredictColumn = helper.String(v)
				}
				if v, ok := groupConfigMap["predict_column_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.PredictColumnType = helper.String(v)
				}
				if v, ok := groupConfigMap["label_column"].(string); ok && v != "" {
					qualityRuleGroupConfig.LabelColumn = helper.String(v)
				}
				if v, ok := groupConfigMap["label_column_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.LabelColumnType = helper.String(v)
				}
				if v, ok := groupConfigMap["model_id_column"].(string); ok && v != "" {
					qualityRuleGroupConfig.ModelIdColumn = helper.String(v)
				}
				if v, ok := groupConfigMap["model_id_column_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.ModelIdColumnType = helper.String(v)
				}
				if v, ok := groupConfigMap["timestamp_column"].(string); ok && v != "" {
					qualityRuleGroupConfig.TimestampColumn = helper.String(v)
				}
				if v, ok := groupConfigMap["timestamp_column_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.TimestampColumnType = helper.String(v)
				}
				if v, ok := groupConfigMap["granularity"].(int); ok {
					qualityRuleGroupConfig.Granularity = helper.IntInt64(v)
				}
				if v, ok := groupConfigMap["granularity_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.GranularityType = helper.String(v)
				}
				if v, ok := groupConfigMap["base_table"].(string); ok && v != "" {
					qualityRuleGroupConfig.BaseTable = helper.String(v)
				}
				if v, ok := groupConfigMap["base_db"].(string); ok && v != "" {
					qualityRuleGroupConfig.BaseDb = helper.String(v)
				}
				if v, ok := groupConfigMap["comparison_column"].(string); ok && v != "" {
					qualityRuleGroupConfig.ComparisonColumn = helper.String(v)
				}
				if v, ok := groupConfigMap["comparison_column_type"].(string); ok && v != "" {
					qualityRuleGroupConfig.ComparisonColumnType = helper.String(v)
				}
				if v, ok := groupConfigMap["protection_value"].(string); ok && v != "" {
					qualityRuleGroupConfig.ProtectionValue = helper.String(v)
				}
				if v, ok := groupConfigMap["positive_value"].(string); ok && v != "" {
					qualityRuleGroupConfig.PositiveValue = helper.String(v)
				}
				if v, ok := groupConfigMap["feature_column"].(string); ok && v != "" {
					qualityRuleGroupConfig.FeatureColumn = helper.String(v)
				}
				qualityRuleGroupExecStrategy.GroupConfig = &qualityRuleGroupConfig
			}
			if v, ok := ruleGroupExecStrategyBOListMap["engine_param"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.EngineParam = helper.String(v)
			}
			if v, ok := ruleGroupExecStrategyBOListMap["catalog_name"].(string); ok && v != "" {
				qualityRuleGroupExecStrategy.CatalogName = helper.String(v)
			}
			request.RuleGroupExecStrategyBOList = append(request.RuleGroupExecStrategyBOList, &qualityRuleGroupExecStrategy)
		}
	}

	if v, ok := d.GetOk("project_id"); ok {
		request.ProjectId = helper.String(v.(string))
	}

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().CreateQualityRuleGroupWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s create wedata quality rule group failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	if response == nil || response.Response == nil || response.Response.Data == nil || len(response.Response.Data.RuleGroupResultList) == 0 || response.Response.Data.RuleGroupResultList[0].Id == nil {
		if response.Response.Data.RuleGroupResultList[0].FailMsg != nil {
			return fmt.Errorf("wedata quality rule group create failed, reason:%s", *response.Response.Data.RuleGroupResultList[0].FailMsg)
		}
		return fmt.Errorf("wedata quality rule group id is nil")
	}

	ruleGroupId = *response.Response.Data.RuleGroupResultList[0].Id

	d.SetId(strings.Join([]string{projectId, helper.Int64ToStr(int64(ruleGroupId))}, tccommon.FILED_SP))

	return resourceTencentCloudWedataQualityRuleGroupRead(d, meta)
}

func resourceTencentCloudWedataQualityRuleGroupRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule_group.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	ruleGroupId := idSplit[1]

	respData, err := service.DescribeWedataQualityRuleGroupById(ctx, projectId, ruleGroupId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `wedata_quality_rule_group` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}

	_ = d.Set("project_id", projectId)

	if respData.RuleGroupId != nil {
		_ = d.Set("rule_group_id", respData.RuleGroupId)
	}

	if respData.ExecStrategy != nil {
		execStrategyMap := map[string]interface{}{}
		if respData.ExecStrategy.MonitorType != nil {
			execStrategyMap["monitor_type"] = respData.ExecStrategy.MonitorType
		}

		if respData.ExecStrategy.ExecutorGroupId != nil {
			execStrategyMap["executor_group_id"] = respData.ExecStrategy.ExecutorGroupId
		}

		if respData.ExecStrategy.RuleGroupName != nil {
			execStrategyMap["rule_group_name"] = respData.ExecStrategy.RuleGroupName
		}

		if respData.DatabaseName != nil {
			execStrategyMap["database_name"] = respData.DatabaseName
		}

		if respData.DatasourceId != nil {
			execStrategyMap["datasource_id"] = respData.DatasourceId
		}

		if respData.TableName != nil {
			execStrategyMap["table_name"] = respData.TableName
		}

		if respData.RuleGroupId != nil {
			execStrategyMap["rule_group_id"] = respData.RuleGroupId
		}

		if respData.ExecStrategy.ExecQueue != nil {
			execStrategyMap["exec_queue"] = respData.ExecStrategy.ExecQueue
		}

		if respData.ExecStrategy.ExecutorGroupName != nil {
			execStrategyMap["executor_group_name"] = respData.ExecStrategy.ExecutorGroupName
		}

		tasksList := make([]map[string]interface{}, 0, len(respData.ExecStrategy.Tasks))
		if respData.ExecStrategy.Tasks != nil {
			for _, tasks := range respData.ExecStrategy.Tasks {
				tasksMap := map[string]interface{}{}

				if tasks.WorkflowId != nil {
					tasksMap["workflow_id"] = tasks.WorkflowId
				}

				if tasks.TaskId != nil {
					tasksMap["task_id"] = tasks.TaskId
				}

				if tasks.TaskName != nil {
					tasksMap["task_name"] = tasks.TaskName
				}

				if tasks.CycleType != nil {
					tasksMap["cycle_type"] = tasks.CycleType
				}

				if tasks.TaskType != nil {
					tasksMap["task_type"] = tasks.TaskType
				}

				if tasks.ScheduleTimeZone != nil {
					tasksMap["schedule_time_zone"] = tasks.ScheduleTimeZone
				}

				if tasks.InChargeIdList != nil {
					tasksMap["in_charge_id_list"] = tasks.InChargeIdList
				}

				if tasks.InChargeNameList != nil {
					tasksMap["in_charge_name_list"] = tasks.InChargeNameList
				}

				tasksList = append(tasksList, tasksMap)
			}

			execStrategyMap["tasks"] = tasksList
		}
		if respData.ExecStrategy.StartTime != nil {
			execStrategyMap["start_time"] = respData.ExecStrategy.StartTime
		}

		if respData.ExecStrategy.EndTime != nil {
			execStrategyMap["end_time"] = respData.ExecStrategy.EndTime
		}

		if respData.ExecStrategy.CycleType != nil {
			execStrategyMap["cycle_type"] = respData.ExecStrategy.CycleType
		}

		if respData.ExecStrategy.DelayTime != nil {
			execStrategyMap["delay_time"] = respData.ExecStrategy.DelayTime
		}

		if respData.ExecStrategy.CycleStep != nil {
			execStrategyMap["cycle_step"] = respData.ExecStrategy.CycleStep
		}

		if respData.ExecStrategy.TaskAction != nil {
			execStrategyMap["task_action"] = respData.ExecStrategy.TaskAction
		}

		if respData.ExecStrategy.ExecEngineType != nil {
			execStrategyMap["exec_engine_type"] = respData.ExecStrategy.ExecEngineType
		}

		if respData.ExecStrategy.ExecPlan != nil {
			execStrategyMap["exec_plan"] = respData.ExecStrategy.ExecPlan
		}

		if respData.ExecStrategy.RuleId != nil {
			execStrategyMap["rule_id"] = respData.ExecStrategy.RuleId
		}

		if respData.ExecStrategy.RuleName != nil {
			execStrategyMap["rule_name"] = respData.ExecStrategy.RuleName
		}

		if respData.ExecStrategy.TriggerTypes != nil {
			execStrategyMap["trigger_types"] = respData.ExecStrategy.TriggerTypes
		}

		if respData.ExecStrategy.DlcGroupName != nil {
			execStrategyMap["dlc_group_name"] = respData.ExecStrategy.DlcGroupName
		}

		if respData.ExecStrategy.SchemaName != nil {
			execStrategyMap["schema_name"] = respData.ExecStrategy.SchemaName
		}

		if respData.Description != nil {
			execStrategyMap["description"] = respData.Description
		}

		if respData.ExecStrategy.ScheduleTimeZone != nil {
			execStrategyMap["schedule_time_zone"] = respData.ExecStrategy.ScheduleTimeZone
		}

		if respData.ExecStrategy.GroupConfig != nil {
			groupConfigMap := map[string]interface{}{}
			if respData.ExecStrategy.GroupConfig.AnalysisType != nil {
				groupConfigMap["analysis_type"] = respData.ExecStrategy.GroupConfig.AnalysisType
			}

			if respData.ExecStrategy.GroupConfig.ModelMonitorType != nil {
				groupConfigMap["model_monitor_type"] = respData.ExecStrategy.GroupConfig.ModelMonitorType
			}

			if respData.ExecStrategy.GroupConfig.PredictColumn != nil {
				groupConfigMap["predict_column"] = respData.ExecStrategy.GroupConfig.PredictColumn
			}

			if respData.ExecStrategy.GroupConfig.PredictColumnType != nil {
				groupConfigMap["predict_column_type"] = respData.ExecStrategy.GroupConfig.PredictColumnType
			}

			if respData.ExecStrategy.GroupConfig.LabelColumn != nil {
				groupConfigMap["label_column"] = respData.ExecStrategy.GroupConfig.LabelColumn
			}

			if respData.ExecStrategy.GroupConfig.LabelColumnType != nil {
				groupConfigMap["label_column_type"] = respData.ExecStrategy.GroupConfig.LabelColumnType
			}

			if respData.ExecStrategy.GroupConfig.ModelIdColumn != nil {
				groupConfigMap["model_id_column"] = respData.ExecStrategy.GroupConfig.ModelIdColumn
			}

			if respData.ExecStrategy.GroupConfig.ModelIdColumnType != nil {
				groupConfigMap["model_id_column_type"] = respData.ExecStrategy.GroupConfig.ModelIdColumnType
			}

			if respData.ExecStrategy.GroupConfig.TimestampColumn != nil {
				groupConfigMap["timestamp_column"] = respData.ExecStrategy.GroupConfig.TimestampColumn
			}

			if respData.ExecStrategy.GroupConfig.TimestampColumnType != nil {
				groupConfigMap["timestamp_column_type"] = respData.ExecStrategy.GroupConfig.TimestampColumnType
			}

			if respData.ExecStrategy.GroupConfig.Granularity != nil {
				groupConfigMap["granularity"] = respData.ExecStrategy.GroupConfig.Granularity
			}

			if respData.ExecStrategy.GroupConfig.GranularityType != nil {
				groupConfigMap["granularity_type"] = respData.ExecStrategy.GroupConfig.GranularityType
			}

			if respData.ExecStrategy.GroupConfig.BaseTable != nil {
				groupConfigMap["base_table"] = respData.ExecStrategy.GroupConfig.BaseTable
			}

			if respData.ExecStrategy.GroupConfig.BaseDb != nil {
				groupConfigMap["base_db"] = respData.ExecStrategy.GroupConfig.BaseDb
			}

			if respData.ExecStrategy.GroupConfig.ComparisonColumn != nil {
				groupConfigMap["comparison_column"] = respData.ExecStrategy.GroupConfig.ComparisonColumn
			}

			if respData.ExecStrategy.GroupConfig.ComparisonColumnType != nil {
				groupConfigMap["comparison_column_type"] = respData.ExecStrategy.GroupConfig.ComparisonColumnType
			}

			if respData.ExecStrategy.GroupConfig.ProtectionValue != nil {
				groupConfigMap["protection_value"] = respData.ExecStrategy.GroupConfig.ProtectionValue
			}

			if respData.ExecStrategy.GroupConfig.PositiveValue != nil {
				groupConfigMap["positive_value"] = respData.ExecStrategy.GroupConfig.PositiveValue
			}

			if respData.ExecStrategy.GroupConfig.FeatureColumn != nil {
				groupConfigMap["feature_column"] = respData.ExecStrategy.GroupConfig.FeatureColumn
			}

			execStrategyMap["group_config"] = []interface{}{groupConfigMap}
		}

		if respData.ExecStrategy.EngineParam != nil {
			execStrategyMap["engine_param"] = respData.ExecStrategy.EngineParam
		}

		if respData.ExecStrategy.CatalogName != nil {
			execStrategyMap["catalog_name"] = respData.ExecStrategy.CatalogName
		}

		_ = d.Set("rule_group_exec_strategy_bo_list", []interface{}{execStrategyMap})
	}

	_ = projectId
	_ = ruleGroupId
	return nil
}

func resourceTencentCloudWedataQualityRuleGroupUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule_group.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	immutableArgs := []string{"project_id"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	ruleGroupId := idSplit[1]

	needChange := false
	mutableArgs := []string{"rule_group_exec_strategy_bo_list"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := wedatav20250806.NewModifyQualityRuleGroupRequest()

		if v, ok := d.GetOk("rule_group_exec_strategy_bo_list"); ok {
			for _, item := range v.([]interface{}) {
				ruleGroupExecStrategyBOListMap := item.(map[string]interface{})
				qualityRuleGroupExecStrategy := wedatav20250806.QualityRuleGroupExecStrategy{}
				if v, ok := ruleGroupExecStrategyBOListMap["monitor_type"].(int); ok {
					qualityRuleGroupExecStrategy.MonitorType = helper.IntUint64(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["executor_group_id"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.ExecutorGroupId = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["rule_group_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.RuleGroupName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["database_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.DatabaseName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["datasource_id"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.DatasourceId = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["table_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.TableName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["rule_group_id"].(int); ok {
					qualityRuleGroupExecStrategy.RuleGroupId = helper.IntUint64(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["exec_queue"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.ExecQueue = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["executor_group_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.ExecutorGroupName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["tasks"]; ok {
					for _, item := range v.([]interface{}) {
						tasksMap := item.(map[string]interface{})
						qualityProdSchedulerTask := wedatav20250806.QualityProdSchedulerTask{}
						if v, ok := tasksMap["workflow_id"].(string); ok && v != "" {
							qualityProdSchedulerTask.WorkflowId = helper.String(v)
						}
						if v, ok := tasksMap["task_id"].(string); ok && v != "" {
							qualityProdSchedulerTask.TaskId = helper.String(v)
						}
						if v, ok := tasksMap["task_name"].(string); ok && v != "" {
							qualityProdSchedulerTask.TaskName = helper.String(v)
						}
						if v, ok := tasksMap["cycle_type"].(int); ok {
							qualityProdSchedulerTask.CycleType = helper.IntInt64(v)
						}
						if v, ok := tasksMap["task_type"].(string); ok && v != "" {
							qualityProdSchedulerTask.TaskType = helper.String(v)
						}
						if v, ok := tasksMap["schedule_time_zone"].(string); ok && v != "" {
							qualityProdSchedulerTask.ScheduleTimeZone = helper.String(v)
						}
						if v, ok := tasksMap["in_charge_id_list"]; ok {
							inChargeIdListSet := v.(*schema.Set).List()
							for i := range inChargeIdListSet {
								inChargeIdList := inChargeIdListSet[i].(string)
								qualityProdSchedulerTask.InChargeIdList = append(qualityProdSchedulerTask.InChargeIdList, helper.String(inChargeIdList))
							}
						}
						if v, ok := tasksMap["in_charge_name_list"]; ok {
							inChargeNameListSet := v.(*schema.Set).List()
							for i := range inChargeNameListSet {
								inChargeNameList := inChargeNameListSet[i].(string)
								qualityProdSchedulerTask.InChargeNameList = append(qualityProdSchedulerTask.InChargeNameList, helper.String(inChargeNameList))
							}
						}
						qualityRuleGroupExecStrategy.Tasks = append(qualityRuleGroupExecStrategy.Tasks, &qualityProdSchedulerTask)
					}
				}
				if v, ok := ruleGroupExecStrategyBOListMap["start_time"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.StartTime = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["end_time"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.EndTime = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["cycle_type"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.CycleType = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["delay_time"].(int); ok {
					qualityRuleGroupExecStrategy.DelayTime = helper.IntUint64(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["cycle_step"].(int); ok {
					qualityRuleGroupExecStrategy.CycleStep = helper.IntUint64(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["task_action"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.TaskAction = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["exec_engine_type"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.ExecEngineType = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["exec_plan"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.ExecPlan = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["rule_id"].(int); ok {
					qualityRuleGroupExecStrategy.RuleId = helper.IntUint64(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["rule_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.RuleName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["trigger_types"]; ok {
					triggerTypesSet := v.(*schema.Set).List()
					for i := range triggerTypesSet {
						triggerTypes := triggerTypesSet[i].(string)
						qualityRuleGroupExecStrategy.TriggerTypes = append(qualityRuleGroupExecStrategy.TriggerTypes, helper.String(triggerTypes))
					}
				}
				if v, ok := ruleGroupExecStrategyBOListMap["dlc_group_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.DlcGroupName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["schema_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.SchemaName = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["description"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.Description = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["schedule_time_zone"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.ScheduleTimeZone = helper.String(v)
				}
				if groupConfigMap, ok := helper.ConvertInterfacesHeadToMap(ruleGroupExecStrategyBOListMap["group_config"]); ok {
					qualityRuleGroupConfig := wedatav20250806.QualityRuleGroupConfig{}
					if v, ok := groupConfigMap["analysis_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.AnalysisType = helper.String(v)
					}
					if v, ok := groupConfigMap["model_monitor_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.ModelMonitorType = helper.String(v)
					}
					if v, ok := groupConfigMap["predict_column"].(string); ok && v != "" {
						qualityRuleGroupConfig.PredictColumn = helper.String(v)
					}
					if v, ok := groupConfigMap["predict_column_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.PredictColumnType = helper.String(v)
					}
					if v, ok := groupConfigMap["label_column"].(string); ok && v != "" {
						qualityRuleGroupConfig.LabelColumn = helper.String(v)
					}
					if v, ok := groupConfigMap["label_column_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.LabelColumnType = helper.String(v)
					}
					if v, ok := groupConfigMap["model_id_column"].(string); ok && v != "" {
						qualityRuleGroupConfig.ModelIdColumn = helper.String(v)
					}
					if v, ok := groupConfigMap["model_id_column_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.ModelIdColumnType = helper.String(v)
					}
					if v, ok := groupConfigMap["timestamp_column"].(string); ok && v != "" {
						qualityRuleGroupConfig.TimestampColumn = helper.String(v)
					}
					if v, ok := groupConfigMap["timestamp_column_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.TimestampColumnType = helper.String(v)
					}
					if v, ok := groupConfigMap["granularity"].(int); ok {
						qualityRuleGroupConfig.Granularity = helper.IntInt64(v)
					}
					if v, ok := groupConfigMap["granularity_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.GranularityType = helper.String(v)
					}
					if v, ok := groupConfigMap["base_table"].(string); ok && v != "" {
						qualityRuleGroupConfig.BaseTable = helper.String(v)
					}
					if v, ok := groupConfigMap["base_db"].(string); ok && v != "" {
						qualityRuleGroupConfig.BaseDb = helper.String(v)
					}
					if v, ok := groupConfigMap["comparison_column"].(string); ok && v != "" {
						qualityRuleGroupConfig.ComparisonColumn = helper.String(v)
					}
					if v, ok := groupConfigMap["comparison_column_type"].(string); ok && v != "" {
						qualityRuleGroupConfig.ComparisonColumnType = helper.String(v)
					}
					if v, ok := groupConfigMap["protection_value"].(string); ok && v != "" {
						qualityRuleGroupConfig.ProtectionValue = helper.String(v)
					}
					if v, ok := groupConfigMap["positive_value"].(string); ok && v != "" {
						qualityRuleGroupConfig.PositiveValue = helper.String(v)
					}
					if v, ok := groupConfigMap["feature_column"].(string); ok && v != "" {
						qualityRuleGroupConfig.FeatureColumn = helper.String(v)
					}
					qualityRuleGroupExecStrategy.GroupConfig = &qualityRuleGroupConfig
				}
				if v, ok := ruleGroupExecStrategyBOListMap["engine_param"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.EngineParam = helper.String(v)
				}
				if v, ok := ruleGroupExecStrategyBOListMap["catalog_name"].(string); ok && v != "" {
					qualityRuleGroupExecStrategy.CatalogName = helper.String(v)
				}
				request.RuleGroupExecStrategyBOList = append(request.RuleGroupExecStrategyBOList, &qualityRuleGroupExecStrategy)
			}
		}

		if v, ok := d.GetOk("project_id"); ok {
			request.ProjectId = helper.String(v.(string))
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().ModifyQualityRuleGroupWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update wedata quality rule group failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	_ = projectId
	_ = ruleGroupId
	return resourceTencentCloudWedataQualityRuleGroupRead(d, meta)
}

func resourceTencentCloudWedataQualityRuleGroupDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule_group.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	ruleGroupId := idSplit[1]

	ruleGroupIdInt, err := strconv.ParseInt(ruleGroupId, 10, 64)
	if err != nil {
		return err
	}

	request := wedatav20250806.NewDeleteQualityRuleGroupRequest()
	request.ProjectId = &projectId
	request.RuleGroupIdList = append(request.RuleGroupIdList, helper.Int64Uint64(ruleGroupIdInt))

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().DeleteQualityRuleGroupWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s delete wedata quality rule group failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	_ = projectId
	_ = ruleGroupId
	return nil
}
