// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataTriggerWorkflowRuns() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataTriggerWorkflowRunsRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"filters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Filter parameters. Workflow name or ID query name: `Keyword`; workflow ID query name: `WorkflowId`; folder query name: `FolderId`; owner query name: `InChargeUin`; workflow execution ID: `ExecutionId`.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Filter field name.",
						},
						"values": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "List of filter values.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"order_fields": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Sort fields. Sort field names include, for example, start time: `CreateTime`; end time: `EndTime`.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Sort field name.",
						},
						"direction": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Sort direction: ASC|DESC.",
						},
					},
				},
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Workflow run query results.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"items": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Collection of workflow run and related task run information.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"app_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "User AppId.",
									},
									"project_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Project ID.",
									},
									"workflow_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow name.",
									},
									"workflow_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow ID.",
									},
									"execution_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow execution ID.",
									},
									"trigger_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Trigger ID.",
									},
									"trigger_type": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Trigger type: scheduled trigger `Scheduler`, manual trigger `ManualTrigger`, event trigger `Event`.",
									},
									"create_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow trigger time.",
									},
									"execution_start_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Execution start timestamp.",
									},
									"execution_end_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Execution end timestamp.",
									},
									"execution_cost_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Execution duration in seconds.",
									},
									"queue_cost_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Concurrent queue time in seconds.",
									},
									"pending_cost_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Resource waiting time in seconds.",
									},
									"execution_state": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Execution state: failed `FAILED`, success `SUCCESS`, pending `PENDING`, skipped `SKIPED`, running `RUNNING`.",
									},
									"execute_user_uin": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Execute user UIN.",
									},
									"execute_user_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Execute user name.",
									},
									"error_code_str": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Error code.",
									},
									"workflow_params": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow parameters.",
									},
									"workflow_version_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow version ID.",
									},
									"support_rerun": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: "Whether rerun is supported.",
									},
									"rerun_times": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Number of reruns.",
									},
									"selected_task_ids": {
										Type:        schema.TypeSet,
										Required:    true,
										Description: "Task scope for execution, comma-separated task ID list.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"pending_start_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Pending start time.",
									},
									"queue_start_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Queue start time.",
									},
									"end_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "End time.",
									},
									"folder_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Folder ID.",
									},
									"folder_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Folder name.",
									},
									"planned_scheduling_time": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Planned scheduling time.",
									},
									"cycle_type": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Cycle type.",
									},
									"user_name_in_charge": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Person in charge name.",
									},
									"user_uin_in_charge": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Person in charge ID.",
									},
								},
							},
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataTriggerWorkflowRunsRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_trigger_workflow_runs.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		paramMap["ProjectId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("filters"); ok {
		filtersSet := v.([]interface{})
		tmpSet := make([]*wedatav20250806.Filter, 0, len(filtersSet))
		for _, item := range filtersSet {
			filtersMap := item.(map[string]interface{})
			filter := wedatav20250806.Filter{}
			if v, ok := filtersMap["name"].(string); ok && v != "" {
				filter.Name = helper.String(v)
			}
			if v, ok := filtersMap["values"]; ok {
				valuesSet := v.(*schema.Set).List()
				for i := range valuesSet {
					values := valuesSet[i].(string)
					filter.Values = append(filter.Values, helper.String(values))
				}
			}
			tmpSet = append(tmpSet, &filter)
		}
		paramMap["Filters"] = tmpSet
	}

	if v, ok := d.GetOk("order_fields"); ok {
		orderFieldsSet := v.([]interface{})
		tmpSet := make([]*wedatav20250806.OrderField, 0, len(orderFieldsSet))
		for _, item := range orderFieldsSet {
			orderFieldsMap := item.(map[string]interface{})
			orderField := wedatav20250806.OrderField{}
			if v, ok := orderFieldsMap["name"].(string); ok && v != "" {
				orderField.Name = helper.String(v)
			}
			if v, ok := orderFieldsMap["direction"].(string); ok && v != "" {
				orderField.Direction = helper.String(v)
			}
			tmpSet = append(tmpSet, &orderField)
		}
		paramMap["OrderFields"] = tmpSet
	}

	var respData []*wedatav20250806.TriggerWorkflowRunBrief
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataTriggerWorkflowRunsByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	ids := make([]string, 0, len(respData))
	dataMap := map[string]interface{}{}

	if len(respData) > 0 {
		itemsList := make([]map[string]interface{}, 0, len(respData))
		for _, items := range respData {
			itemsMap := map[string]interface{}{}

			if items.AppId != nil {
				itemsMap["app_id"] = items.AppId
			}

			if items.ProjectId != nil {
				itemsMap["project_id"] = items.ProjectId
			}

			if items.WorkflowName != nil {
				itemsMap["workflow_name"] = items.WorkflowName
			}

			if items.WorkflowId != nil {
				itemsMap["workflow_id"] = items.WorkflowId
			}

			if items.ExecutionId != nil {
				itemsMap["execution_id"] = items.ExecutionId
				ids = append(ids, *items.ExecutionId)
			}

			if items.TriggerId != nil {
				itemsMap["trigger_id"] = items.TriggerId
			}

			if items.TriggerType != nil {
				itemsMap["trigger_type"] = items.TriggerType
			}

			if items.CreateTime != nil {
				itemsMap["create_time"] = items.CreateTime
			}

			if items.ExecutionStartTime != nil {
				itemsMap["execution_start_time"] = items.ExecutionStartTime
			}

			if items.ExecutionEndTime != nil {
				itemsMap["execution_end_time"] = items.ExecutionEndTime
			}

			if items.ExecutionCostTime != nil {
				itemsMap["execution_cost_time"] = items.ExecutionCostTime
			}

			if items.QueueCostTime != nil {
				itemsMap["queue_cost_time"] = items.QueueCostTime
			}

			if items.PendingCostTime != nil {
				itemsMap["pending_cost_time"] = items.PendingCostTime
			}

			if items.ExecutionState != nil {
				itemsMap["execution_state"] = items.ExecutionState
			}

			if items.ExecuteUserUin != nil {
				itemsMap["execute_user_uin"] = items.ExecuteUserUin
			}

			if items.ExecuteUserName != nil {
				itemsMap["execute_user_name"] = items.ExecuteUserName
			}

			if items.ErrorCodeStr != nil {
				itemsMap["error_code_str"] = items.ErrorCodeStr
			}

			if items.WorkflowParams != nil {
				itemsMap["workflow_params"] = items.WorkflowParams
			}

			if items.WorkflowVersionId != nil {
				itemsMap["workflow_version_id"] = items.WorkflowVersionId
			}

			if items.SupportRerun != nil {
				itemsMap["support_rerun"] = items.SupportRerun
			}

			if items.RerunTimes != nil {
				itemsMap["rerun_times"] = items.RerunTimes
			}

			if items.SelectedTaskIds != nil {
				itemsMap["selected_task_ids"] = items.SelectedTaskIds
			}

			if items.PendingStartTime != nil {
				itemsMap["pending_start_time"] = items.PendingStartTime
			}

			if items.QueueStartTime != nil {
				itemsMap["queue_start_time"] = items.QueueStartTime
			}

			if items.EndTime != nil {
				itemsMap["end_time"] = items.EndTime
			}

			if items.FolderId != nil {
				itemsMap["folder_id"] = items.FolderId
			}

			if items.FolderName != nil {
				itemsMap["folder_name"] = items.FolderName
			}

			if items.PlannedSchedulingTime != nil {
				itemsMap["planned_scheduling_time"] = items.PlannedSchedulingTime
			}

			if items.CycleType != nil {
				itemsMap["cycle_type"] = items.CycleType
			}

			if items.UserNameInCharge != nil {
				itemsMap["user_name_in_charge"] = items.UserNameInCharge
			}

			if items.UserUinInCharge != nil {
				itemsMap["user_uin_in_charge"] = items.UserUinInCharge
			}

			itemsList = append(itemsList, itemsMap)
		}

		dataMap["items"] = itemsList
	}

	d.SetId(helper.DataResourceIdsHash(ids))
	_ = d.Set("data", []interface{}{dataMap})

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
