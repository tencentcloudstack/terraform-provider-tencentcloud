// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudWedataTriggerWorkflow() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudWedataTriggerWorkflowCreate,
		Read:   resourceTencentCloudWedataTriggerWorkflowRead,
		Update: resourceTencentCloudWedataTriggerWorkflowUpdate,
		Delete: resourceTencentCloudWedataTriggerWorkflowDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"workflow_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Workflow name.",
			},

			"parent_folder_path": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Parent folder path.",
			},

			"workflow_desc": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Workflow description.",
			},

			"owner_uin": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Workflow owner ID.",
			},

			"workflow_params": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Workflow parameters.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"param_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Parameter name.",
						},
						"param_value": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Parameter value.",
						},
					},
				},
			},

			"trigger_workflow_scheduler_configurations": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Unified scheduling configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"trigger_mode": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Trigger mode: Scheduled trigger:  `TIME_TRIGGER`; Continuous run: `CONTINUE_RUN`; File arrival: `FILE_ARRIVAL`. Notes: For `TIME_TRIGGER` and `CONTINUE_RUN` modes, SchedulerStatus, SchedulerTimeZone, StartTime, EndTime, ConfigMode, CycleType, and CrontabExpression are required; For `FILE_ARRIVAL` mode, FileArrivalPath, TriggerMinimumIntervalSecond, and TriggerWaitTimeSecond are required.",
						},
						"extra_info": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "WorkflowTriggerConfig converted to JSON format, used for reconciliation.",
						},
						"schedule_time_zone": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Scheduler time zone.",
						},
						"start_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Schedule effective start time.",
						},
						"end_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Schedule end time.",
						},
						"config_mode": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Configuration mode, COMMON or CRON_EXPRESSION.",
						},
						"cycle_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Cycle type. Supported values: `ONEOFF_CYCLE`: One-time; `YEAR_CYCLE`: Yearly; `MONTH_CYCLE`: Monthly; `WEEK_CYCLE`: Weekly; `DAY_CYCLE`: Daily; `HOUR_CYCLE`: Hourly; `MINUTE_CYCLE`: Minutely; `CRONTAB_CYCLE`: Crontab expression.",
						},
						"crontab_expression": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Cron expression.",
						},
						"trigger_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Trigger ID (UUID).",
						},
						"file_arrival_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Listening path in the storage system for file arrival mode.",
						},
						"trigger_minimum_interval_second": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Minimum trigger interval in file arrival mode (seconds).",
						},
						"trigger_wait_time_second": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Trigger wait time in file arrival mode (seconds).",
						},
						"scheduler_status": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Trigger status, ACTIVE or PAUSED.",
						},
					},
				},
			},

			"bundle_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Bundle ID.",
			},

			"bundle_info": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Bundle information.",
			},

			"general_task_params": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "General task parameter configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "General task parameter type, currently only SPARK_SQL is supported.",
						},
						"value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "General task parameter content; multiple parameters are separated by semicolons (;).",
						},
					},
				},
			},
		},
	}
}

func resourceTencentCloudWedataTriggerWorkflowCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_trigger_workflow.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		projectId  string
		workflowId string
	)
	var (
		request  = wedatav20250806.NewCreateTriggerWorkflowRequest()
		response = wedatav20250806.NewCreateTriggerWorkflowResponse()
	)

	if v, ok := d.GetOk("project_id"); ok {
		request.ProjectId = helper.String(v.(string))
		projectId = v.(string)
	}

	if v, ok := d.GetOk("workflow_name"); ok {
		request.WorkflowName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("parent_folder_path"); ok {
		request.ParentFolderPath = helper.String(v.(string))
	}

	if v, ok := d.GetOk("workflow_desc"); ok {
		request.WorkflowDesc = helper.String(v.(string))
	}

	if v, ok := d.GetOk("owner_uin"); ok {
		request.OwnerUin = helper.String(v.(string))
	}

	if v, ok := d.GetOk("workflow_params"); ok {
		for _, item := range v.([]interface{}) {
			workflowParamsMap := item.(map[string]interface{})
			paramInfo := wedatav20250806.ParamInfo{}
			if v, ok := workflowParamsMap["param_key"].(string); ok && v != "" {
				paramInfo.ParamKey = helper.String(v)
			}
			if v, ok := workflowParamsMap["param_value"].(string); ok && v != "" {
				paramInfo.ParamValue = helper.String(v)
			}
			request.WorkflowParams = append(request.WorkflowParams, &paramInfo)
		}
	}

	if v, ok := d.GetOk("trigger_workflow_scheduler_configurations"); ok {
		for _, item := range v.([]interface{}) {
			triggerWorkflowSchedulerConfigurationsMap := item.(map[string]interface{})
			workflowTriggerConfig := wedatav20250806.WorkflowTriggerConfig{}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_mode"].(string); ok && v != "" {
				workflowTriggerConfig.TriggerMode = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["extra_info"].(string); ok && v != "" {
				workflowTriggerConfig.ExtraInfo = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["schedule_time_zone"].(string); ok && v != "" {
				workflowTriggerConfig.ScheduleTimeZone = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["start_time"].(string); ok && v != "" {
				workflowTriggerConfig.StartTime = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["end_time"].(string); ok && v != "" {
				workflowTriggerConfig.EndTime = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["config_mode"].(string); ok && v != "" {
				workflowTriggerConfig.ConfigMode = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["cycle_type"].(string); ok && v != "" {
				workflowTriggerConfig.CycleType = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["crontab_expression"].(string); ok && v != "" {
				workflowTriggerConfig.CrontabExpression = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_id"].(string); ok && v != "" {
				workflowTriggerConfig.TriggerId = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["file_arrival_path"].(string); ok && v != "" {
				workflowTriggerConfig.FileArrivalPath = helper.String(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_minimum_interval_second"].(int); ok {
				workflowTriggerConfig.TriggerMinimumIntervalSecond = helper.IntUint64(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_wait_time_second"].(int); ok {
				workflowTriggerConfig.TriggerWaitTimeSecond = helper.IntUint64(v)
			}
			if v, ok := triggerWorkflowSchedulerConfigurationsMap["scheduler_status"].(string); ok && v != "" {
				workflowTriggerConfig.SchedulerStatus = helper.String(v)
			}
			request.TriggerWorkflowSchedulerConfigurations = append(request.TriggerWorkflowSchedulerConfigurations, &workflowTriggerConfig)
		}
	}

	if v, ok := d.GetOk("bundle_id"); ok {
		request.BundleId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("bundle_info"); ok {
		request.BundleInfo = helper.String(v.(string))
	}

	if v, ok := d.GetOk("general_task_params"); ok {
		for _, item := range v.([]interface{}) {
			generalTaskParamsMap := item.(map[string]interface{})
			workflowGeneralTaskParam := wedatav20250806.WorkflowGeneralTaskParam{}
			if v, ok := generalTaskParamsMap["type"].(string); ok && v != "" {
				workflowGeneralTaskParam.Type = helper.String(v)
			}
			if v, ok := generalTaskParamsMap["value"].(string); ok && v != "" {
				workflowGeneralTaskParam.Value = helper.String(v)
			}
			request.GeneralTaskParams = append(request.GeneralTaskParams, &workflowGeneralTaskParam)
		}
	}

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().CreateTriggerWorkflowWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s create wedata trigger workflow failed, reason:%+v", logId, reqErr)
		return reqErr
	}
	if response == nil || response.Response == nil || response.Response.Data == nil || response.Response.Data.WorkflowId == nil {
		return fmt.Errorf("wedata trigger workflow id is nil")
	}

	workflowId = *response.Response.Data.WorkflowId

	d.SetId(strings.Join([]string{projectId, workflowId}, tccommon.FILED_SP))

	return resourceTencentCloudWedataTriggerWorkflowRead(d, meta)
}

func resourceTencentCloudWedataTriggerWorkflowRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_trigger_workflow.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	workflowId := idSplit[1]

	respData, err := service.DescribeWedataTriggerWorkflowById(ctx, projectId, workflowId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `wedata_trigger_workflow` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}

	_ = d.Set("project_id", projectId)

	if respData.WorkflowName != nil {
		_ = d.Set("workflow_name", respData.WorkflowName)
	}

	if respData.OwnerUin != nil {
		_ = d.Set("owner_uin", respData.OwnerUin)
	}

	if respData.CreateUserUin != nil {
		_ = d.Set("create_user_uin", respData.CreateUserUin)
	}

	workflowParamsList := make([]map[string]interface{}, 0, len(respData.WorkflowParams))
	if respData.WorkflowParams != nil {
		for _, workflowParams := range respData.WorkflowParams {
			workflowParamsMap := map[string]interface{}{}

			if workflowParams.ParamKey != nil {
				workflowParamsMap["param_key"] = workflowParams.ParamKey
			}

			if workflowParams.ParamValue != nil {
				workflowParamsMap["param_value"] = workflowParams.ParamValue
			}

			workflowParamsList = append(workflowParamsList, workflowParamsMap)
		}

		_ = d.Set("workflow_params", workflowParamsList)
	}

	triggerWorkflowSchedulerConfigurationsList := make([]map[string]interface{}, 0, len(respData.TriggerWorkflowSchedulerConfigurations))
	if respData.TriggerWorkflowSchedulerConfigurations != nil {
		for _, triggerWorkflowSchedulerConfigurations := range respData.TriggerWorkflowSchedulerConfigurations {
			triggerWorkflowSchedulerConfigurationsMap := map[string]interface{}{}

			if triggerWorkflowSchedulerConfigurations.TriggerMode != nil {
				triggerWorkflowSchedulerConfigurationsMap["trigger_mode"] = triggerWorkflowSchedulerConfigurations.TriggerMode
			}

			if triggerWorkflowSchedulerConfigurations.ExtraInfo != nil {
				triggerWorkflowSchedulerConfigurationsMap["extra_info"] = triggerWorkflowSchedulerConfigurations.ExtraInfo
			}

			if triggerWorkflowSchedulerConfigurations.ScheduleTimeZone != nil {
				triggerWorkflowSchedulerConfigurationsMap["schedule_time_zone"] = triggerWorkflowSchedulerConfigurations.ScheduleTimeZone
			}

			if triggerWorkflowSchedulerConfigurations.StartTime != nil {
				triggerWorkflowSchedulerConfigurationsMap["start_time"] = triggerWorkflowSchedulerConfigurations.StartTime
			}

			if triggerWorkflowSchedulerConfigurations.EndTime != nil {
				triggerWorkflowSchedulerConfigurationsMap["end_time"] = triggerWorkflowSchedulerConfigurations.EndTime
			}

			if triggerWorkflowSchedulerConfigurations.ConfigMode != nil {
				triggerWorkflowSchedulerConfigurationsMap["config_mode"] = triggerWorkflowSchedulerConfigurations.ConfigMode
			}

			if triggerWorkflowSchedulerConfigurations.CycleType != nil {
				triggerWorkflowSchedulerConfigurationsMap["cycle_type"] = triggerWorkflowSchedulerConfigurations.CycleType
			}

			if triggerWorkflowSchedulerConfigurations.CrontabExpression != nil {
				triggerWorkflowSchedulerConfigurationsMap["crontab_expression"] = triggerWorkflowSchedulerConfigurations.CrontabExpression
			}

			if triggerWorkflowSchedulerConfigurations.TriggerId != nil {
				triggerWorkflowSchedulerConfigurationsMap["trigger_id"] = triggerWorkflowSchedulerConfigurations.TriggerId
			}

			if triggerWorkflowSchedulerConfigurations.FileArrivalPath != nil {
				triggerWorkflowSchedulerConfigurationsMap["file_arrival_path"] = triggerWorkflowSchedulerConfigurations.FileArrivalPath
			}

			if triggerWorkflowSchedulerConfigurations.TriggerMinimumIntervalSecond != nil {
				triggerWorkflowSchedulerConfigurationsMap["trigger_minimum_interval_second"] = triggerWorkflowSchedulerConfigurations.TriggerMinimumIntervalSecond
			}

			if triggerWorkflowSchedulerConfigurations.TriggerWaitTimeSecond != nil {
				triggerWorkflowSchedulerConfigurationsMap["trigger_wait_time_second"] = triggerWorkflowSchedulerConfigurations.TriggerWaitTimeSecond
			}

			if triggerWorkflowSchedulerConfigurations.SchedulerStatus != nil {
				triggerWorkflowSchedulerConfigurationsMap["scheduler_status"] = triggerWorkflowSchedulerConfigurations.SchedulerStatus
			}

			triggerWorkflowSchedulerConfigurationsList = append(triggerWorkflowSchedulerConfigurationsList, triggerWorkflowSchedulerConfigurationsMap)
		}

		_ = d.Set("trigger_workflow_scheduler_configurations", triggerWorkflowSchedulerConfigurationsList)
	}

	if respData.WorkflowDesc != nil {
		_ = d.Set("workflow_desc", respData.WorkflowDesc)
	}

	if respData.Path != nil && respData.WorkflowName != nil {
		_ = d.Set("parent_folder_path", strings.TrimSuffix(*respData.Path, fmt.Sprintf("/%s", *respData.WorkflowName)))
	}

	if respData.BundleId != nil {
		_ = d.Set("bundle_id", respData.BundleId)
	}

	if respData.BundleInfo != nil {
		_ = d.Set("bundle_info", respData.BundleInfo)
	}

	generalTaskParamsList := make([]map[string]interface{}, 0, len(respData.GeneralTaskParams))
	if respData.GeneralTaskParams != nil {
		for _, generalTaskParams := range respData.GeneralTaskParams {
			generalTaskParamsMap := map[string]interface{}{}

			if generalTaskParams.Type != nil {
				generalTaskParamsMap["type"] = generalTaskParams.Type
			}

			if generalTaskParams.Value != nil {
				generalTaskParamsMap["value"] = generalTaskParams.Value
			}

			generalTaskParamsList = append(generalTaskParamsList, generalTaskParamsMap)
		}

		_ = d.Set("general_task_params", generalTaskParamsList)
	}

	if respData.SchedulerStatus != nil {
		_ = d.Set("scheduler_status", respData.SchedulerStatus)
	}

	_ = projectId
	_ = workflowId
	return nil
}

func resourceTencentCloudWedataTriggerWorkflowUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_trigger_workflow.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	immutableArgs := []string{"project_id", "workflow_id", "parent_folder_path"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}
	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	workflowId := idSplit[1]

	needChange := false
	mutableArgs := []string{"workflow_name", "owner_uin", "workflow_desc", "workflow_params", "trigger_workflow_scheduler_configurations", "bundle_id", "bundle_info", "general_task_params"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := wedatav20250806.NewUpdateTriggerWorkflowRequest()
		request.ProjectId = &projectId
		request.WorkflowId = &workflowId

		if v, ok := d.GetOk("workflow_name"); ok {
			request.WorkflowName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("owner_uin"); ok {
			request.OwnerUin = helper.String(v.(string))
		}

		if v, ok := d.GetOk("workflow_desc"); ok {
			request.WorkflowDesc = helper.String(v.(string))
		}

		if v, ok := d.GetOk("workflow_params"); ok {
			for _, item := range v.([]interface{}) {
				workflowParamsMap := item.(map[string]interface{})
				paramInfo := wedatav20250806.ParamInfo{}
				if v, ok := workflowParamsMap["param_key"].(string); ok && v != "" {
					paramInfo.ParamKey = helper.String(v)
				}
				if v, ok := workflowParamsMap["param_value"].(string); ok && v != "" {
					paramInfo.ParamValue = helper.String(v)
				}
				request.WorkflowParams = append(request.WorkflowParams, &paramInfo)
			}
		}

		if v, ok := d.GetOk("trigger_workflow_scheduler_configurations"); ok {
			for _, item := range v.([]interface{}) {
				triggerWorkflowSchedulerConfigurationsMap := item.(map[string]interface{})
				workflowTriggerConfig := wedatav20250806.WorkflowTriggerConfig{}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_mode"].(string); ok && v != "" {
					workflowTriggerConfig.TriggerMode = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["extra_info"].(string); ok && v != "" {
					workflowTriggerConfig.ExtraInfo = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["schedule_time_zone"].(string); ok && v != "" {
					workflowTriggerConfig.ScheduleTimeZone = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["start_time"].(string); ok && v != "" {
					workflowTriggerConfig.StartTime = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["end_time"].(string); ok && v != "" {
					workflowTriggerConfig.EndTime = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["config_mode"].(string); ok && v != "" {
					workflowTriggerConfig.ConfigMode = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["cycle_type"].(string); ok && v != "" {
					workflowTriggerConfig.CycleType = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["crontab_expression"].(string); ok && v != "" {
					workflowTriggerConfig.CrontabExpression = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_id"].(string); ok && v != "" {
					workflowTriggerConfig.TriggerId = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["file_arrival_path"].(string); ok && v != "" {
					workflowTriggerConfig.FileArrivalPath = helper.String(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_minimum_interval_second"].(int); ok {
					workflowTriggerConfig.TriggerMinimumIntervalSecond = helper.IntUint64(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["trigger_wait_time_second"].(int); ok {
					workflowTriggerConfig.TriggerWaitTimeSecond = helper.IntUint64(v)
				}
				if v, ok := triggerWorkflowSchedulerConfigurationsMap["scheduler_status"].(string); ok && v != "" {
					workflowTriggerConfig.SchedulerStatus = helper.String(v)
				}
				request.TriggerWorkflowSchedulerConfigurations = append(request.TriggerWorkflowSchedulerConfigurations, &workflowTriggerConfig)
			}
		}

		if v, ok := d.GetOk("bundle_id"); ok {
			request.BundleId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("bundle_info"); ok {
			request.BundleInfo = helper.String(v.(string))
		}

		if v, ok := d.GetOk("general_task_params"); ok {
			for _, item := range v.([]interface{}) {
				generalTaskParamsMap := item.(map[string]interface{})
				workflowGeneralTaskParam := wedatav20250806.WorkflowGeneralTaskParam{}
				if v, ok := generalTaskParamsMap["type"].(string); ok && v != "" {
					workflowGeneralTaskParam.Type = helper.String(v)
				}
				if v, ok := generalTaskParamsMap["value"].(string); ok && v != "" {
					workflowGeneralTaskParam.Value = helper.String(v)
				}
				request.GeneralTaskParams = append(request.GeneralTaskParams, &workflowGeneralTaskParam)
			}
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().UpdateTriggerWorkflowWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update wedata trigger workflow failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	_ = projectId
	_ = workflowId
	return resourceTencentCloudWedataTriggerWorkflowRead(d, meta)
}

func resourceTencentCloudWedataTriggerWorkflowDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_trigger_workflow.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	workflowId := idSplit[1]

	var (
		request  = wedatav20250806.NewDeleteTriggerWorkflowRequest()
		response = wedatav20250806.NewDeleteTriggerWorkflowResponse()
	)
	request.ProjectId = &projectId
	request.WorkflowId = &workflowId

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().DeleteTriggerWorkflowWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s delete wedata trigger workflow failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	_ = response
	_ = projectId
	_ = workflowId
	return nil
}
