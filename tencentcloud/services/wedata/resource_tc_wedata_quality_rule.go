// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudWedataQualityRule() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudWedataQualityRuleCreate,
		Read:   resourceTencentCloudWedataQualityRuleRead,
		Update: resourceTencentCloudWedataQualityRuleUpdate,
		Delete: resourceTencentCloudWedataQualityRuleDelete,
		Importer: &schema.ResourceImporter{
			State: helper.ImportWithDefaultValue(map[string]interface{}{
				"create_rule_scene": 1,
			}),
		},
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"rule_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Rule ID.",
			},

			"create_rule_scene": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: "Rule creation scene. Valid values: `1` (single table multiple rules). Other business scenarios are not currently supported.",
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Rule name.",
			},
			"type": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: "Rule type. Valid values: `1` (system template), `2` (custom template), `3` (custom SQL).",
			},
			"datasource_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Data source ID.",
			},
			"database_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Database name.",
			},
			"compare_rule": {
				Type:        schema.TypeList,
				Required:    true,
				MaxItems:    1,
				Description: "Alarm trigger condition.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"items": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Comparison condition list.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"compare_type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Comparison type (required). Valid values: `1` (fixed value), `2` (fluctuation value), `3` (numerical range comparison), `4` (enumeration range comparison), `5` (no comparison), `6` (field data correlation), `7` (fairness).",
									},
									"operator": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Comparison operator type (conditionally required). Required when CompareType belongs to {1,2,6,7}. Valid values: `<`, `<=`, `==`, `=>`, `>`, `!=`, `IRLCRO` (within interval, left closed right open), `IRLORC` (within interval, left open right closed), `IRLCRC` (within interval, left closed right closed), `IRLORO` (within interval, left open right open), `NRLCRO` (not within interval, left closed right open), `NRLORC` (not within interval, left open right closed), `NRLCRC` (not within interval, left closed right closed), `NRLORO` (not within interval, left open right open).",
									},
									"value_compute_type": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Quality statistics value type (conditionally required). Required when CompareType belongs to {2,3,7}. When compareType = 2 (fluctuation value): `1` = absolute value (ABS), `2` = ascending (ASCEND), `3` = descending (DESCEND). When compareType = 3 (numerical range): `4` = within range (WITH_IN_RANGE), `5` = out of range (OUT_OF_RANGE). When compareType = 7 (fairness): `6` = fairness rate (FAIRNESS_RATE), `7` = fairness gap (FAIRNESS_GAP).",
									},
									"value_list": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: "Comparison threshold list (required).",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"value_type": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Threshold type (required). Valid values: `1` (low threshold), `2` (high threshold), `3` (normal threshold), `4` (enumeration value).",
												},
												"value": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Threshold value (required).",
												},
											},
										},
									},
								},
							},
						},
						"cycle_step": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "Periodic template default cycle in seconds.",
						},
						"compute_expression": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "`o` represents OR, `a` represents AND, numbers represent items index.",
						},
					},
				},
			},
			"alarm_level": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: "Alarm trigger level. Valid values: `1` (low), `2` (medium), `3` (high).",
			},
			"source_engine_types": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: "Supported execution engine list for this rule. Valid values: `1` (MYSQL), `2` (HIVE), `4` (SPARK), `8` (LIVY), `16` (DLC), `32` (GBASE), `64` (TCHouse-P), `128` (DORIS), `256` (TCHouse-D), `512` (EMR_STARROCKS), `1024` (TCHouse-X).",
				Elem: &schema.Schema{
					Type: schema.TypeInt,
				},
			},
			"table_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Table name. Either TableId or TableName must be provided.",
			},
			"rule_template_id": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Rule template ID. Required when Type is not equal to 3 (custom SQL).",
			},
			"quality_dim": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Quality dimension of the rule. Required when Type=3 (custom SQL). Valid values: `1` (accuracy), `2` (uniqueness), `3` (completeness), `4` (consistency), `5` (timeliness), `6` (validity).",
			},
			"rule_group_id": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Rule group ID.",
			},
			"table_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Data table ID. Either TableId or TableName must be provided.",
			},
			"source_object_data_type_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Source data object (table, field, etc.) detailed type. Required when Type=1 (system template). For table corresponds to fixed value `table` (template is table-level). For field corresponds to field type: int, string, etc. (template is field-level).",
			},
			"source_object_value": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Source data object (table, field, etc.) name. Required when Type=1 (system template).",
			},
			"condition_type": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Detection range. Required when Type=1 (system template) or 2 (custom template). Valid values: `1` (full table), `2` (conditional scan). Note: When CompareType is 2 (fluctuation value) or using user-defined template containing filter condition ${FILTER}, detection range must be 2 (conditional scan).",
			},
			"condition_expression": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Conditional scan WHERE condition expression. Required when ConditionType=2 (conditional scan).",
			},
			"custom_sql": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Custom SQL (Base64 encoded). Required when Type=3 (custom SQL).",
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Rule description.",
			},
			"database_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Database ID.",
			},
			"target_database_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target database ID.",
			},
			"target_table_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target table ID.",
			},
			"target_condition_expr": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target filter condition expression.",
			},
			"rel_condition_expr": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Source field and target field association condition ON expression. Required only for field data correlation rules (ruleTemplate qualityDim=4 (consistency) and subQualityDim=3 (field data correlation)). Example: sourceTable.model_id=targetTable.model_id.",
			},
			"field_config": {
				Type:        schema.TypeList,
				Optional:    true,
				MaxItems:    1,
				Description: "Custom template SQL expression field replacement parameters. Required when Type=2 (custom template).",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"where_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "WHERE variables.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"field_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Field key.",
									},
									"field_value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Field value.",
									},
									"field_data_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Field data type.",
									},
									"value_config": {
										Type:        schema.TypeList,
										Optional:    true,
										MaxItems:    1,
										Description: "Field value variable information.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"field_key": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Field value key.",
												},
												"field_value": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Field value.",
												},
												"field_data_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Field data type.",
												},
											},
										},
									},
								},
							},
						},
						"table_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Database and table variables.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"database_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Database ID.",
									},
									"database_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Database name.",
									},
									"table_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Table ID.",
									},
									"table_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Table name.",
									},
									"table_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Table key.",
									},
									"field_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: "Field variables.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"field_key": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Field key.",
												},
												"field_value": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Field value.",
												},
												"field_data_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Field data type.",
												},
												"value_config": {
													Type:        schema.TypeList,
													Optional:    true,
													MaxItems:    1,
													Description: "Field value variable information.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"field_key": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Field value key.",
															},
															"field_value": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Field value.",
															},
															"field_data_type": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Field data type.",
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"target_object_value": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target field name CITY.",
			},
			"index": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Index to distinguish different data when adding.",
			},
			"schema_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Schema name.",
			},
			"target_schema_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target schema name. Required only for system template field data correlation rules and when data source is TCHouse-P (ruleTemplate qualityDim=4 and subQualityDim=3). Used for cross-table data validation and association.",
			},
			"target_database_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target database name. Required only for system template field data correlation rules (ruleTemplate qualityDim=4 and subQualityDim=3). Used for cross-table data validation and association.",
			},
			"target_table_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target table name. Required only for system template field data correlation rules (ruleTemplate qualityDim=4 and subQualityDim=3). Used for cross-table data validation and association.",
			},
			"task_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Task ID.",
			},
			"catalog_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Data catalog name, mainly used for DLC data source.",
			},
			"target_catalog_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Target data catalog name. Required only for system template field data correlation rules and when data source is DLC (ruleTemplate qualityDim=4 and subQualityDim=3). Used for cross-table data validation and association.",
			},
		},
	}
}

func resourceTencentCloudWedataQualityRuleCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		projectId string
		ruleId    uint64
	)
	var (
		request  = wedatav20250806.NewCreateQualityRuleRequest()
		response = wedatav20250806.NewCreateQualityRuleResponse()
	)

	if v, ok := d.GetOk("project_id"); ok {
		request.ProjectId = helper.String(v.(string))
		projectId = v.(string)
	}

	if v, ok := d.GetOkExists("create_rule_scene"); ok {
		request.CreateRuleScene = helper.IntInt64(v.(int))
	}

	qualityRuleInfo := wedatav20250806.QualityRuleInfo{}
	if v, ok := d.GetOk("name"); ok {
		qualityRuleInfo.Name = helper.String(v.(string))
	}
	if v, ok := d.GetOk("type"); ok {
		qualityRuleInfo.Type = helper.IntUint64(v.(int))
	}
	if v, ok := d.GetOk("datasource_id"); ok {
		qualityRuleInfo.DatasourceId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("database_name"); ok {
		qualityRuleInfo.DatabaseName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("compare_rule"); ok {
		if compareRuleMap, ok := helper.ConvertInterfacesHeadToMap(v); ok {
			qualityCompareRule := wedatav20250806.QualityCompareRule{}
			if v, ok := compareRuleMap["items"]; ok {
				for _, item := range v.([]interface{}) {
					itemsMap := item.(map[string]interface{})
					qualityCompareRuleItem := wedatav20250806.QualityCompareRuleItem{}
					if v, ok := itemsMap["compare_type"].(int); ok {
						qualityCompareRuleItem.CompareType = helper.IntUint64(v)
					}
					if v, ok := itemsMap["operator"].(string); ok && v != "" {
						qualityCompareRuleItem.Operator = helper.String(v)
					}
					if v, ok := itemsMap["value_compute_type"].(int); ok {
						qualityCompareRuleItem.ValueComputeType = helper.IntUint64(v)
					}
					if v, ok := itemsMap["value_list"]; ok {
						for _, item := range v.([]interface{}) {
							valueListMap := item.(map[string]interface{})
							qualityThresholdValue := wedatav20250806.QualityThresholdValue{}
							if v, ok := valueListMap["value_type"].(int); ok {
								qualityThresholdValue.ValueType = helper.IntUint64(v)
							}
							if v, ok := valueListMap["value"].(string); ok && v != "" {
								qualityThresholdValue.Value = helper.String(v)
							}
							qualityCompareRuleItem.ValueList = append(qualityCompareRuleItem.ValueList, &qualityThresholdValue)
						}
					}
					qualityCompareRule.Items = append(qualityCompareRule.Items, &qualityCompareRuleItem)
				}
			}
			if v, ok := compareRuleMap["cycle_step"].(int); ok {
				qualityCompareRule.CycleStep = helper.IntUint64(v)
			}
			if v, ok := compareRuleMap["compute_expression"].(string); ok && v != "" {
				qualityCompareRule.ComputeExpression = helper.String(v)
			}
			qualityRuleInfo.CompareRule = &qualityCompareRule
		}
	}
	if v, ok := d.GetOk("alarm_level"); ok {
		qualityRuleInfo.AlarmLevel = helper.IntUint64(v.(int))
	}
	if v, ok := d.GetOk("source_engine_types"); ok {
		sourceEngineTypesSet := v.(*schema.Set).List()
		for i := range sourceEngineTypesSet {
			sourceEngineTypes := sourceEngineTypesSet[i].(int)
			qualityRuleInfo.SourceEngineTypes = append(qualityRuleInfo.SourceEngineTypes, helper.IntUint64(sourceEngineTypes))
		}
	}
	if v, ok := d.GetOk("table_name"); ok {
		qualityRuleInfo.TableName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("rule_template_id"); ok {
		qualityRuleInfo.RuleTemplateId = helper.IntUint64(v.(int))
	}
	if v, ok := d.GetOk("quality_dim"); ok {
		qualityRuleInfo.QualityDim = helper.IntUint64(v.(int))
	}
	if v, ok := d.GetOk("project_id"); ok {
		qualityRuleInfo.ProjectId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("rule_group_id"); ok {
		qualityRuleInfo.RuleGroupId = helper.IntUint64(v.(int))
	}
	if v, ok := d.GetOk("table_id"); ok {
		qualityRuleInfo.TableId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("source_object_data_type_name"); ok {
		qualityRuleInfo.SourceObjectDataTypeName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("source_object_value"); ok {
		qualityRuleInfo.SourceObjectValue = helper.String(v.(string))
	}
	if v, ok := d.GetOk("condition_type"); ok {
		qualityRuleInfo.ConditionType = helper.IntUint64(v.(int))
	}
	if v, ok := d.GetOk("condition_expression"); ok {
		qualityRuleInfo.ConditionExpression = helper.String(v.(string))
	}
	if v, ok := d.GetOk("custom_sql"); ok {
		qualityRuleInfo.CustomSql = helper.String(v.(string))
	}
	if v, ok := d.GetOk("description"); ok {
		qualityRuleInfo.Description = helper.String(v.(string))
	}
	if v, ok := d.GetOk("database_id"); ok {
		qualityRuleInfo.DatabaseId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_database_id"); ok {
		qualityRuleInfo.TargetDatabaseId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_table_id"); ok {
		qualityRuleInfo.TargetTableId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_condition_expr"); ok {
		qualityRuleInfo.TargetConditionExpr = helper.String(v.(string))
	}
	if v, ok := d.GetOk("rel_condition_expr"); ok {
		qualityRuleInfo.RelConditionExpr = helper.String(v.(string))
	}
	if v, ok := d.GetOk("field_config"); ok {
		if fieldConfigMap, ok := helper.ConvertInterfacesHeadToMap(v); ok {
			qualityRuleFieldConfig := wedatav20250806.QualityRuleFieldConfig{}
			if v, ok := fieldConfigMap["where_config"]; ok {
				for _, item := range v.([]interface{}) {
					whereConfigMap := item.(map[string]interface{})
					qualityFieldConfig := wedatav20250806.QualityFieldConfig{}
					if v, ok := whereConfigMap["field_key"].(string); ok && v != "" {
						qualityFieldConfig.FieldKey = helper.String(v)
					}
					if v, ok := whereConfigMap["field_value"].(string); ok && v != "" {
						qualityFieldConfig.FieldValue = helper.String(v)
					}
					if v, ok := whereConfigMap["field_data_type"].(string); ok && v != "" {
						qualityFieldConfig.FieldDataType = helper.String(v)
					}
					if valueConfigMap, ok := helper.ConvertInterfacesHeadToMap(whereConfigMap["value_config"]); ok {
						qualityColumnValueConfig := wedatav20250806.QualityColumnValueConfig{}
						if v, ok := valueConfigMap["field_key"].(string); ok && v != "" {
							qualityColumnValueConfig.FieldKey = helper.String(v)
						}
						if v, ok := valueConfigMap["field_value"].(string); ok && v != "" {
							qualityColumnValueConfig.FieldValue = helper.String(v)
						}
						if v, ok := valueConfigMap["field_data_type"].(string); ok && v != "" {
							qualityColumnValueConfig.FieldDataType = helper.String(v)
						}
						qualityFieldConfig.ValueConfig = &qualityColumnValueConfig
					}
					qualityRuleFieldConfig.WhereConfig = append(qualityRuleFieldConfig.WhereConfig, &qualityFieldConfig)
				}
			}
			if v, ok := fieldConfigMap["table_config"]; ok {
				for _, item := range v.([]interface{}) {
					tableConfigMap := item.(map[string]interface{})
					qualityTableConfig := wedatav20250806.QualityTableConfig{}
					if v, ok := tableConfigMap["database_id"].(string); ok && v != "" {
						qualityTableConfig.DatabaseId = helper.String(v)
					}
					if v, ok := tableConfigMap["database_name"].(string); ok && v != "" {
						qualityTableConfig.DatabaseName = helper.String(v)
					}
					if v, ok := tableConfigMap["table_id"].(string); ok && v != "" {
						qualityTableConfig.TableId = helper.String(v)
					}
					if v, ok := tableConfigMap["table_name"].(string); ok && v != "" {
						qualityTableConfig.TableName = helper.String(v)
					}
					if v, ok := tableConfigMap["table_key"].(string); ok && v != "" {
						qualityTableConfig.TableKey = helper.String(v)
					}
					if v, ok := tableConfigMap["field_config"]; ok {
						for _, item := range v.([]interface{}) {
							fieldConfigMap := item.(map[string]interface{})
							qualityFieldConfig := wedatav20250806.QualityFieldConfig{}
							if v, ok := fieldConfigMap["field_key"].(string); ok && v != "" {
								qualityFieldConfig.FieldKey = helper.String(v)
							}
							if v, ok := fieldConfigMap["field_value"].(string); ok && v != "" {
								qualityFieldConfig.FieldValue = helper.String(v)
							}
							if v, ok := fieldConfigMap["field_data_type"].(string); ok && v != "" {
								qualityFieldConfig.FieldDataType = helper.String(v)
							}
							if valueConfigMap, ok := helper.ConvertInterfacesHeadToMap(fieldConfigMap["value_config"]); ok {
								qualityColumnValueConfig2 := wedatav20250806.QualityColumnValueConfig{}
								if v, ok := valueConfigMap["field_key"].(string); ok && v != "" {
									qualityColumnValueConfig2.FieldKey = helper.String(v)
								}
								if v, ok := valueConfigMap["field_value"].(string); ok && v != "" {
									qualityColumnValueConfig2.FieldValue = helper.String(v)
								}
								if v, ok := valueConfigMap["field_data_type"].(string); ok && v != "" {
									qualityColumnValueConfig2.FieldDataType = helper.String(v)
								}
								qualityFieldConfig.ValueConfig = &qualityColumnValueConfig2
							}
							qualityTableConfig.FieldConfig = append(qualityTableConfig.FieldConfig, &qualityFieldConfig)
						}
					}
					qualityRuleFieldConfig.TableConfig = append(qualityRuleFieldConfig.TableConfig, &qualityTableConfig)
				}
			}
			qualityRuleInfo.FieldConfig = &qualityRuleFieldConfig
		}
	}
	if v, ok := d.GetOk("target_object_value"); ok {
		qualityRuleInfo.TargetObjectValue = helper.String(v.(string))
	}
	if v, ok := d.GetOk("index"); ok {
		qualityRuleInfo.Index = helper.String(v.(string))
	}
	if v, ok := d.GetOk("schema_name"); ok {
		qualityRuleInfo.SchemaName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_schema_name"); ok {
		qualityRuleInfo.TargetSchemaName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_database_name"); ok {
		qualityRuleInfo.TargetDatabaseName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_table_name"); ok {
		qualityRuleInfo.TargetTableName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("task_id"); ok {
		qualityRuleInfo.TaskId = helper.String(v.(string))
	}
	if v, ok := d.GetOk("catalog_name"); ok {
		qualityRuleInfo.CatalogName = helper.String(v.(string))
	}
	if v, ok := d.GetOk("target_catalog_name"); ok {
		qualityRuleInfo.TargetCatalogName = helper.String(v.(string))
	}
	request.RuleBOList = append(request.RuleBOList, &qualityRuleInfo)

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().CreateQualityRuleWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s create wedata quality rule failed, reason:%+v", logId, reqErr)
		return reqErr
	}
	if response == nil || response.Response == nil || response.Response.Data == nil || len(response.Response.Data.SuccessRuleIds) == 0 {
		if response.Response.Data.Msg != nil {
			return fmt.Errorf("wedata quality rule id is nil, msg [%s]", *response.Response.Data.Msg)
		}
		return fmt.Errorf("wedata quality rule id is nil")
	}
	ruleId = *response.Response.Data.SuccessRuleIds[0]

	d.SetId(strings.Join([]string{projectId, helper.Int64ToStr(int64(ruleId))}, tccommon.FILED_SP))

	return resourceTencentCloudWedataQualityRuleRead(d, meta)
}

func resourceTencentCloudWedataQualityRuleRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	ruleId := idSplit[1]

	respData, err := service.DescribeWedataQualityRuleById(ctx, projectId, ruleId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `wedata_quality_rule` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}

	_ = d.Set("project_id", projectId)
	_ = d.Set("rule_id", ruleId)

	if respData.RuleGroupId != nil {
		_ = d.Set("rule_group_id", respData.RuleGroupId)
	}

	if respData.TableId != nil {
		_ = d.Set("table_id", respData.TableId)
	}

	if respData.Name != nil {
		_ = d.Set("name", respData.Name)
	}

	if respData.Type != nil {
		_ = d.Set("type", respData.Type)
	}

	if respData.RuleTemplateId != nil {
		_ = d.Set("rule_template_id", respData.RuleTemplateId)
	}

	// if respData.RuleTemplateContent != nil {
	// 	_ = d.Set("rule_template_content", respData.RuleTemplateContent)
	// }

	if respData.QualityDim != nil {
		_ = d.Set("quality_dim", respData.QualityDim)
	}

	// if respData.SourceObjectType != nil {
	// 	_ = d.Set("source_object_type", respData.SourceObjectType)
	// }

	// if respData.SourceObjectDataType != nil {
	// 	_ = d.Set("source_object_data_type", respData.SourceObjectDataType)
	// }

	if respData.SourceObjectDataTypeName != nil {
		_ = d.Set("source_object_data_type_name", respData.SourceObjectDataTypeName)
	}

	if respData.SourceObjectValue != nil {
		_ = d.Set("source_object_value", respData.SourceObjectValue)
	}

	if respData.ConditionType != nil {
		_ = d.Set("condition_type", respData.ConditionType)
	}

	if respData.ConditionExpression != nil {
		_ = d.Set("condition_expression", respData.ConditionExpression)
	}

	if respData.CustomSql != nil {
		_ = d.Set("custom_sql", respData.CustomSql)
	}

	if respData.CompareRule != nil {
		compareRuleMap := map[string]interface{}{}
		itemsList2 := make([]map[string]interface{}, 0, len(respData.CompareRule.Items))
		if respData.CompareRule.Items != nil {
			for _, items := range respData.CompareRule.Items {
				itemsMap2 := map[string]interface{}{}

				if items.CompareType != nil {
					itemsMap2["compare_type"] = items.CompareType
				}

				if items.Operator != nil {
					itemsMap2["operator"] = items.Operator
				}

				if items.ValueComputeType != nil {
					itemsMap2["value_compute_type"] = items.ValueComputeType
				}

				valueListList := make([]map[string]interface{}, 0, len(items.ValueList))
				if items.ValueList != nil {
					for _, valueList := range items.ValueList {
						valueListMap := map[string]interface{}{}

						if valueList.ValueType != nil {
							valueListMap["value_type"] = valueList.ValueType
						}

						if valueList.Value != nil {
							valueListMap["value"] = valueList.Value
						}

						valueListList = append(valueListList, valueListMap)
					}

					itemsMap2["value_list"] = valueListList
				}
				itemsList2 = append(itemsList2, itemsMap2)
			}

			compareRuleMap["items"] = itemsList2
		}
		if respData.CompareRule.CycleStep != nil {
			compareRuleMap["cycle_step"] = respData.CompareRule.CycleStep
		}

		if respData.CompareRule.ComputeExpression != nil {
			compareRuleMap["compute_expression"] = respData.CompareRule.ComputeExpression
		}

		_ = d.Set("compare_rule", []interface{}{compareRuleMap})
	}

	if respData.AlarmLevel != nil {
		_ = d.Set("alarm_level", respData.AlarmLevel)
	}

	if respData.Description != nil {
		_ = d.Set("description", respData.Description)
	}

	// if respData.Operator != nil {
	// 	_ = d.Set("operator", respData.Operator)
	// }

	if respData.TargetDatabaseId != nil {
		_ = d.Set("target_database_id", respData.TargetDatabaseId)
	}

	if respData.TargetDatabaseName != nil {
		_ = d.Set("target_database_name", respData.TargetDatabaseName)
	}

	if respData.TargetTableId != nil {
		_ = d.Set("target_table_id", respData.TargetTableId)
	}

	if respData.TargetTableName != nil {
		_ = d.Set("target_table_name", respData.TargetTableName)
	}

	if respData.TargetConditionExpr != nil {
		_ = d.Set("target_condition_expr", respData.TargetConditionExpr)
	}

	if respData.RelConditionExpr != nil {
		_ = d.Set("rel_condition_expr", respData.RelConditionExpr)
	}

	fieldConfigMap := map[string]interface{}{}

	if respData.FieldConfig != nil {
		whereConfigList := make([]map[string]interface{}, 0, len(respData.FieldConfig.WhereConfig))
		if respData.FieldConfig.WhereConfig != nil {
			for _, whereConfig := range respData.FieldConfig.WhereConfig {
				whereConfigMap := map[string]interface{}{}

				if whereConfig.FieldKey != nil {
					whereConfigMap["field_key"] = whereConfig.FieldKey
				}

				if whereConfig.FieldValue != nil {
					whereConfigMap["field_value"] = whereConfig.FieldValue
				}

				if whereConfig.FieldDataType != nil {
					whereConfigMap["field_data_type"] = whereConfig.FieldDataType
				}

				valueConfigMap := map[string]interface{}{}

				if whereConfig.ValueConfig != nil {
					if whereConfig.ValueConfig.FieldKey != nil {
						valueConfigMap["field_key"] = whereConfig.ValueConfig.FieldKey
					}

					if whereConfig.ValueConfig.FieldValue != nil {
						valueConfigMap["field_value"] = whereConfig.ValueConfig.FieldValue
					}

					if whereConfig.ValueConfig.FieldDataType != nil {
						valueConfigMap["field_data_type"] = whereConfig.ValueConfig.FieldDataType
					}

					whereConfigMap["value_config"] = []interface{}{valueConfigMap}
				}

				whereConfigList = append(whereConfigList, whereConfigMap)
			}

			fieldConfigMap["where_config"] = whereConfigList
		}
		if respData.FieldConfig.TableConfig != nil {
			tableConfigList := make([]map[string]interface{}, 0, len(respData.FieldConfig.TableConfig))
			for _, tableConfig := range respData.FieldConfig.TableConfig {
				tableConfigMap := map[string]interface{}{}

				if tableConfig.DatabaseId != nil {
					tableConfigMap["database_id"] = tableConfig.DatabaseId
				}

				if tableConfig.DatabaseName != nil {
					tableConfigMap["database_name"] = tableConfig.DatabaseName
				}

				if tableConfig.TableId != nil {
					tableConfigMap["table_id"] = tableConfig.TableId
				}

				if tableConfig.TableName != nil {
					tableConfigMap["table_name"] = tableConfig.TableName
				}

				if tableConfig.TableKey != nil {
					tableConfigMap["table_key"] = tableConfig.TableKey
				}

				if tableConfig.FieldConfig != nil {
					fieldConfigList := make([]map[string]interface{}, 0, len(tableConfig.FieldConfig))
					for _, fieldConfig := range tableConfig.FieldConfig {
						fieldConfigMap := map[string]interface{}{}

						if fieldConfig.FieldKey != nil {
							fieldConfigMap["field_key"] = fieldConfig.FieldKey
						}

						if fieldConfig.FieldValue != nil {
							fieldConfigMap["field_value"] = fieldConfig.FieldValue
						}

						if fieldConfig.FieldDataType != nil {
							fieldConfigMap["field_data_type"] = fieldConfig.FieldDataType
						}

						valueConfigMap := map[string]interface{}{}

						if fieldConfig.ValueConfig != nil {
							if fieldConfig.ValueConfig.FieldKey != nil {
								valueConfigMap["field_key"] = fieldConfig.ValueConfig.FieldKey
							}

							if fieldConfig.ValueConfig.FieldValue != nil {
								valueConfigMap["field_value"] = fieldConfig.ValueConfig.FieldValue
							}

							if fieldConfig.ValueConfig.FieldDataType != nil {
								valueConfigMap["field_data_type"] = fieldConfig.ValueConfig.FieldDataType
							}

							fieldConfigMap["value_config"] = []interface{}{valueConfigMap}
						}

						fieldConfigList = append(fieldConfigList, fieldConfigMap)
					}

					tableConfigMap["field_config"] = fieldConfigList
				}
				tableConfigList = append(tableConfigList, tableConfigMap)
			}

			fieldConfigMap["table_config"] = tableConfigList
		}
		_ = d.Set("field_config", []interface{}{fieldConfigMap})
	}

	// if respData.MultiSourceFlag != nil {
	// 	_ = d.Set("multi_source_flag", respData.MultiSourceFlag)
	// }

	// if respData.WhereFlag != nil {
	// 	_ = d.Set("where_flag", respData.WhereFlag)
	// }

	// if respData.TemplateSql != nil {
	// 	_ = d.Set("template_sql", respData.TemplateSql)
	// }

	// if respData.SubQualityDim != nil {
	// 	_ = d.Set("sub_quality_dim", respData.SubQualityDim)
	// }

	// if respData.TargetObjectType != nil {
	// 	_ = d.Set("target_object_type", respData.TargetObjectType)
	// }

	// if respData.TargetObjectDataType != nil {
	// 	_ = d.Set("target_object_data_type", respData.TargetObjectDataType)
	// }

	// if respData.TargetObjectDataTypeName != nil {
	// 	_ = d.Set("target_object_data_type_name", respData.TargetObjectDataTypeName)
	// }

	if respData.TargetObjectValue != nil {
		_ = d.Set("target_object_value", respData.TargetObjectValue)
	}

	if respData.SourceEngineTypes != nil {
		_ = d.Set("source_engine_types", respData.SourceEngineTypes)
	}

	if respData.TableName != nil {
		_ = d.Set("table_name", respData.TableName)
	}

	// if respData.TableOwnerName != nil {
	// 	_ = d.Set("table_owner_name", respData.TableOwnerName)
	// }

	// if respData.ExecStrategy != nil {
	// 	execStrategyMap := map[string]interface{}{}
	// 	if respData.ExecStrategy.MonitorType != nil {
	// 		execStrategyMap["monitor_type"] = respData.ExecStrategy.MonitorType
	// 	}

	// 	if respData.ExecStrategy.ExecutorGroupId != nil {
	// 		execStrategyMap["executor_group_id"] = respData.ExecStrategy.ExecutorGroupId
	// 	}

	// 	if respData.ExecStrategy.RuleGroupName != nil {
	// 		execStrategyMap["rule_group_name"] = respData.ExecStrategy.RuleGroupName
	// 	}

	// 	if respData.ExecStrategy.DatabaseName != nil {
	// 		execStrategyMap["database_name"] = respData.ExecStrategy.DatabaseName
	// 	}

	// 	if respData.ExecStrategy.DatasourceId != nil {
	// 		execStrategyMap["datasource_id"] = respData.ExecStrategy.DatasourceId
	// 	}

	// 	if respData.ExecStrategy.TableName != nil {
	// 		execStrategyMap["table_name"] = respData.ExecStrategy.TableName
	// 	}

	// 	if respData.ExecStrategy.RuleGroupId != nil {
	// 		execStrategyMap["rule_group_id"] = respData.ExecStrategy.RuleGroupId
	// 	}

	// 	if respData.ExecStrategy.ExecQueue != nil {
	// 		execStrategyMap["exec_queue"] = respData.ExecStrategy.ExecQueue
	// 	}

	// 	if respData.ExecStrategy.ExecutorGroupName != nil {
	// 		execStrategyMap["executor_group_name"] = respData.ExecStrategy.ExecutorGroupName
	// 	}

	// 	if respData.ExecStrategy.Tasks != nil {
	// 		tasksList := make([]map[string]interface{}, 0, len(respData.ExecStrategy.Tasks))
	// 		for _, tasks := range respData.ExecStrategy.Tasks {
	// 			tasksMap := map[string]interface{}{}

	// 			if tasks.WorkflowId != nil {
	// 				tasksMap["workflow_id"] = tasks.WorkflowId
	// 			}

	// 			if tasks.TaskId != nil {
	// 				tasksMap["task_id"] = tasks.TaskId
	// 			}

	// 			if tasks.TaskName != nil {
	// 				tasksMap["task_name"] = tasks.TaskName
	// 			}

	// 			if tasks.CycleType != nil {
	// 				tasksMap["cycle_type"] = tasks.CycleType
	// 			}

	// 			if tasks.TaskType != nil {
	// 				tasksMap["task_type"] = tasks.TaskType
	// 			}

	// 			if tasks.ScheduleTimeZone != nil {
	// 				tasksMap["schedule_time_zone"] = tasks.ScheduleTimeZone
	// 			}

	// 			if tasks.InChargeIdList != nil {
	// 				tasksMap["in_charge_id_list"] = tasks.InChargeIdList
	// 			}

	// 			if tasks.InChargeNameList != nil {
	// 				tasksMap["in_charge_name_list"] = tasks.InChargeNameList
	// 			}

	// 			tasksList = append(tasksList, tasksMap)
	// 		}

	// 		execStrategyMap["tasks"] = tasksList
	// 	}
	// 	if respData.ExecStrategy.StartTime != nil {
	// 		execStrategyMap["start_time"] = respData.ExecStrategy.StartTime
	// 	}

	// 	if respData.ExecStrategy.EndTime != nil {
	// 		execStrategyMap["end_time"] = respData.ExecStrategy.EndTime
	// 	}

	// 	if respData.ExecStrategy.CycleType != nil {
	// 		execStrategyMap["cycle_type"] = respData.ExecStrategy.CycleType
	// 	}

	// 	if respData.ExecStrategy.DelayTime != nil {
	// 		execStrategyMap["delay_time"] = respData.ExecStrategy.DelayTime
	// 	}

	// 	if respData.ExecStrategy.CycleStep != nil {
	// 		execStrategyMap["cycle_step"] = respData.ExecStrategy.CycleStep
	// 	}

	// 	if respData.ExecStrategy.TaskAction != nil {
	// 		execStrategyMap["task_action"] = respData.ExecStrategy.TaskAction
	// 	}

	// 	if respData.ExecStrategy.ExecEngineType != nil {
	// 		execStrategyMap["exec_engine_type"] = respData.ExecStrategy.ExecEngineType
	// 	}

	// 	if respData.ExecStrategy.ExecPlan != nil {
	// 		execStrategyMap["exec_plan"] = respData.ExecStrategy.ExecPlan
	// 	}

	// 	if respData.ExecStrategy.RuleId != nil {
	// 		execStrategyMap["rule_id"] = respData.ExecStrategy.RuleId
	// 	}

	// 	if respData.ExecStrategy.RuleName != nil {
	// 		execStrategyMap["rule_name"] = respData.ExecStrategy.RuleName
	// 	}

	// 	if respData.ExecStrategy.TriggerTypes != nil {
	// 		execStrategyMap["trigger_types"] = respData.ExecStrategy.TriggerTypes
	// 	}

	// 	if respData.ExecStrategy.DlcGroupName != nil {
	// 		execStrategyMap["dlc_group_name"] = respData.ExecStrategy.DlcGroupName
	// 	}

	// 	if respData.ExecStrategy.SchemaName != nil {
	// 		execStrategyMap["schema_name"] = respData.ExecStrategy.SchemaName
	// 	}

	// 	if respData.ExecStrategy.Description != nil {
	// 		execStrategyMap["description"] = respData.ExecStrategy.Description
	// 	}

	// 	if respData.ExecStrategy.ScheduleTimeZone != nil {
	// 		execStrategyMap["schedule_time_zone"] = respData.ExecStrategy.ScheduleTimeZone
	// 	}

	// 	// if respData.ExecStrategy.GroupConfig != nil {
	// 	// 	groupConfigMap := map[string]interface{}{}
	// 	// 	if respData.ExecStrategy.GroupConfig.AnalysisType != nil {
	// 	// 		groupConfigMap["analysis_type"] = respData.ExecStrategy.GroupConfig.AnalysisType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.ModelMonitorType != nil {
	// 	// 		groupConfigMap["model_monitor_type"] = respData.ExecStrategy.GroupConfig.ModelMonitorType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.PredictColumn != nil {
	// 	// 		groupConfigMap["predict_column"] = respData.ExecStrategy.GroupConfig.PredictColumn
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.PredictColumnType != nil {
	// 	// 		groupConfigMap["predict_column_type"] = respData.ExecStrategy.GroupConfig.PredictColumnType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.LabelColumn != nil {
	// 	// 		groupConfigMap["label_column"] = respData.ExecStrategy.GroupConfig.LabelColumn
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.LabelColumnType != nil {
	// 	// 		groupConfigMap["label_column_type"] = respData.ExecStrategy.GroupConfig.LabelColumnType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.ModelIdColumn != nil {
	// 	// 		groupConfigMap["model_id_column"] = respData.ExecStrategy.GroupConfig.ModelIdColumn
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.ModelIdColumnType != nil {
	// 	// 		groupConfigMap["model_id_column_type"] = respData.ExecStrategy.GroupConfig.ModelIdColumnType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.TimestampColumn != nil {
	// 	// 		groupConfigMap["timestamp_column"] = respData.ExecStrategy.GroupConfig.TimestampColumn
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.TimestampColumnType != nil {
	// 	// 		groupConfigMap["timestamp_column_type"] = respData.ExecStrategy.GroupConfig.TimestampColumnType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.Granularity != nil {
	// 	// 		groupConfigMap["granularity"] = respData.ExecStrategy.GroupConfig.Granularity
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.GranularityType != nil {
	// 	// 		groupConfigMap["granularity_type"] = respData.ExecStrategy.GroupConfig.GranularityType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.BaseTable != nil {
	// 	// 		groupConfigMap["base_table"] = respData.ExecStrategy.GroupConfig.BaseTable
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.BaseDb != nil {
	// 	// 		groupConfigMap["base_db"] = respData.ExecStrategy.GroupConfig.BaseDb
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.ComparisonColumn != nil {
	// 	// 		groupConfigMap["comparison_column"] = respData.ExecStrategy.GroupConfig.ComparisonColumn
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.ComparisonColumnType != nil {
	// 	// 		groupConfigMap["comparison_column_type"] = respData.ExecStrategy.GroupConfig.ComparisonColumnType
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.ProtectionValue != nil {
	// 	// 		groupConfigMap["protection_value"] = respData.ExecStrategy.GroupConfig.ProtectionValue
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.PositiveValue != nil {
	// 	// 		groupConfigMap["positive_value"] = respData.ExecStrategy.GroupConfig.PositiveValue
	// 	// 	}

	// 	// 	if respData.ExecStrategy.GroupConfig.FeatureColumn != nil {
	// 	// 		groupConfigMap["feature_column"] = respData.ExecStrategy.GroupConfig.FeatureColumn
	// 	// 	}

	// 	// 	execStrategyMap["group_config"] = []interface{}{groupConfigMap}
	// 	// }

	// 	if respData.ExecStrategy.EngineParam != nil {
	// 		execStrategyMap["engine_param"] = respData.ExecStrategy.EngineParam
	// 	}

	// 	if respData.ExecStrategy.CatalogName != nil {
	// 		execStrategyMap["catalog_name"] = respData.ExecStrategy.CatalogName
	// 	}

	// 	_ = d.Set("exec_strategy", []interface{}{execStrategyMap})
	// }

	// if respData.Subscription != nil {
	// 	subscriptionMap := map[string]interface{}{}
	// 	if respData.Subscription.RuleGroupId != nil {
	// 		subscriptionMap["rule_group_id"] = respData.Subscription.RuleGroupId
	// 	}

	// 	receiversList := make([]map[string]interface{}, 0, len(respData.Subscription.Receivers))
	// 	if respData.Subscription.Receivers != nil {
	// 		for _, receivers := range respData.Subscription.Receivers {
	// 			receiversMap := map[string]interface{}{}

	// 			if receivers.ReceiverUserId != nil {
	// 				receiversMap["receiver_user_id"] = receivers.ReceiverUserId
	// 			}

	// 			if receivers.ReceiverName != nil {
	// 				receiversMap["receiver_name"] = receivers.ReceiverName
	// 			}

	// 			if receivers.ReceiverUserIdStr != nil {
	// 				receiversMap["receiver_user_id_str"] = receivers.ReceiverUserIdStr
	// 			}

	// 			receiversList = append(receiversList, receiversMap)
	// 		}

	// 		subscriptionMap["receivers"] = receiversList
	// 	}
	// 	if respData.Subscription.SubscribeType != nil {
	// 		subscriptionMap["subscribe_type"] = respData.Subscription.SubscribeType
	// 	}

	// 	webHooksList := make([]map[string]interface{}, 0, len(respData.Subscription.WebHooks))
	// 	if respData.Subscription.WebHooks != nil {
	// 		for _, webHooks := range respData.Subscription.WebHooks {
	// 			webHooksMap := map[string]interface{}{}

	// 			if webHooks.HookType != nil {
	// 				webHooksMap["hook_type"] = webHooks.HookType
	// 			}

	// 			if webHooks.HookAddress != nil {
	// 				webHooksMap["hook_address"] = webHooks.HookAddress
	// 			}

	// 			webHooksList = append(webHooksList, webHooksMap)
	// 		}

	// 		subscriptionMap["web_hooks"] = webHooksList
	// 	}
	// 	if respData.Subscription.RuleId != nil {
	// 		subscriptionMap["rule_id"] = respData.Subscription.RuleId
	// 	}

	// 	if respData.Subscription.RuleName != nil {
	// 		subscriptionMap["rule_name"] = respData.Subscription.RuleName
	// 	}

	// 	if respData.Subscription.AlarmMessageRule != nil {
	// 		subscriptionMap["alarm_message_rule"] = respData.Subscription.AlarmMessageRule
	// 	}

	// 	_ = d.Set("subscription", []interface{}{subscriptionMap})
	// }

	// if respData.CreateTime != nil {
	// 	_ = d.Set("create_time", respData.CreateTime)
	// }

	if respData.DatasourceId != nil {
		_ = d.Set("datasource_id", strconv.FormatUint(*respData.DatasourceId, 10))
	}

	if respData.DatabaseId != nil {
		_ = d.Set("database_id", respData.DatabaseId)
	}

	// if respData.MonitorStatus != nil {
	// 	_ = d.Set("monitor_status", respData.MonitorStatus)
	// }

	// if respData.TriggerCondition != nil {
	// 	_ = d.Set("trigger_condition", respData.TriggerCondition)
	// }

	// if respData.DsEnvType != nil {
	// 	_ = d.Set("ds_env_type", respData.DsEnvType)
	// }

	// if respData.DatasourceType != nil {
	// 	_ = d.Set("datasource_type", respData.DatasourceType)
	// }

	if respData.SchemaName != nil {
		_ = d.Set("schema_name", respData.SchemaName)
	}

	if respData.TargetSchemaName != nil {
		_ = d.Set("target_schema_name", respData.TargetSchemaName)
	}

	if respData.ProjectId != nil {
		_ = d.Set("project_id", respData.ProjectId)
	}

	// if respData.ProjectName != nil {
	// 	_ = d.Set("project_name", respData.ProjectName)
	// }

	// if respData.UpdateTime != nil {
	// 	_ = d.Set("update_time", respData.UpdateTime)
	// }

	// if respData.DatasourceName != nil {
	// 	_ = d.Set("datasource_name", respData.DatasourceName)
	// }

	if respData.DatabaseName != nil {
		_ = d.Set("database_name", respData.DatabaseName)
	}

	// if respData.FailMsg != nil {
	// 	_ = d.Set("fail_msg", respData.FailMsg)
	// }

	// if respData.GroupType != nil {
	// 	_ = d.Set("group_type", respData.GroupType)
	// }

	// if respData.AspectTaskId != nil {
	// 	_ = d.Set("aspect_task_id", respData.AspectTaskId)
	// }

	if respData.CatalogName != nil {
		_ = d.Set("catalog_name", respData.CatalogName)
	}

	if respData.TargetCatalogName != nil {
		_ = d.Set("target_catalog_name", respData.TargetCatalogName)
	}

	_ = projectId
	_ = ruleId
	return nil
}

func resourceTencentCloudWedataQualityRuleUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	immutableArgs := []string{"project_id", "rule_id"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}
	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	ruleId := idSplit[1]

	ruleIdInt, err := strconv.ParseUint(ruleId, 10, 64)
	if err != nil {
		return fmt.Errorf("ruleId is not uint")
	}

	needChange := false
	mutableArgs := []string{
		"name", "type", "alarm_level", "table_id", "rule_template_id", "quality_dim", "rule_group_id",
		"source_object_data_type_name", "source_object_value", "condition_type", "condition_expression",
		"custom_sql", "description", "target_database_id", "target_table_id", "target_condition_expr",
		"rel_condition_expr", "target_object_value", "source_engine_types", "target_database_name",
		"target_schema_name", "target_table_name", "catalog_name", "target_catalog_name", "compare_rule",
	}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := wedatav20250806.NewModifyQualityRuleRequest()
		request.ProjectId = helper.String(projectId)
		request.RuleId = &ruleIdInt

		if v, ok := d.GetOk("name"); ok {
			request.Name = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("type"); ok {
			request.Type = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOkExists("alarm_level"); ok {
			request.AlarmLevel = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOk("table_id"); ok {
			request.TableId = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("rule_template_id"); ok {
			request.RuleTemplateId = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOkExists("quality_dim"); ok {
			request.QualityDim = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOkExists("rule_group_id"); ok {
			request.RuleGroupId = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOk("source_object_data_type_name"); ok {
			request.SourceObjectDataTypeName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("source_object_value"); ok {
			request.SourceObjectValue = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("condition_type"); ok {
			request.ConditionType = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOk("condition_expression"); ok {
			request.ConditionExpression = helper.String(v.(string))
		}

		if v, ok := d.GetOk("custom_sql"); ok {
			request.CustomSql = helper.String(v.(string))
		}

		if v, ok := d.GetOk("description"); ok {
			request.Description = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_database_id"); ok {
			request.TargetDatabaseId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_table_id"); ok {
			request.TargetTableId = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_condition_expr"); ok {
			request.TargetConditionExpr = helper.String(v.(string))
		}

		if v, ok := d.GetOk("rel_condition_expr"); ok {
			request.RelConditionExpr = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_object_value"); ok {
			request.TargetObjectValue = helper.String(v.(string))
		}

		if v, ok := d.GetOk("source_engine_types"); ok {
			sourceEngineTypesSet := v.(*schema.Set).List()
			for i := range sourceEngineTypesSet {
				sourceEngineTypes := sourceEngineTypesSet[i].(int)
				request.SourceEngineTypes = append(request.SourceEngineTypes, helper.IntUint64(sourceEngineTypes))
			}
		}

		if v, ok := d.GetOk("target_database_name"); ok {
			request.TargetDatabaseName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_schema_name"); ok {
			request.TargetSchemaName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_table_name"); ok {
			request.TargetTableName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("catalog_name"); ok {
			request.CatalogName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("target_catalog_name"); ok {
			request.TargetCatalogName = helper.String(v.(string))
		}

		if v, ok := d.GetOk("compare_rule"); ok {
			if compareRuleMap, ok := helper.ConvertInterfacesHeadToMap(v); ok {
				qualityCompareRule := wedatav20250806.QualityCompareRule{}
				if v, ok := compareRuleMap["items"]; ok {
					for _, item := range v.([]interface{}) {
						itemsMap := item.(map[string]interface{})
						qualityCompareRuleItem := wedatav20250806.QualityCompareRuleItem{}
						if v, ok := itemsMap["compare_type"].(int); ok {
							qualityCompareRuleItem.CompareType = helper.IntUint64(v)
						}
						if v, ok := itemsMap["operator"].(string); ok && v != "" {
							qualityCompareRuleItem.Operator = helper.String(v)
						}
						if v, ok := itemsMap["value_compute_type"].(int); ok {
							qualityCompareRuleItem.ValueComputeType = helper.IntUint64(v)
						}
						if v, ok := itemsMap["value_list"]; ok {
							for _, item := range v.([]interface{}) {
								valueListMap := item.(map[string]interface{})
								qualityThresholdValue := wedatav20250806.QualityThresholdValue{}
								if v, ok := valueListMap["value_type"].(int); ok {
									qualityThresholdValue.ValueType = helper.IntUint64(v)
								}
								if v, ok := valueListMap["value"].(string); ok && v != "" {
									qualityThresholdValue.Value = helper.String(v)
								}
								qualityCompareRuleItem.ValueList = append(qualityCompareRuleItem.ValueList, &qualityThresholdValue)
							}
						}
						qualityCompareRule.Items = append(qualityCompareRule.Items, &qualityCompareRuleItem)
					}
				}
				if v, ok := compareRuleMap["cycle_step"].(int); ok {
					qualityCompareRule.CycleStep = helper.IntUint64(v)
				}
				if v, ok := compareRuleMap["compute_expression"].(string); ok && v != "" {
					qualityCompareRule.ComputeExpression = helper.String(v)
				}
				request.CompareRule = &qualityCompareRule
			}
		}

		reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().ModifyQualityRuleWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if reqErr != nil {
			log.Printf("[CRITAL]%s update wedata quality rule failed, reason:%+v", logId, reqErr)
			return reqErr
		}
	}

	_ = projectId
	_ = ruleId
	return resourceTencentCloudWedataQualityRuleRead(d, meta)
}

func resourceTencentCloudWedataQualityRuleDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_quality_rule.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	projectId := idSplit[0]
	ruleId := idSplit[1]

	ruleIdInt, err := strconv.ParseUint(ruleId, 10, 64)
	if err != nil {
		return fmt.Errorf("ruleId is not uint")
	}

	var (
		request  = wedatav20250806.NewDeleteQualityRuleRequest()
		response = wedatav20250806.NewDeleteQualityRuleResponse()
	)
	request.ProjectId = &projectId
	request.RuleId = &ruleIdInt

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().DeleteQualityRuleWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if reqErr != nil {
		log.Printf("[CRITAL]%s delete wedata quality rule failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	_ = response
	_ = projectId
	_ = ruleId
	return nil
}
