package wedata

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudWedataDataBackfillPlanOperation() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudWedataDataBackfillPlanOperationCreate,
		Read:   resourceTencentCloudWedataDataBackfillPlanOperationRead,
		Delete: resourceTencentCloudWedataDataBackfillPlanOperationDelete,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Project ID.",
			},

			"task_ids": {
				Type:        schema.TypeSet,
				Required:    true,
				ForceNew:    true,
				Description: "Backfill task collection.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"data_backfill_range_list": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: "Specifies the data time configuration for the backfill task.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"start_date": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Start date in yyyy-MM-dd format. indicates the start from 00:00:00 on the specified date.",
						},
						"end_date": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "End date in the format yyyy-MM-dd, indicates ending at 23:59:59 of the specified date.",
						},
						"execution_start_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Start time of each day between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.",
						},
						"execution_end_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "End time point between [StartDate, EndDate] in HH:mm format. effective for tasks with a period of hours or less.",
						},
					},
				},
			},

			"time_zone": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Time zone, default UTC+8.",
			},

			"data_backfill_plan_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Backfill plan name. if left empty, a string of characters is randomly generated by system.",
			},

			"check_parent_type": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Check parent task type. valid values: NONE (do not check ALL), ALL (check ALL upstream parent tasks), MAKE_SCOPE (only check in the currently selected tasks of the backfill plan). default: NONE (do not check).",
			},

			"skip_event_listening": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: "Specifies whether to ignore event dependency for backfill. default true.",
			},

			"redefine_self_workflow_dependency": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Custom workflow self-dependency. valid values: yes or no. if not configured, use the original workflow self-dependency.",
			},

			"redefine_parallel_num": {
				Type:        schema.TypeInt,
				Optional:    true,
				ForceNew:    true,
				Description: "Customizes the degree of concurrency for instance running. if without configuring, use the existing self-dependent of the task.",
			},

			"scheduler_resource_group_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Scheduling resource group id. if left empty, indicates usage of the original task scheduling execution resource group.",
			},

			"integration_resource_group_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Integration task resource group id. indicates usage of the original task scheduling execution resource group if empty.",
			},

			"redefine_param_list": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: "Custom parameter. re-specifies the task's parameters to facilitate the execution of new logic by replenished instances.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"k": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Key name.",
						},
						"v": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The value. do not pass SQL (the request will be deemed as an attack on the api). if needed, transcode the SQL with Base64 and decode it.",
						},
					},
				},
			},

			"data_time_order": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Backfill Execution Order - The execution order for backfill instances based on their data time. Effective only when both conditions are met:\n\n1. Must be the same cycle task.\n\n2. Priority is given to dependency order. If no dependencies apply, execution follows the configured order.\n\nValid values:\n\n-NORMAL: No specific order (default)\n\n-ORDER: Execute in chronological order\n\n-REVERSE: Execute in reverse chronological order.",
			},

			"redefine_cycle_type": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Backfill Instance Regeneration Cycle - If set, this will redefine the generation cycle of backfill task instances. Currently, only daily instances can be converted into instances generated on the first day of each month.\n\nValid value:\n\nMONTH_CYCLE: Monthly.",
			},
		},
	}
}

func resourceTencentCloudWedataDataBackfillPlanOperationCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_data_backfill_plan_operation.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId              = tccommon.GetLogId(tccommon.ContextNil)
		ctx                = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		request            = wedatav20250806.NewCreateDataBackfillPlanRequest()
		response           = wedatav20250806.NewCreateDataBackfillPlanResponse()
		dataBackfillPlanId string
	)

	if v, ok := d.GetOk("project_id"); ok {
		request.ProjectId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("task_ids"); ok {
		taskIdsSet := v.(*schema.Set).List()
		for i := range taskIdsSet {
			taskIds := taskIdsSet[i].(string)
			request.TaskIds = append(request.TaskIds, helper.String(taskIds))
		}
	}

	if v, ok := d.GetOk("data_backfill_range_list"); ok {
		for _, item := range v.([]interface{}) {
			dataBackfillRangeListMap := item.(map[string]interface{})
			dataBackfillRange := wedatav20250806.DataBackfillRange{}
			if v, ok := dataBackfillRangeListMap["start_date"].(string); ok && v != "" {
				dataBackfillRange.StartDate = helper.String(v)
			}

			if v, ok := dataBackfillRangeListMap["end_date"].(string); ok && v != "" {
				dataBackfillRange.EndDate = helper.String(v)
			}

			if v, ok := dataBackfillRangeListMap["execution_start_time"].(string); ok && v != "" {
				dataBackfillRange.ExecutionStartTime = helper.String(v)
			}

			if v, ok := dataBackfillRangeListMap["execution_end_time"].(string); ok && v != "" {
				dataBackfillRange.ExecutionEndTime = helper.String(v)
			}

			request.DataBackfillRangeList = append(request.DataBackfillRangeList, &dataBackfillRange)
		}
	}

	if v, ok := d.GetOk("time_zone"); ok {
		request.TimeZone = helper.String(v.(string))
	}

	if v, ok := d.GetOk("data_backfill_plan_name"); ok {
		request.DataBackfillPlanName = helper.String(v.(string))
	}

	if v, ok := d.GetOk("check_parent_type"); ok {
		request.CheckParentType = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("skip_event_listening"); ok {
		request.SkipEventListening = helper.Bool(v.(bool))
	}

	if v, ok := d.GetOk("redefine_self_workflow_dependency"); ok {
		request.RedefineSelfWorkflowDependency = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("redefine_parallel_num"); ok {
		request.RedefineParallelNum = helper.IntUint64(v.(int))
	}

	if v, ok := d.GetOk("scheduler_resource_group_id"); ok {
		request.SchedulerResourceGroupId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("integration_resource_group_id"); ok {
		request.IntegrationResourceGroupId = helper.String(v.(string))
	}

	if v, ok := d.GetOk("redefine_param_list"); ok {
		for _, item := range v.([]interface{}) {
			redefineParamListMap := item.(map[string]interface{})
			kVPair := wedatav20250806.KVPair{}
			if v, ok := redefineParamListMap["k"].(string); ok && v != "" {
				kVPair.K = helper.String(v)
			}

			if v, ok := redefineParamListMap["v"].(string); ok && v != "" {
				kVPair.V = helper.String(v)
			}

			request.RedefineParamList = append(request.RedefineParamList, &kVPair)
		}
	}

	if v, ok := d.GetOk("data_time_order"); ok {
		request.DataTimeOrder = helper.String(v.(string))
	}

	if v, ok := d.GetOk("redefine_cycle_type"); ok {
		request.RedefineCycleType = helper.String(v.(string))
	}

	reqErr := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseWedataV20250806Client().CreateDataBackfillPlanWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || result.Response.Data == nil {
			return resource.NonRetryableError(fmt.Errorf("Create wedata data backfill plan operation failed, Response is nil"))
		}

		response = result
		return nil
	})

	if reqErr != nil {
		log.Printf("[CRITAL]%s create wedata data backfill plan operation failed, reason:%+v", logId, reqErr)
		return reqErr
	}

	if response.Response.Data.DataBackfillPlanId == nil {
		return fmt.Errorf("DataBackfillPlanId is nil.")
	}

	dataBackfillPlanId = *response.Response.Data.DataBackfillPlanId
	d.SetId(dataBackfillPlanId)
	return resourceTencentCloudWedataDataBackfillPlanOperationRead(d, meta)
}

func resourceTencentCloudWedataDataBackfillPlanOperationRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_data_backfill_plan_operation.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}

func resourceTencentCloudWedataDataBackfillPlanOperationDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_wedata_data_backfill_plan_operation.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
