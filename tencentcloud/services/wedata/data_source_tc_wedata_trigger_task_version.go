// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataTriggerTaskVersion() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataTriggerTaskVersionRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"task_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Task ID.",
			},

			"version_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Submitted version ID; if not provided, the latest submitted version is used by default.",
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Version details.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"create_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Creation time.",
						},
						"version_num": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Version number.",
						},
						"create_user_uin": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Version creator.",
						},
						"version_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Saved version ID.",
						},
						"version_remark": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Version description.",
						},
						"approve_status": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Approval status (only for submitted versions).",
						},
						"approve_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Production status (only for submitted versions).",
						},
						"approve_user_uin": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Approver ID.",
						},
						"task": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Task details of the version.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"trigger_task_base_attribute": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Basic task attributes.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"task_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Task ID.",
												},
												"task_type_id": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: "Task type ID:\n\n- 26: OfflineSynchronization\n- 30: Python\n- 32: DLC SQL\n- 35: Shell\n- 38: Shell Form Mode\n- 46: DLC Spark\n- 50: DLC PySpark\n- 130: Branch Node\n- 131: Merged Node\n- 132: Notebook\n- 133: SSH\n- 137: For-each\n- 139: DLC Spark Streaming\n- 140: Run Workflow.",
												},
												"workflow_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Workflow ID.",
												},
												"task_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task name.",
												},
												"task_latest_version_no": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Latest saved version number.",
												},
												"task_latest_submit_version_no": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Latest submitted version number.",
												},
												"workflow_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Workflow name.",
												},
												"status": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task status:\n* N: New\n* Y: Scheduling.",
												},
												"submit": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: "Latest submission status of the task; whether the task has been submitted: true/false.",
												},
												"create_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task creation time, example: 2022-02-12 11:13:41.",
												},
												"last_update_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last update time, example: 2025-08-13 16:34:06.",
												},
												"last_update_user_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last updater name.",
												},
												"last_ops_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last operations time.",
												},
												"last_ops_user_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Last operations user name.",
												},
												"owner_uin": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task owner ID.",
												},
												"task_description": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task description.",
												},
												"update_user_uin": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Most recent updater user ID.",
												},
												"create_user_uin": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Creator user ID.",
												},
												"task_folder_path": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Task folder path. Notes: Do not include the task node type in the path. For example, in a workflow named wf01 under the \"General\" category, if you want to create a shell task in the tf_01 folder under this category, just fill in /tf_01; If the tf_01 folder does not exist, you must create it first (using the CreateTaskFolder API) before the operation can succeed.",
												},
											},
										},
									},
									"trigger_task_configuration": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Task configuration.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"code_content": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Base64-encoded code content.",
												},
												"task_ext_configuration_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Task extended attribute configuration list.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_value": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter value.",
															},
														},
													},
												},
												"data_cluster": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Cluster ID.",
												},
												"broker_ip": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Specified execution node.",
												},
												"yarn_queue": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Resource pool queue name; must be obtained via DescribeProjectClusterQueues.",
												},
												"source_service_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Source data source ID; must be obtained via DescribeDataSourceWithoutInfo.",
												},
												"source_service_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Source data source type; must be obtained via DescribeDataSourceWithoutInfo.",
												},
												"source_service_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Source data source name; must be obtained via DescribeDataSourceWithoutInfo.",
												},
												"target_service_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Target data source ID; must be obtained via DescribeDataSourceWithoutInfo.",
												},
												"target_service_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Target data source type; must be obtained via DescribeDataSourceWithoutInfo.",
												},
												"target_service_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Target data source name; must be obtained via DescribeDataSourceWithoutInfo.",
												},
												"resource_group": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Resource group ID; must be obtained via DescribeNormalSchedulerExecutorGroups to get ExecutorGroupId.",
												},
												"resource_group_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Resource group name; must be obtained via DescribeNormalSchedulerExecutorGroups to get ExecutorGroupName.",
												},
												"task_scheduling_parameter_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Scheduling parameters.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_value": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter value.",
															},
														},
													},
												},
												"bundle_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Bundle ID in use.",
												},
												"bundle_info": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Bundle information.",
												},
											},
										},
									},
									"trigger_task_scheduler_configuration": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Task scheduling configuration.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"upstream_dependency_config_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Upstream dependency array.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"task_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Task ID.",
															},
														},
													},
												},
												"run_priority_type": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Task scheduling priority; run priority 4 high, 5 medium, 6 low; default: 6.",
												},
												"retry_wait_minute": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Retry strategy retry wait time, in minutes; default: 5.",
												},
												"max_retry_number": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Retry strategy maximum retry attempts; default: 4.",
												},
												"execution_ttl_minute": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Timeout handling strategy for execution duration timeout (minutes); default is -1.",
												},
												"wait_execution_total_ttl_minute": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Timeout handling strategy for total waiting duration timeout (minutes); default is -1.",
												},
												"allow_redo_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Re-run & backfill configuration; default is ALL; ALL allows re-run or backfill after success or failure; FAILURE disallows re-run or backfill after success but allows after failure; NONE disallows re-run or backfill after both success and failure.",
												},
												"param_task_out_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Output parameter array.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_value": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter definition.",
															},
														},
													},
												},
												"param_task_in_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Input parameter array.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter name.",
															},
															"param_desc": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parameter description; format: project identifier.task name.parameter name; example: project_wedata_1.sh_250820_104107.pp_out.",
															},
															"from_task_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parent task ID.",
															},
															"from_param_key": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Parent task parameter key.",
															},
														},
													},
												},
												"task_output_registry_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Output registration.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"datasource_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Data source ID.",
															},
															"database_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Database name.",
															},
															"table_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Table name.",
															},
															"partition_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Partition name.",
															},
															"data_flow_type": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Input/output table type: Input stream UPSTREAM, Output stream DOWNSTREAM.",
															},
															"table_physical_id": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Table physical unique ID.",
															},
															"db_guid": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Database unique identifier.",
															},
															"table_guid": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Table unique identifier.",
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataTriggerTaskVersionRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_trigger_task_version.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	var projectId string
	var taskId string
	var versionId string
	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		paramMap["ProjectId"] = helper.String(v.(string))
		projectId = v.(string)
	}

	if v, ok := d.GetOk("task_id"); ok {
		paramMap["TaskId"] = helper.String(v.(string))
		taskId = v.(string)
	}

	if v, ok := d.GetOk("version_id"); ok {
		paramMap["VersionId"] = helper.String(v.(string))
	}

	var respData *wedatav20250806.GetTriggerTaskVersionResponseParams
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataTriggerTaskVersionByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	dataMap := map[string]interface{}{}

	if respData.Data != nil {
		if respData.Data.CreateTime != nil {
			dataMap["create_time"] = respData.Data.CreateTime
		}

		if respData.Data.VersionNum != nil {
			dataMap["version_num"] = respData.Data.VersionNum
		}

		if respData.Data.CreateUserUin != nil {
			dataMap["create_user_uin"] = respData.Data.CreateUserUin
		}

		if respData.Data.VersionId != nil {
			dataMap["version_id"] = respData.Data.VersionId
			versionId = *respData.Data.VersionId
		}

		if respData.Data.VersionRemark != nil {
			dataMap["version_remark"] = respData.Data.VersionRemark
		}

		if respData.Data.ApproveStatus != nil {
			dataMap["approve_status"] = respData.Data.ApproveStatus
		}

		if respData.Data.ApproveTime != nil {
			dataMap["approve_time"] = respData.Data.ApproveTime
		}

		if respData.Data.ApproveUserUin != nil {
			dataMap["approve_user_uin"] = respData.Data.ApproveUserUin
		}

		taskMap := map[string]interface{}{}

		if respData.Data.Task != nil {
			triggerTaskBaseAttributeMap := map[string]interface{}{}

			if respData.Data.Task.TriggerTaskBaseAttribute != nil {
				if respData.Data.Task.TriggerTaskBaseAttribute.TaskId != nil {
					triggerTaskBaseAttributeMap["task_id"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskId
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.TaskTypeId != nil {
					triggerTaskBaseAttributeMap["task_type_id"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskTypeId
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.WorkflowId != nil {
					triggerTaskBaseAttributeMap["workflow_id"] = respData.Data.Task.TriggerTaskBaseAttribute.WorkflowId
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.TaskName != nil {
					triggerTaskBaseAttributeMap["task_name"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskName
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.TaskLatestVersionNo != nil {
					triggerTaskBaseAttributeMap["task_latest_version_no"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskLatestVersionNo
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.TaskLatestSubmitVersionNo != nil {
					triggerTaskBaseAttributeMap["task_latest_submit_version_no"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskLatestSubmitVersionNo
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.WorkflowName != nil {
					triggerTaskBaseAttributeMap["workflow_name"] = respData.Data.Task.TriggerTaskBaseAttribute.WorkflowName
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.Status != nil {
					triggerTaskBaseAttributeMap["status"] = respData.Data.Task.TriggerTaskBaseAttribute.Status
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.Submit != nil {
					triggerTaskBaseAttributeMap["submit"] = respData.Data.Task.TriggerTaskBaseAttribute.Submit
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.CreateTime != nil {
					triggerTaskBaseAttributeMap["create_time"] = respData.Data.Task.TriggerTaskBaseAttribute.CreateTime
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.LastUpdateTime != nil {
					triggerTaskBaseAttributeMap["last_update_time"] = respData.Data.Task.TriggerTaskBaseAttribute.LastUpdateTime
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.LastUpdateUserName != nil {
					triggerTaskBaseAttributeMap["last_update_user_name"] = respData.Data.Task.TriggerTaskBaseAttribute.LastUpdateUserName
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.LastOpsTime != nil {
					triggerTaskBaseAttributeMap["last_ops_time"] = respData.Data.Task.TriggerTaskBaseAttribute.LastOpsTime
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.LastOpsUserName != nil {
					triggerTaskBaseAttributeMap["last_ops_user_name"] = respData.Data.Task.TriggerTaskBaseAttribute.LastOpsUserName
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.OwnerUin != nil {
					triggerTaskBaseAttributeMap["owner_uin"] = respData.Data.Task.TriggerTaskBaseAttribute.OwnerUin
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.TaskDescription != nil {
					triggerTaskBaseAttributeMap["task_description"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskDescription
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.UpdateUserUin != nil {
					triggerTaskBaseAttributeMap["update_user_uin"] = respData.Data.Task.TriggerTaskBaseAttribute.UpdateUserUin
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.CreateUserUin != nil {
					triggerTaskBaseAttributeMap["create_user_uin"] = respData.Data.Task.TriggerTaskBaseAttribute.CreateUserUin
				}

				if respData.Data.Task.TriggerTaskBaseAttribute.TaskFolderPath != nil {
					triggerTaskBaseAttributeMap["task_folder_path"] = respData.Data.Task.TriggerTaskBaseAttribute.TaskFolderPath
				}

				taskMap["trigger_task_base_attribute"] = []interface{}{triggerTaskBaseAttributeMap}
			}

			triggerTaskConfigurationMap := map[string]interface{}{}

			if respData.Data.Task.TriggerTaskConfiguration != nil {
				if respData.Data.Task.TriggerTaskConfiguration.CodeContent != nil {
					triggerTaskConfigurationMap["code_content"] = respData.Data.Task.TriggerTaskConfiguration.CodeContent
				}

				taskExtConfigurationListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TriggerTaskConfiguration.TaskExtConfigurationList))
				if respData.Data.Task.TriggerTaskConfiguration.TaskExtConfigurationList != nil {
					for _, taskExtConfigurationList := range respData.Data.Task.TriggerTaskConfiguration.TaskExtConfigurationList {
						taskExtConfigurationListMap := map[string]interface{}{}

						if taskExtConfigurationList.ParamKey != nil {
							taskExtConfigurationListMap["param_key"] = taskExtConfigurationList.ParamKey
						}

						if taskExtConfigurationList.ParamValue != nil {
							taskExtConfigurationListMap["param_value"] = taskExtConfigurationList.ParamValue
						}

						taskExtConfigurationListList = append(taskExtConfigurationListList, taskExtConfigurationListMap)
					}

					triggerTaskConfigurationMap["task_ext_configuration_list"] = taskExtConfigurationListList
				}
				if respData.Data.Task.TriggerTaskConfiguration.DataCluster != nil {
					triggerTaskConfigurationMap["data_cluster"] = respData.Data.Task.TriggerTaskConfiguration.DataCluster
				}

				if respData.Data.Task.TriggerTaskConfiguration.BrokerIp != nil {
					triggerTaskConfigurationMap["broker_ip"] = respData.Data.Task.TriggerTaskConfiguration.BrokerIp
				}

				if respData.Data.Task.TriggerTaskConfiguration.YarnQueue != nil {
					triggerTaskConfigurationMap["yarn_queue"] = respData.Data.Task.TriggerTaskConfiguration.YarnQueue
				}

				if respData.Data.Task.TriggerTaskConfiguration.SourceServiceId != nil {
					triggerTaskConfigurationMap["source_service_id"] = respData.Data.Task.TriggerTaskConfiguration.SourceServiceId
				}

				if respData.Data.Task.TriggerTaskConfiguration.SourceServiceType != nil {
					triggerTaskConfigurationMap["source_service_type"] = respData.Data.Task.TriggerTaskConfiguration.SourceServiceType
				}

				if respData.Data.Task.TriggerTaskConfiguration.SourceServiceName != nil {
					triggerTaskConfigurationMap["source_service_name"] = respData.Data.Task.TriggerTaskConfiguration.SourceServiceName
				}

				if respData.Data.Task.TriggerTaskConfiguration.TargetServiceId != nil {
					triggerTaskConfigurationMap["target_service_id"] = respData.Data.Task.TriggerTaskConfiguration.TargetServiceId
				}

				if respData.Data.Task.TriggerTaskConfiguration.TargetServiceType != nil {
					triggerTaskConfigurationMap["target_service_type"] = respData.Data.Task.TriggerTaskConfiguration.TargetServiceType
				}

				if respData.Data.Task.TriggerTaskConfiguration.TargetServiceName != nil {
					triggerTaskConfigurationMap["target_service_name"] = respData.Data.Task.TriggerTaskConfiguration.TargetServiceName
				}

				if respData.Data.Task.TriggerTaskConfiguration.ResourceGroup != nil {
					triggerTaskConfigurationMap["resource_group"] = respData.Data.Task.TriggerTaskConfiguration.ResourceGroup
				}

				if respData.Data.Task.TriggerTaskConfiguration.ResourceGroupName != nil {
					triggerTaskConfigurationMap["resource_group_name"] = respData.Data.Task.TriggerTaskConfiguration.ResourceGroupName
				}

				taskSchedulingParameterListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TriggerTaskConfiguration.TaskSchedulingParameterList))
				if respData.Data.Task.TriggerTaskConfiguration.TaskSchedulingParameterList != nil {
					for _, taskSchedulingParameterList := range respData.Data.Task.TriggerTaskConfiguration.TaskSchedulingParameterList {
						taskSchedulingParameterListMap := map[string]interface{}{}

						if taskSchedulingParameterList.ParamKey != nil {
							taskSchedulingParameterListMap["param_key"] = taskSchedulingParameterList.ParamKey
						}

						if taskSchedulingParameterList.ParamValue != nil {
							taskSchedulingParameterListMap["param_value"] = taskSchedulingParameterList.ParamValue
						}

						taskSchedulingParameterListList = append(taskSchedulingParameterListList, taskSchedulingParameterListMap)
					}

					triggerTaskConfigurationMap["task_scheduling_parameter_list"] = taskSchedulingParameterListList
				}
				if respData.Data.Task.TriggerTaskConfiguration.BundleId != nil {
					triggerTaskConfigurationMap["bundle_id"] = respData.Data.Task.TriggerTaskConfiguration.BundleId
				}

				if respData.Data.Task.TriggerTaskConfiguration.BundleInfo != nil {
					triggerTaskConfigurationMap["bundle_info"] = respData.Data.Task.TriggerTaskConfiguration.BundleInfo
				}

				taskMap["trigger_task_configuration"] = []interface{}{triggerTaskConfigurationMap}
			}

			triggerTaskSchedulerConfigurationMap := map[string]interface{}{}

			if respData.Data.Task.TriggerTaskSchedulerConfiguration != nil {
				upstreamDependencyConfigListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TriggerTaskSchedulerConfiguration.UpstreamDependencyConfigList))
				if respData.Data.Task.TriggerTaskSchedulerConfiguration.UpstreamDependencyConfigList != nil {
					for _, upstreamDependencyConfigList := range respData.Data.Task.TriggerTaskSchedulerConfiguration.UpstreamDependencyConfigList {
						upstreamDependencyConfigListMap := map[string]interface{}{}

						if upstreamDependencyConfigList.TaskId != nil {
							upstreamDependencyConfigListMap["task_id"] = upstreamDependencyConfigList.TaskId
						}

						upstreamDependencyConfigListList = append(upstreamDependencyConfigListList, upstreamDependencyConfigListMap)
					}

					triggerTaskSchedulerConfigurationMap["upstream_dependency_config_list"] = upstreamDependencyConfigListList
				}
				if respData.Data.Task.TriggerTaskSchedulerConfiguration.RunPriorityType != nil {
					triggerTaskSchedulerConfigurationMap["run_priority_type"] = respData.Data.Task.TriggerTaskSchedulerConfiguration.RunPriorityType
				}

				if respData.Data.Task.TriggerTaskSchedulerConfiguration.RetryWaitMinute != nil {
					triggerTaskSchedulerConfigurationMap["retry_wait_minute"] = respData.Data.Task.TriggerTaskSchedulerConfiguration.RetryWaitMinute
				}

				if respData.Data.Task.TriggerTaskSchedulerConfiguration.MaxRetryNumber != nil {
					triggerTaskSchedulerConfigurationMap["max_retry_number"] = respData.Data.Task.TriggerTaskSchedulerConfiguration.MaxRetryNumber
				}

				if respData.Data.Task.TriggerTaskSchedulerConfiguration.ExecutionTTLMinute != nil {
					triggerTaskSchedulerConfigurationMap["execution_ttl_minute"] = respData.Data.Task.TriggerTaskSchedulerConfiguration.ExecutionTTLMinute
				}

				if respData.Data.Task.TriggerTaskSchedulerConfiguration.WaitExecutionTotalTTLMinute != nil {
					triggerTaskSchedulerConfigurationMap["wait_execution_total_ttl_minute"] = respData.Data.Task.TriggerTaskSchedulerConfiguration.WaitExecutionTotalTTLMinute
				}

				if respData.Data.Task.TriggerTaskSchedulerConfiguration.AllowRedoType != nil {
					triggerTaskSchedulerConfigurationMap["allow_redo_type"] = respData.Data.Task.TriggerTaskSchedulerConfiguration.AllowRedoType
				}

				paramTaskOutListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TriggerTaskSchedulerConfiguration.ParamTaskOutList))
				if respData.Data.Task.TriggerTaskSchedulerConfiguration.ParamTaskOutList != nil {
					for _, paramTaskOutList := range respData.Data.Task.TriggerTaskSchedulerConfiguration.ParamTaskOutList {
						paramTaskOutListMap := map[string]interface{}{}

						if paramTaskOutList.ParamKey != nil {
							paramTaskOutListMap["param_key"] = paramTaskOutList.ParamKey
						}

						if paramTaskOutList.ParamValue != nil {
							paramTaskOutListMap["param_value"] = paramTaskOutList.ParamValue
						}

						paramTaskOutListList = append(paramTaskOutListList, paramTaskOutListMap)
					}

					triggerTaskSchedulerConfigurationMap["param_task_out_list"] = paramTaskOutListList
				}
				paramTaskInListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TriggerTaskSchedulerConfiguration.ParamTaskInList))
				if respData.Data.Task.TriggerTaskSchedulerConfiguration.ParamTaskInList != nil {
					for _, paramTaskInList := range respData.Data.Task.TriggerTaskSchedulerConfiguration.ParamTaskInList {
						paramTaskInListMap := map[string]interface{}{}

						if paramTaskInList.ParamKey != nil {
							paramTaskInListMap["param_key"] = paramTaskInList.ParamKey
						}

						if paramTaskInList.ParamDesc != nil {
							paramTaskInListMap["param_desc"] = paramTaskInList.ParamDesc
						}

						if paramTaskInList.FromTaskId != nil {
							paramTaskInListMap["from_task_id"] = paramTaskInList.FromTaskId
						}

						if paramTaskInList.FromParamKey != nil {
							paramTaskInListMap["from_param_key"] = paramTaskInList.FromParamKey
						}

						paramTaskInListList = append(paramTaskInListList, paramTaskInListMap)
					}

					triggerTaskSchedulerConfigurationMap["param_task_in_list"] = paramTaskInListList
				}
				taskOutputRegistryListList := make([]map[string]interface{}, 0, len(respData.Data.Task.TriggerTaskSchedulerConfiguration.TaskOutputRegistryList))
				if respData.Data.Task.TriggerTaskSchedulerConfiguration.TaskOutputRegistryList != nil {
					for _, taskOutputRegistryList := range respData.Data.Task.TriggerTaskSchedulerConfiguration.TaskOutputRegistryList {
						taskOutputRegistryListMap := map[string]interface{}{}

						if taskOutputRegistryList.DatasourceId != nil {
							taskOutputRegistryListMap["datasource_id"] = taskOutputRegistryList.DatasourceId
						}

						if taskOutputRegistryList.DatabaseName != nil {
							taskOutputRegistryListMap["database_name"] = taskOutputRegistryList.DatabaseName
						}

						if taskOutputRegistryList.TableName != nil {
							taskOutputRegistryListMap["table_name"] = taskOutputRegistryList.TableName
						}

						if taskOutputRegistryList.PartitionName != nil {
							taskOutputRegistryListMap["partition_name"] = taskOutputRegistryList.PartitionName
						}

						if taskOutputRegistryList.DataFlowType != nil {
							taskOutputRegistryListMap["data_flow_type"] = taskOutputRegistryList.DataFlowType
						}

						if taskOutputRegistryList.TablePhysicalId != nil {
							taskOutputRegistryListMap["table_physical_id"] = taskOutputRegistryList.TablePhysicalId
						}

						if taskOutputRegistryList.DbGuid != nil {
							taskOutputRegistryListMap["db_guid"] = taskOutputRegistryList.DbGuid
						}

						if taskOutputRegistryList.TableGuid != nil {
							taskOutputRegistryListMap["table_guid"] = taskOutputRegistryList.TableGuid
						}

						taskOutputRegistryListList = append(taskOutputRegistryListList, taskOutputRegistryListMap)
					}

					triggerTaskSchedulerConfigurationMap["task_output_registry_list"] = taskOutputRegistryListList
				}
				taskMap["trigger_task_scheduler_configuration"] = []interface{}{triggerTaskSchedulerConfigurationMap}
			}

			dataMap["task"] = []interface{}{taskMap}
		}

		_ = d.Set("data", []interface{}{dataMap})
	}

	d.SetId(strings.Join([]string{projectId, taskId, versionId}, tccommon.FILED_SP))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
