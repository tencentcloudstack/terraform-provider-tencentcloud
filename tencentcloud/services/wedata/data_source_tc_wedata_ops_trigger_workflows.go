// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataOpsTriggerWorkflows() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataOpsTriggerWorkflowsRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project ID.",
			},

			"filters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Filter parameters. Workflow name or ID query name: `Keyword`; workflow ID query name: `WorkflowId`; folder query name: `FolderId`; owner query name: `InChargeUin`.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Filter field name.",
						},
						"values": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "List of filter values.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"order_fields": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Sort fields. Sort field names include, for example, task count: TaskCount.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Sort field name.",
						},
						"direction": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Sort direction: ASC|DESC.",
						},
					},
				},
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Workflow query results.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"total_count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Total record count.",
						},
						"total_page_number": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Number of pages.",
						},
						"page_number": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Page number.",
						},
						"page_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Page size.",
						},
						"items": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Collection of workflow information.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"project_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Project ID.",
									},
									"workflow_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow ID.",
									},
									"workflow_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow name.",
									},
									"task_count": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Number of tasks.",
									},
									"folder_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Folder ID.",
									},
									"folder_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Folder name.",
									},
									"workflow_trigger_config": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Scheduling configuration.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"trigger_mode": {
													Type:        schema.TypeString,
													Required:    true,
													Description: "Trigger mode. Scheduled trigger: `TIME_TRIGGER`; Continuous run: `CONTINUE_RUN`; File arrival: `FILE_ARRIVAL`. In TIME_TRIGGER and CONTINUE_RUN modes, SchedulerStatus, SchedulerTimeZone, StartTime, EndTime, ConfigMode, CycleType, and CrontabExpression are required. In FILE_ARRIVAL mode, FileArrivalPath, TriggerMinimumIntervalSecond, and TriggerWaitTimeSecond are required.",
												},
												"extra_info": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "WorkflowTriggerConfig converted to JSON format, used for reconciliation.",
												},
												"schedule_time_zone": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Scheduling time zone.",
												},
												"start_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Schedule effective start time.",
												},
												"end_time": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Schedule end time.",
												},
												"config_mode": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Configuration mode, common: COMMON; cron expression: CRON_EXPRESSION.",
												},
												"cycle_type": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Cycle type. Supported types: `ONEOFF_CYCLE`: one-time; `YEAR_CYCLE`: year; `MONTH_CYCLE`: month; `WEEK_CYCLE`: week; `DAY_CYCLE`: day; `HOUR_CYCLE`: hour; `MINUTE_CYCLE`: minute; `CRONTAB_CYCLE`: crontab expression type.",
												},
												"crontab_expression": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Cron expression.",
												},
												"trigger_id": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Trigger ID, UUID.",
												},
												"file_arrival_path": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "In file arrival mode, the listening path in the storage system.",
												},
												"trigger_minimum_interval_second": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "In file arrival mode, minimum trigger interval (seconds).",
												},
												"trigger_wait_time_second": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "In file arrival mode, trigger wait time (seconds).",
												},
												"scheduler_status": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: "Trigger status: start `ACTIVE`, pause `PAUSED`.",
												},
											},
										},
									},
									"user_name_in_charge": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Person in charge.",
									},
									"user_uin_in_charge": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Person in charge ID.",
									},
									"workflow_params": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Workflow parameters.",
									},
								},
							},
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataOpsTriggerWorkflowsRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_ops_trigger_workflows.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		paramMap["ProjectId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("filters"); ok {
		filtersSet := v.([]interface{})
		tmpSet := make([]*wedatav20250806.Filter, 0, len(filtersSet))
		for _, item := range filtersSet {
			filtersMap := item.(map[string]interface{})
			filter := wedatav20250806.Filter{}
			if v, ok := filtersMap["name"].(string); ok && v != "" {
				filter.Name = helper.String(v)
			}
			if v, ok := filtersMap["values"]; ok {
				valuesSet := v.(*schema.Set).List()
				for i := range valuesSet {
					values := valuesSet[i].(string)
					filter.Values = append(filter.Values, helper.String(values))
				}
			}
			tmpSet = append(tmpSet, &filter)
		}
		paramMap["Filters"] = tmpSet
	}

	if v, ok := d.GetOk("order_fields"); ok {
		orderFieldsSet := v.([]interface{})
		tmpSet := make([]*wedatav20250806.OrderField, 0, len(orderFieldsSet))
		for _, item := range orderFieldsSet {
			orderFieldsMap := item.(map[string]interface{})
			orderField := wedatav20250806.OrderField{}
			if v, ok := orderFieldsMap["name"].(string); ok && v != "" {
				orderField.Name = helper.String(v)
			}
			if v, ok := orderFieldsMap["direction"].(string); ok && v != "" {
				orderField.Direction = helper.String(v)
			}
			tmpSet = append(tmpSet, &orderField)
		}
		paramMap["OrderFields"] = tmpSet
	}

	var respData []*wedatav20250806.TriggerWorkflowBrief
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataOpsTriggerWorkflowsByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	ids := make([]string, 0, len(respData))
	dataMap := map[string]interface{}{}

	if len(respData) > 0 {
		itemsList := make([]map[string]interface{}, 0, len(respData))
		for _, items := range respData {
			itemsMap := map[string]interface{}{}

			if items.ProjectId != nil {
				itemsMap["project_id"] = items.ProjectId
			}

			if items.WorkflowId != nil {
				itemsMap["workflow_id"] = items.WorkflowId
				ids = append(ids, *items.WorkflowId)
			}

			if items.WorkflowName != nil {
				itemsMap["workflow_name"] = items.WorkflowName
			}

			if items.TaskCount != nil {
				itemsMap["task_count"] = items.TaskCount
			}

			if items.FolderId != nil {
				itemsMap["folder_id"] = items.FolderId
			}

			if items.FolderName != nil {
				itemsMap["folder_name"] = items.FolderName
			}

			workflowTriggerConfigMap := map[string]interface{}{}

			if items.WorkflowTriggerConfig != nil {
				if items.WorkflowTriggerConfig.TriggerMode != nil {
					workflowTriggerConfigMap["trigger_mode"] = items.WorkflowTriggerConfig.TriggerMode
				}

				if items.WorkflowTriggerConfig.ExtraInfo != nil {
					workflowTriggerConfigMap["extra_info"] = items.WorkflowTriggerConfig.ExtraInfo
				}

				if items.WorkflowTriggerConfig.ScheduleTimeZone != nil {
					workflowTriggerConfigMap["schedule_time_zone"] = items.WorkflowTriggerConfig.ScheduleTimeZone
				}

				if items.WorkflowTriggerConfig.StartTime != nil {
					workflowTriggerConfigMap["start_time"] = items.WorkflowTriggerConfig.StartTime
				}

				if items.WorkflowTriggerConfig.EndTime != nil {
					workflowTriggerConfigMap["end_time"] = items.WorkflowTriggerConfig.EndTime
				}

				if items.WorkflowTriggerConfig.ConfigMode != nil {
					workflowTriggerConfigMap["config_mode"] = items.WorkflowTriggerConfig.ConfigMode
				}

				if items.WorkflowTriggerConfig.CycleType != nil {
					workflowTriggerConfigMap["cycle_type"] = items.WorkflowTriggerConfig.CycleType
				}

				if items.WorkflowTriggerConfig.CrontabExpression != nil {
					workflowTriggerConfigMap["crontab_expression"] = items.WorkflowTriggerConfig.CrontabExpression
				}

				if items.WorkflowTriggerConfig.TriggerId != nil {
					workflowTriggerConfigMap["trigger_id"] = items.WorkflowTriggerConfig.TriggerId
				}

				if items.WorkflowTriggerConfig.FileArrivalPath != nil {
					workflowTriggerConfigMap["file_arrival_path"] = items.WorkflowTriggerConfig.FileArrivalPath
				}

				if items.WorkflowTriggerConfig.TriggerMinimumIntervalSecond != nil {
					workflowTriggerConfigMap["trigger_minimum_interval_second"] = items.WorkflowTriggerConfig.TriggerMinimumIntervalSecond
				}

				if items.WorkflowTriggerConfig.TriggerWaitTimeSecond != nil {
					workflowTriggerConfigMap["trigger_wait_time_second"] = items.WorkflowTriggerConfig.TriggerWaitTimeSecond
				}

				if items.WorkflowTriggerConfig.SchedulerStatus != nil {
					workflowTriggerConfigMap["scheduler_status"] = items.WorkflowTriggerConfig.SchedulerStatus
				}

				itemsMap["workflow_trigger_config"] = []interface{}{workflowTriggerConfigMap}
			}

			if items.UserNameInCharge != nil {
				itemsMap["user_name_in_charge"] = items.UserNameInCharge
			}

			if items.UserUinInCharge != nil {
				itemsMap["user_uin_in_charge"] = items.UserUinInCharge
			}

			if items.WorkflowParams != nil {
				itemsMap["workflow_params"] = items.WorkflowParams
			}

			itemsList = append(itemsList, itemsMap)
		}

		dataMap["items"] = itemsList
	}

	d.SetId(helper.DataResourceIdsHash(ids))
	_ = d.Set("data", []interface{}{dataMap})

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
