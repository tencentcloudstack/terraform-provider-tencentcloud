// Code generated by iacg; DO NOT EDIT.
package wedata

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	wedatav20250806 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/wedata/v20250806"
	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudWedataOpsAlarmRules() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudWedataOpsAlarmRulesRead,
		Schema: map[string]*schema.Schema{
			"project_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Project id.",
			},

			"monitor_object_type": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Monitoring object type, Task dimension monitoring: can be configured according to task/workflow/project: 1.Task, 2.Workflow, 3.Project (default is 1.Task) Project dimension monitoring: Project overall task fluctuation alarm, 7: Project fluctuation monitoring alarm.",
			},

			"task_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Query alarm rules based on task ID.",
			},

			"alarm_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold. Example value: [\"failure\"].",
			},

			"alarm_level": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Alarm level: 1. Normal, 2. Major, 3. Urgent.",
			},

			"alarm_recipient_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Query the alarm rules configured for the corresponding alarm recipient.",
			},

			"keyword": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Query the corresponding alarm rule based on the alarm rule ID/rule name.",
			},

			"create_user_uin": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Alarm rule creator filtering.",
			},

			"create_time_from": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The start time of the alarm rule creation time range, in the format of 2025-08-17 00:00:00.",
			},

			"create_time_to": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The end time of the alarm rule creation time range, in the format of \"2025-08-26 23:59:59\".",
			},

			"update_time_from": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Last updated time filter alarm rules, format such as \"2025-08-26 00:00:00\".",
			},

			"update_time_to": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Last updated time filter alarm rule format such as: \"2025-08-26 23:59:59\".",
			},

			"data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Alarm information response.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"page_number": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The number of pages in the pagination, the current page number.",
						},
						"page_size": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Number of items displayed per page.",
						},
						"total_page_number": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "Total number of pages.",
						},
						"total_count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: "The total number of alarm rules.",
						},
						"items": {
							Type:        schema.TypeList,
							Required:    true,
							Description: "Alarm rule information list.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"alarm_rule_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Alarm rule ID.",
									},
									"alarm_rule_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Alarm rule name.",
									},
									"description": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Alarm rule description.",
									},
									"monitor_object_type": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Monitoring object type, Task-based monitoring: Configurable by task/workflow/project: 1. Task, 2. Workflow, 3. Project (default is 1. Task). Project-based monitoring: Alerts for overall project task fluctuations, 7: Project fluctuation monitoring alerts.",
									},
									"monitor_object_ids": {
										Type:        schema.TypeSet,
										Required:    true,
										Description: "A list of monitored object business IDs. Different business IDs are passed in based on the MonitorType setting. For example, 1 (Task) - MonitorObjectIds is a list of task IDs; 2 (Workflow) - MonitorObjectIds is a list of workflow IDs (workflow IDs can be obtained from the ListWorkflows interface); 3 (Project) - MonitorObjectIds is a list of project IDs.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"alarm_types": {
										Type:        schema.TypeSet,
										Required:    true,
										Description: "Alarm Rule Monitoring Types: failure: failure alarm; overtime: timeout alarm; success: success alarm; backTrackingOrRerunSuccess: backTrackingOrRerunSuccess: backTrackingOrRerunFailure: backTrackingOrRerunFailure. Project Fluctuation Alarms: projectFailureInstanceUpwardFluctuationAlarm: alarm if the upward fluctuation rate of failed instances exceeds the threshold. projectSuccessInstanceDownwardFluctuationAlarm: alarm if the downward fluctuation rate of successful instances exceeds the threshold. Offline Integration Task Reconciliation Alarms: reconciliationFailure: offline reconciliation task failure alarm; reconciliationOvertime: offline reconciliation task timeout alarm; reconciliationMismatch: alarm if the number of inconsistent entries in a data reconciliation task exceeds the threshold.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"status": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Whether the alarm rule is enabled: 0-disable, 1-enable.",
									},
									"alarm_rule_detail": {
										Type:        schema.TypeList,
										Required:    true,
										MaxItems:    1,
										Description: "Alarm rule configuration information: Success alarms do not require configuration. Failure alarms can be configured as either first-failure alarms or all retry failure alarms. Timeout configuration requires the timeout type and timeout threshold. Project fluctuation alarms require the fluctuation rate and anti-shake period.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"trigger": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Failure trigger timing: 1 - Triggered on first failure; 2 -- Triggered when all retries complete (default).",
												},
												"data_backfill_or_rerun_trigger": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Re-recording trigger timing: 1 - Triggered by the first failure; 2 - Triggered by completion of all retries.",
												},
												"time_out_ext_info": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Periodic instance timeout configuration details.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"rule_type": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.",
															},
															"type": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Timeout value configuration type: 1-Specified value; 2-Average value.",
															},
															"hour": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Specify the timeout value in hours. The default value is 0.",
															},
															"min": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "The timeout value is specified in minutes. The default value is 1.",
															},
															"schedule_time_zone": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.",
															},
														},
													},
												},
												"data_backfill_or_rerun_time_out_ext_info": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Detailed configuration of re-running and re-recording instance timeout.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"rule_type": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Timeout alarm configuration: 1. Estimated running time exceeded, 2. Estimated completion time exceeded, 3. Estimated waiting time for scheduling exceeded, 4. Estimated completion within the period but not completed.",
															},
															"type": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Timeout value configuration type: 1-Specified value; 2-Average value.",
															},
															"hour": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Specify the timeout value in hours. The default value is 0.",
															},
															"min": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "The timeout value is specified in minutes. The default value is 1.",
															},
															"schedule_time_zone": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "The time zone configuration corresponding to the timeout period, such as UTC+7, the default is UTC+8.",
															},
														},
													},
												},
												"project_instance_statistics_alarm_info_list": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Project fluctuation alarm configuration details.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"alarm_type": {
																Type:        schema.TypeString,
																Required:    true,
																Description: "Alarm type: projectFailureInstanceUpwardFluctuationAlarm: Failure instance upward fluctuation alarm; projectSuccessInstanceDownwardFluctuationAlarm: Success instance downward fluctuation alarm.",
															},
															"instance_threshold_count_percent": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "The alarm threshold for the proportion of instance successes fluctuating downwards; the alarm threshold for the proportion of instance failures fluctuating upwards.",
															},
															"instance_threshold_count": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "The cumulative instance number fluctuation threshold.",
															},
															"stabilize_threshold": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Stability threshold (number of statistical cycles for anti-shake configuration).",
															},
															"stabilize_statistics_cycle": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Stability statistics period (number of anti-shake configuration statistics periods).",
															},
															"is_cumulant": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: "Whether to calculate cumulatively, false: continuous, true: cumulative.",
															},
															"instance_count": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "The cumulative number of instances on the day; the downward fluctuation of the number of failed instances on the day.",
															},
														},
													},
												},
												"reconciliation_ext_info": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "Offline integrated reconciliation alarm configuration information.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"rule_type": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Offline alarm rule types: reconciliationFailure: Offline reconciliation failure alarm; reconciliationOvertime: Offline reconciliation task timeout alarm (timeout must be configured); reconciliationMismatch: Offline reconciliation mismatch alarm (mismatch threshold must be configured).",
															},
															"mismatch_count": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Reconciliation inconsistency threshold, RuleType=reconciliationMismatch. This field needs to be configured and has no default value.",
															},
															"hour": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Reconciliation task timeout threshold: hours, default is 0.",
															},
															"min": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Reconciliation task timeout threshold: minutes, default is 1.",
															},
														},
													},
												},
											},
										},
									},
									"alarm_level": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Alarm level: 1. Normal, 2. Major, 3. Urgent.",
									},
									"owner_uin": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Alarm rule creator uid.",
									},
									"bundle_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Alarm rules bound to the bundle client: If it is empty, it is a normal alarm rule; if it is not empty, it corresponds to the rule bound to the bundle client.",
									},
									"bundle_info": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "If bundleId is not empty, it indicates the name of the bound bundle client.",
									},
									"alarm_groups": {
										Type:        schema.TypeList,
										Required:    true,
										Description: "Alarm recipient configuration list.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"alarm_escalation_recipient_ids": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: "Alarm escalator ID list. If the alarm receiver or the upper escalator does not confirm the alarm within the alarm interval, the alarm will be sent to the next level escalator.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"alarm_escalation_interval": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Alarm escalation interval.",
												},
												"notification_fatigue": {
													Type:        schema.TypeList,
													Optional:    true,
													MaxItems:    1,
													Description: "Alarm notification fatigue configuration.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"notify_count": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Number of alarms.",
															},
															"notify_interval": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: "Alarm interval, in minutes.",
															},
															"quiet_intervals": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: "Do not disturb time, for example, the example value [{DaysOfWeek: [1, 2], StartTime: \"00:00:00\", EndTime: \"09:00:00\"}] means do not disturb from 00:00 to 09:00 every Monday and Tuesday.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"days_of_week": {
																			Type:        schema.TypeSet,
																			Optional:    true,
																			Description: "According to the ISO standard, 1 represents Monday and 7 represents Sunday.",
																			Elem: &schema.Schema{
																				Type: schema.TypeInt,
																			},
																		},
																		"start_time": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: "Start time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.",
																		},
																		"end_time": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: "End time, with precision of hours, minutes, and seconds, in the format of HH:mm:ss.",
																		},
																	},
																},
															},
														},
													},
												},
												"alarm_ways": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: "Alert Channels: 1: Email, 2: SMS, 3: WeChat, 4: Voice, 5: WeChat Enterprise, 6: Http, 7: WeChat Enterprise Group, 8: Lark Group, 9: DingTalk Group, 10: Slack Group, 11: Teams Group (Default: Email), Only one channel can be selected.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"web_hooks": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: "List of webhook addresses for corporate WeChat groups, Feishu groups, DingTalk groups, Slack groups, and Teams groups.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"alarm_way": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: "Alert channel value: 7. Enterprise WeChat group, 8. Feishu group, 9. DingTalk group, 10. Slack group, 11. Teams group.",
															},
															"web_hooks": {
																Type:        schema.TypeSet,
																Optional:    true,
																Description: "List of webhook addresses for the alarm group.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
												"alarm_recipient_type": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: "Alarm Recipient Type: 1. Designated Personnel, 2. Task Responsible Personnel, 3. Duty Roster (Default: 1. Designated Personnel).",
												},
												"alarm_recipient_ids": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: "Depending on the type of AlarmRecipientType, this list has different business IDs: 1 (Specified Person): Alarm Recipient ID List; 2 (Task Responsible Person): No configuration required; 3 (Duty Roster): Duty Roster ID List.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudWedataOpsAlarmRulesRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_wedata_ops_alarm_rules.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := WedataService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("project_id"); ok {
		paramMap["ProjectId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("monitor_object_type"); ok {
		paramMap["MonitorObjectType"] = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOk("task_id"); ok {
		paramMap["TaskId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("alarm_type"); ok {
		paramMap["AlarmType"] = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("alarm_level"); ok {
		paramMap["AlarmLevel"] = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOk("alarm_recipient_id"); ok {
		paramMap["AlarmRecipientId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("keyword"); ok {
		paramMap["Keyword"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("create_user_uin"); ok {
		paramMap["CreateUserUin"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("create_time_from"); ok {
		paramMap["CreateTimeFrom"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("create_time_to"); ok {
		paramMap["CreateTimeTo"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("update_time_from"); ok {
		paramMap["UpdateTimeFrom"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("update_time_to"); ok {
		paramMap["UpdateTimeTo"] = helper.String(v.(string))
	}

	var respData *wedatav20250806.ListOpsAlarmRulesResponseParams
	reqErr := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeWedataOpsAlarmRulesByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if reqErr != nil {
		return reqErr
	}

	var projectId string
	var alarmRuleId string
	dataMap := map[string]interface{}{}
	ids := []string{}
	if respData.Data != nil {
		if respData.Data.PageNumber != nil {
			dataMap["page_number"] = respData.Data.PageNumber
		}

		if respData.Data.PageSize != nil {
			dataMap["page_size"] = respData.Data.PageSize
		}

		if respData.Data.TotalPageNumber != nil {
			dataMap["total_page_number"] = respData.Data.TotalPageNumber
		}

		if respData.Data.TotalCount != nil {
			dataMap["total_count"] = respData.Data.TotalCount
		}

		itemsList := make([]map[string]interface{}, 0, len(respData.Data.Items))
		if respData.Data.Items != nil {
			for _, items := range respData.Data.Items {
				itemsMap := map[string]interface{}{}

				if items.AlarmRuleId != nil {
					itemsMap["alarm_rule_id"] = items.AlarmRuleId
					alarmRuleId = *items.AlarmRuleId
				}

				if items.AlarmRuleName != nil {
					itemsMap["alarm_rule_name"] = items.AlarmRuleName
				}

				if items.Description != nil {
					itemsMap["description"] = items.Description
				}

				if items.MonitorObjectType != nil {
					itemsMap["monitor_object_type"] = items.MonitorObjectType
				}

				if items.MonitorObjectIds != nil {
					itemsMap["monitor_object_ids"] = items.MonitorObjectIds
				}

				if items.AlarmTypes != nil {
					itemsMap["alarm_types"] = items.AlarmTypes
				}

				if items.Status != nil {
					itemsMap["status"] = items.Status
				}

				alarmRuleDetailMap := map[string]interface{}{}

				if items.AlarmRuleDetail != nil {
					if items.AlarmRuleDetail.Trigger != nil {
						alarmRuleDetailMap["trigger"] = items.AlarmRuleDetail.Trigger
					}

					if items.AlarmRuleDetail.DataBackfillOrRerunTrigger != nil {
						alarmRuleDetailMap["data_backfill_or_rerun_trigger"] = items.AlarmRuleDetail.DataBackfillOrRerunTrigger
					}

					timeOutExtInfoList := make([]map[string]interface{}, 0, len(items.AlarmRuleDetail.TimeOutExtInfo))
					if items.AlarmRuleDetail.TimeOutExtInfo != nil {
						for _, timeOutExtInfo := range items.AlarmRuleDetail.TimeOutExtInfo {
							timeOutExtInfoMap := map[string]interface{}{}

							if timeOutExtInfo.RuleType != nil {
								timeOutExtInfoMap["rule_type"] = timeOutExtInfo.RuleType
							}

							if timeOutExtInfo.Type != nil {
								timeOutExtInfoMap["type"] = timeOutExtInfo.Type
							}

							if timeOutExtInfo.Hour != nil {
								timeOutExtInfoMap["hour"] = timeOutExtInfo.Hour
							}

							if timeOutExtInfo.Min != nil {
								timeOutExtInfoMap["min"] = timeOutExtInfo.Min
							}

							if timeOutExtInfo.ScheduleTimeZone != nil {
								timeOutExtInfoMap["schedule_time_zone"] = timeOutExtInfo.ScheduleTimeZone
							}

							timeOutExtInfoList = append(timeOutExtInfoList, timeOutExtInfoMap)
						}

						alarmRuleDetailMap["time_out_ext_info"] = timeOutExtInfoList
					}
					dataBackfillOrRerunTimeOutExtInfoList := make([]map[string]interface{}, 0, len(items.AlarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo))
					if items.AlarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo != nil {
						for _, dataBackfillOrRerunTimeOutExtInfo := range items.AlarmRuleDetail.DataBackfillOrRerunTimeOutExtInfo {
							dataBackfillOrRerunTimeOutExtInfoMap := map[string]interface{}{}

							if dataBackfillOrRerunTimeOutExtInfo.RuleType != nil {
								dataBackfillOrRerunTimeOutExtInfoMap["rule_type"] = dataBackfillOrRerunTimeOutExtInfo.RuleType
							}

							if dataBackfillOrRerunTimeOutExtInfo.Type != nil {
								dataBackfillOrRerunTimeOutExtInfoMap["type"] = dataBackfillOrRerunTimeOutExtInfo.Type
							}

							if dataBackfillOrRerunTimeOutExtInfo.Hour != nil {
								dataBackfillOrRerunTimeOutExtInfoMap["hour"] = dataBackfillOrRerunTimeOutExtInfo.Hour
							}

							if dataBackfillOrRerunTimeOutExtInfo.Min != nil {
								dataBackfillOrRerunTimeOutExtInfoMap["min"] = dataBackfillOrRerunTimeOutExtInfo.Min
							}

							if dataBackfillOrRerunTimeOutExtInfo.ScheduleTimeZone != nil {
								dataBackfillOrRerunTimeOutExtInfoMap["schedule_time_zone"] = dataBackfillOrRerunTimeOutExtInfo.ScheduleTimeZone
							}

							dataBackfillOrRerunTimeOutExtInfoList = append(dataBackfillOrRerunTimeOutExtInfoList, dataBackfillOrRerunTimeOutExtInfoMap)
						}

						alarmRuleDetailMap["data_backfill_or_rerun_time_out_ext_info"] = dataBackfillOrRerunTimeOutExtInfoList
					}
					projectInstanceStatisticsAlarmInfoListList := make([]map[string]interface{}, 0, len(items.AlarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList))
					if items.AlarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList != nil {
						for _, projectInstanceStatisticsAlarmInfoList := range items.AlarmRuleDetail.ProjectInstanceStatisticsAlarmInfoList {
							projectInstanceStatisticsAlarmInfoListMap := map[string]interface{}{}

							if projectInstanceStatisticsAlarmInfoList.AlarmType != nil {
								projectInstanceStatisticsAlarmInfoListMap["alarm_type"] = projectInstanceStatisticsAlarmInfoList.AlarmType
							}

							if projectInstanceStatisticsAlarmInfoList.InstanceThresholdCountPercent != nil {
								projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count_percent"] = projectInstanceStatisticsAlarmInfoList.InstanceThresholdCountPercent
							}

							if projectInstanceStatisticsAlarmInfoList.InstanceThresholdCount != nil {
								projectInstanceStatisticsAlarmInfoListMap["instance_threshold_count"] = projectInstanceStatisticsAlarmInfoList.InstanceThresholdCount
							}

							if projectInstanceStatisticsAlarmInfoList.StabilizeThreshold != nil {
								projectInstanceStatisticsAlarmInfoListMap["stabilize_threshold"] = projectInstanceStatisticsAlarmInfoList.StabilizeThreshold
							}

							if projectInstanceStatisticsAlarmInfoList.StabilizeStatisticsCycle != nil {
								projectInstanceStatisticsAlarmInfoListMap["stabilize_statistics_cycle"] = projectInstanceStatisticsAlarmInfoList.StabilizeStatisticsCycle
							}

							if projectInstanceStatisticsAlarmInfoList.IsCumulant != nil {
								projectInstanceStatisticsAlarmInfoListMap["is_cumulant"] = projectInstanceStatisticsAlarmInfoList.IsCumulant
							}

							if projectInstanceStatisticsAlarmInfoList.InstanceCount != nil {
								projectInstanceStatisticsAlarmInfoListMap["instance_count"] = projectInstanceStatisticsAlarmInfoList.InstanceCount
							}

							projectInstanceStatisticsAlarmInfoListList = append(projectInstanceStatisticsAlarmInfoListList, projectInstanceStatisticsAlarmInfoListMap)
						}

						alarmRuleDetailMap["project_instance_statistics_alarm_info_list"] = projectInstanceStatisticsAlarmInfoListList
					}
					reconciliationExtInfoList := make([]map[string]interface{}, 0, len(items.AlarmRuleDetail.ReconciliationExtInfo))
					if items.AlarmRuleDetail.ReconciliationExtInfo != nil {
						for _, reconciliationExtInfo := range items.AlarmRuleDetail.ReconciliationExtInfo {
							reconciliationExtInfoMap := map[string]interface{}{}

							if reconciliationExtInfo.RuleType != nil {
								reconciliationExtInfoMap["rule_type"] = reconciliationExtInfo.RuleType
							}

							if reconciliationExtInfo.MismatchCount != nil {
								reconciliationExtInfoMap["mismatch_count"] = reconciliationExtInfo.MismatchCount
							}

							if reconciliationExtInfo.Hour != nil {
								reconciliationExtInfoMap["hour"] = reconciliationExtInfo.Hour
							}

							if reconciliationExtInfo.Min != nil {
								reconciliationExtInfoMap["min"] = reconciliationExtInfo.Min
							}

							reconciliationExtInfoList = append(reconciliationExtInfoList, reconciliationExtInfoMap)
						}

						alarmRuleDetailMap["reconciliation_ext_info"] = reconciliationExtInfoList
					}
					itemsMap["alarm_rule_detail"] = []interface{}{alarmRuleDetailMap}
				}

				if items.AlarmLevel != nil {
					itemsMap["alarm_level"] = items.AlarmLevel
				}

				if items.OwnerUin != nil {
					itemsMap["owner_uin"] = items.OwnerUin
				}

				if items.BundleId != nil {
					itemsMap["bundle_id"] = items.BundleId
				}

				if items.BundleInfo != nil {
					itemsMap["bundle_info"] = items.BundleInfo
				}

				alarmGroupsList := make([]map[string]interface{}, 0, len(items.AlarmGroups))
				if items.AlarmGroups != nil {
					for _, alarmGroups := range items.AlarmGroups {
						alarmGroupsMap := map[string]interface{}{}

						if alarmGroups.AlarmEscalationRecipientIds != nil {
							alarmGroupsMap["alarm_escalation_recipient_ids"] = alarmGroups.AlarmEscalationRecipientIds
						}

						if alarmGroups.AlarmEscalationInterval != nil {
							alarmGroupsMap["alarm_escalation_interval"] = alarmGroups.AlarmEscalationInterval
						}

						notificationFatigueMap := map[string]interface{}{}

						if alarmGroups.NotificationFatigue != nil {
							if alarmGroups.NotificationFatigue.NotifyCount != nil {
								notificationFatigueMap["notify_count"] = alarmGroups.NotificationFatigue.NotifyCount
							}

							if alarmGroups.NotificationFatigue.NotifyInterval != nil {
								notificationFatigueMap["notify_interval"] = alarmGroups.NotificationFatigue.NotifyInterval
							}

							quietIntervalsList := make([]map[string]interface{}, 0, len(alarmGroups.NotificationFatigue.QuietIntervals))
							if alarmGroups.NotificationFatigue.QuietIntervals != nil {
								for _, quietIntervals := range alarmGroups.NotificationFatigue.QuietIntervals {
									quietIntervalsMap := map[string]interface{}{}

									if quietIntervals.DaysOfWeek != nil {
										quietIntervalsMap["days_of_week"] = quietIntervals.DaysOfWeek
									}

									if quietIntervals.StartTime != nil {
										quietIntervalsMap["start_time"] = quietIntervals.StartTime
									}

									if quietIntervals.EndTime != nil {
										quietIntervalsMap["end_time"] = quietIntervals.EndTime
									}

									quietIntervalsList = append(quietIntervalsList, quietIntervalsMap)
								}

								notificationFatigueMap["quiet_intervals"] = quietIntervalsList
							}
							alarmGroupsMap["notification_fatigue"] = []interface{}{notificationFatigueMap}
						}

						if alarmGroups.AlarmWays != nil {
							alarmGroupsMap["alarm_ways"] = alarmGroups.AlarmWays
						}

						webHooksList := make([]map[string]interface{}, 0, len(alarmGroups.WebHooks))
						if alarmGroups.WebHooks != nil {
							for _, webHooks := range alarmGroups.WebHooks {
								webHooksMap := map[string]interface{}{}

								if webHooks.AlarmWay != nil {
									webHooksMap["alarm_way"] = webHooks.AlarmWay
								}

								if webHooks.WebHooks != nil {
									webHooksMap["web_hooks"] = webHooks.WebHooks
								}

								webHooksList = append(webHooksList, webHooksMap)
							}

							alarmGroupsMap["web_hooks"] = webHooksList
						}
						if alarmGroups.AlarmRecipientType != nil {
							alarmGroupsMap["alarm_recipient_type"] = alarmGroups.AlarmRecipientType
						}

						if alarmGroups.AlarmRecipientIds != nil {
							alarmGroupsMap["alarm_recipient_ids"] = alarmGroups.AlarmRecipientIds
						}

						alarmGroupsList = append(alarmGroupsList, alarmGroupsMap)
					}

					itemsMap["alarm_groups"] = alarmGroupsList
				}

				ids = append(ids, strings.Join([]string{projectId, alarmRuleId}, tccommon.FILED_SP))
				itemsList = append(itemsList, itemsMap)
			}

			dataMap["items"] = itemsList
		}
		_ = d.Set("data", []interface{}{dataMap})
	}

	d.SetId(helper.DataResourceIdsHash(ids))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), dataMap); e != nil {
			return e
		}
	}

	return nil
}
