// Code generated by iacg; DO NOT EDIT.
package tcss

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	tcssv20201101 "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/tcss/v20201101"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTcssImageRegistry() *schema.Resource {
	return &schema.Resource{
		DeprecationMessage: "This resource has been deprecated in Terraform TencentCloud provider version 1.82.23.",
		Create:             resourceTencentCloudTcssImageRegistryCreate,
		Read:               resourceTencentCloudTcssImageRegistryRead,
		Update:             resourceTencentCloudTcssImageRegistryUpdate,
		Delete:             resourceTencentCloudTcssImageRegistryDelete,
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Repository name.",
			},

			"username": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Username.",
			},

			"password": {
				Type:        schema.TypeString,
				Required:    true,
				Sensitive:   true,
				Description: "Password.",
			},

			"url": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Repository URL.",
			},

			"registry_type": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Repository type, which can be `harbor`. Valid values: harbor, quay, jfrog, aws, azure, other-tcr.",
			},

			"net_type": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Network type, which can be `public` (public network).",
			},

			"registry_version": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Repository version.",
			},

			"registry_region": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Region. Default value: `default`.",
			},

			"speed_limit": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Speed limit.",
			},

			"insecure": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Valid values: `0` (secure mode with certificate verification, which is the default value); `1` (unsecure mode that skips certificate verification).",
			},

			"conn_detect_config": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: "Connectivity detection configuration.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"quuid": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Host Quuid.",
						},
						"uuid": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Host uuid.",
						},
					},
				},
			},

			"need_scan": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Whether to scan the latest image.",
			},

			"sync_status": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Sync status.",
			},
		},
	}
}

func resourceTencentCloudTcssImageRegistryCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_tcss_image_registry.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		registryId int64
	)
	var (
		request  = tcssv20201101.NewAddAssetImageRegistryRegistryDetailRequest()
		response = tcssv20201101.NewAddAssetImageRegistryRegistryDetailResponse()
	)

	if v, ok := d.GetOk("name"); ok {
		request.Name = helper.String(v.(string))
	}

	if v, ok := d.GetOk("username"); ok {
		request.Username = helper.String(v.(string))
	}

	if v, ok := d.GetOk("password"); ok {
		request.Password = helper.String(v.(string))
	}

	if v, ok := d.GetOk("url"); ok {
		request.Url = helper.String(v.(string))
	}

	if v, ok := d.GetOk("registry_type"); ok {
		request.RegistryType = helper.String(v.(string))
	}

	if v, ok := d.GetOk("registry_version"); ok {
		request.RegistryVersion = helper.String(v.(string))
	}

	if v, ok := d.GetOk("net_type"); ok {
		request.NetType = helper.String(v.(string))
	}

	if v, ok := d.GetOk("registry_region"); ok {
		request.RegistryRegion = helper.String(v.(string))
	}

	if v, ok := d.GetOkExists("speed_limit"); ok {
		request.SpeedLimit = helper.IntInt64(v.(int))
	}

	if v, ok := d.GetOkExists("insecure"); ok {
		request.Insecure = helper.IntUint64(v.(int))
	}

	if v, ok := d.GetOk("conn_detect_config"); ok {
		for _, item := range v.(*schema.Set).List() {
			connDetectConfigMap := item.(map[string]interface{})
			connDetectConfig := tcssv20201101.ConnDetectConfig{}
			if v, ok := connDetectConfigMap["quuid"]; ok {
				connDetectConfig.Quuid = helper.String(v.(string))
			}
			if v, ok := connDetectConfigMap["uuid"]; ok {
				connDetectConfig.Uuid = helper.String(v.(string))
			}
			request.ConnDetectConfig = append(request.ConnDetectConfig, &connDetectConfig)
		}
	}

	if v, ok := d.GetOkExists("need_scan"); ok {
		request.NeedScan = helper.Bool(v.(bool))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTcssV20201101Client().AddAssetImageRegistryRegistryDetailWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create tcss image registry failed, reason:%+v", logId, err)
		return err
	}

	registryId = *response.Response.RegistryId

	d.SetId(helper.Int64ToStr(registryId))

	return resourceTencentCloudTcssImageRegistryRead(d, meta)
}

func resourceTencentCloudTcssImageRegistryRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_tcss_image_registry.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	if err := resourceTencentCloudTcssImageRegistryReadOnStart(ctx); err != nil {
		return err
	}

	registryId := d.Id()

	_ = registryId
	_ = ctx
	return nil
}

func resourceTencentCloudTcssImageRegistryUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_tcss_image_registry.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	immutableArgs := []string{"name", "need_scan"}
	for _, v := range immutableArgs {
		if d.HasChange(v) {
			return fmt.Errorf("argument `%s` cannot be changed", v)
		}
	}
	registryId := d.Id()

	needChange := false
	mutableArgs := []string{"username", "password", "url", "registry_type", "registry_version", "net_type", "registry_region", "speed_limit", "insecure", "conn_detect_config"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := tcssv20201101.NewUpdateAssetImageRegistryRegistryDetailRequest()

		if v, ok := d.GetOk("username"); ok {
			request.Username = helper.String(v.(string))
		}

		if v, ok := d.GetOk("password"); ok {
			request.Password = helper.String(v.(string))
		}

		if v, ok := d.GetOk("url"); ok {
			request.Url = helper.String(v.(string))
		}

		if v, ok := d.GetOk("registry_type"); ok {
			request.RegistryType = helper.String(v.(string))
		}

		if v, ok := d.GetOk("registry_version"); ok {
			request.RegistryVersion = helper.String(v.(string))
		}

		if v, ok := d.GetOk("net_type"); ok {
			request.NetType = helper.String(v.(string))
		}

		if v, ok := d.GetOk("registry_region"); ok {
			request.RegistryRegion = helper.String(v.(string))
		}

		if v, ok := d.GetOkExists("speed_limit"); ok {
			request.SpeedLimit = helper.IntInt64(v.(int))
		}

		if v, ok := d.GetOkExists("insecure"); ok {
			request.Insecure = helper.IntUint64(v.(int))
		}

		if v, ok := d.GetOk("conn_detect_config"); ok {
			for _, item := range v.(*schema.Set).List() {
				connDetectConfigMap := item.(map[string]interface{})
				connDetectConfig := tcssv20201101.ConnDetectConfig{}
				if v, ok := connDetectConfigMap["quuid"]; ok {
					connDetectConfig.Quuid = helper.String(v.(string))
				}
				if v, ok := connDetectConfigMap["uuid"]; ok {
					connDetectConfig.Uuid = helper.String(v.(string))
				}
				request.ConnDetectConfig = append(request.ConnDetectConfig, &connDetectConfig)
			}
		}

		request.RegistryId = helper.StrToInt64Point(registryId)

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			if err := resourceTencentCloudTcssImageRegistryUpdatePreRequest0(ctx, request); err != nil {
				return err
			}

			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTcssV20201101Client().UpdateAssetImageRegistryRegistryDetailWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update tcss image registry failed, reason:%+v", logId, err)
			return err
		}
	}

	return resourceTencentCloudTcssImageRegistryRead(d, meta)
}

func resourceTencentCloudTcssImageRegistryDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_tcss_image_registry.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	registryId := d.Id()

	var (
		request  = tcssv20201101.NewRemoveAssetImageRegistryRegistryDetailRequest()
		response = tcssv20201101.NewRemoveAssetImageRegistryRegistryDetailResponse()
	)

	request.RegistryId = helper.StrToInt64Point(registryId)

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTcssV20201101Client().RemoveAssetImageRegistryRegistryDetailWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete tcss image registry failed, reason:%+v", logId, err)
		return err
	}

	_ = response
	return nil
}
