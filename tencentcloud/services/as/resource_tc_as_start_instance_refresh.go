// Code generated by iacg; DO NOT EDIT.
package as

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	as "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/as/v20180419"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudAsStartInstanceRefresh() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudAsStartInstanceRefreshCreate,
		Read:   resourceTencentCloudAsStartInstanceRefreshRead,
		Delete: resourceTencentCloudAsStartInstanceRefreshDelete,
		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(5 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"auto_scaling_group_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Scaling group ID.",
			},
			"refresh_settings": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "Refresh settings.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"check_instance_target_health": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Backend service health check status for instances, defaults to FALSE. This setting takes effect only for scaling groups bound with application load balancers. When enabled, if an instance fails the check after being refreshed, its load balancer port weight remains 0 and is marked as a refresh failure. Valid values: <br><li>TRUE: Enable the check.</li> <li>FALSE: Do not enable the check.",
						},
						"rolling_update_settings": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Rolling update settings parameters. RefreshMode is the rolling update. This parameter must be filled in.Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"batch_number": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Batch quantity. The batch quantity should be a positive integer greater than 0, but cannot exceed the total number of instances pending refresh.",
									},
									"batch_pause": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Pause policy between batches. Default value: Automatic. Valid values: <br><li>FIRST_BATCH_PAUSE: Pause after the first batch update completes.</li> <li>BATCH_INTERVAL_PAUSE: Pause between each batch update.</li> <li>AUTOMATIC: No pauses.",
									},
									"max_surge": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Maximum Extra Quantity. After setting this parameter, a batch of pay-as-you-go extra instances will be created according to the launch configuration before the rolling update starts, and the extra instances will be destroyed after the rolling update is completed.",
									},
									"fail_process": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Failure Handling Policy. The default value is `AUTO_PAUSE`. The values are as follows, `AUTO_PAUSE`: Pause after refresh fails; `AUTO_ROLLBACK`: Roll back after refresh fails; `AUTO_CANCEL`: Cancel after refresh fails.",
									},
								},
							},
						},
						"check_instance_target_health_timeout": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The timeout period for backend service health status checks, in seconds. The valid range is [60, 7200], with a default value of 1800 seconds. This takes effect only when the CheckInstanceTargetHealth parameter is enabled. If the instance health check times out, it will be marked as a refresh failure.",
						},
					},
				},
			},
			"refresh_mode": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Refresh mode. Value range: ROLLING_UPDATE_RESET: Reinstall the system for rolling update; ROLLING_UPDATE_REPLACE: Create a new instance for rolling update. This mode does not support the rollback interface yet.",
			},
		},
	}
}

func resourceTencentCloudAsStartInstanceRefreshCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId             = tccommon.GetLogId(tccommon.ContextNil)
		ctx               = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		request           = as.NewStartInstanceRefreshRequest()
		response          = as.NewStartInstanceRefreshResponse()
		waitRequest       = as.NewDescribeRefreshActivitiesRequest()
		refreshActivityId string
	)

	if v, ok := d.GetOk("auto_scaling_group_id"); ok {
		request.AutoScalingGroupId = helper.String(v.(string))
	}

	if refreshSettingsMap, ok := helper.InterfacesHeadMap(d, "refresh_settings"); ok {
		refreshSettings := as.RefreshSettings{}
		if v, ok := refreshSettingsMap["check_instance_target_health"]; ok {
			refreshSettings.CheckInstanceTargetHealth = helper.Bool(v.(bool))
		}

		if rollingUpdateSettingsMap, ok := helper.ConvertInterfacesHeadToMap(refreshSettingsMap["rolling_update_settings"]); ok {
			rollingUpdateSettings := as.RollingUpdateSettings{}
			if v, ok := rollingUpdateSettingsMap["batch_number"]; ok {
				rollingUpdateSettings.BatchNumber = helper.IntUint64(v.(int))
			}

			if v, ok := rollingUpdateSettingsMap["batch_pause"]; ok && v != "" {
				rollingUpdateSettings.BatchPause = helper.String(v.(string))
			}

			if v, ok := rollingUpdateSettingsMap["max_surge"]; ok {
				rollingUpdateSettings.MaxSurge = helper.IntInt64(v.(int))
			}

			if v, ok := rollingUpdateSettingsMap["fail_process"]; ok && v != "" {
				rollingUpdateSettings.FailProcess = helper.String(v.(string))
			}

			refreshSettings.RollingUpdateSettings = &rollingUpdateSettings
		}

		if v, ok := refreshSettingsMap["check_instance_target_health_timeout"]; ok && v != 0 {
			refreshSettings.CheckInstanceTargetHealthTimeout = helper.IntUint64(v.(int))
		}

		request.RefreshSettings = &refreshSettings
	}

	if v, ok := d.GetOk("refresh_mode"); ok {
		request.RefreshMode = helper.String(v.(string))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseAsClient().StartInstanceRefreshWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || result.Response.RefreshActivityId == nil {
			e = fmt.Errorf("create as start instance refresh failed.")
			return resource.NonRetryableError(e)
		}

		response = result
		return nil
	})

	if err != nil {
		log.Printf("[CRITAL]%s create as start instance refresh failed, reason:%+v", logId, err)
		return err
	}

	refreshActivityId = *response.Response.RefreshActivityId
	d.SetId(refreshActivityId)

	// wait
	waitRequest.RefreshActivityIds = helper.Strings([]string{refreshActivityId})
	err = resource.Retry(d.Timeout(schema.TimeoutCreate), func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseAsClient().DescribeRefreshActivitiesWithContext(ctx, waitRequest)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, waitRequest.GetAction(), waitRequest.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || len(result.Response.RefreshActivitySet) != 1 {
			return resource.NonRetryableError(fmt.Errorf("Create as start instance refresh failed."))
		}

		refreshStatus := result.Response.RefreshActivitySet[0].Status
		refreshActivityId := result.Response.RefreshActivitySet[0].RefreshActivityId
		if refreshStatus == nil || refreshActivityId == nil {
			return resource.NonRetryableError(fmt.Errorf("Status or RefreshActivityId is nil."))
		}

		if *refreshStatus == REFRESH_ACTIVITIES_SUCCESSFUL {
			return nil
		}

		return resource.RetryableError(fmt.Errorf("Start instance refresh is still in running. Status: %s, RefreshActivityId: %s.", *refreshStatus, *refreshActivityId))
	})

	if err != nil {
		log.Printf("[CRITAL]%s create as start instance refresh failed, reason:%+v", logId, err)
		return err
	}

	return resourceTencentCloudAsStartInstanceRefreshRead(d, meta)
}

func resourceTencentCloudAsStartInstanceRefreshRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}

func resourceTencentCloudAsStartInstanceRefreshDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
