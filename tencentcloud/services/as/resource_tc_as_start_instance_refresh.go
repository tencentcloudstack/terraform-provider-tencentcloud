// Code generated by iacg; DO NOT EDIT.
package as

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	as "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/as/v20180419"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudAsStartInstanceRefresh() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudAsStartInstanceRefreshCreate,
		Read:   resourceTencentCloudAsStartInstanceRefreshRead,
		Delete: resourceTencentCloudAsStartInstanceRefreshDelete,
		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(5 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"auto_scaling_group_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Scaling group ID.",
			},
			"refresh_settings": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "Refresh settings.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"check_instance_target_health": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Backend service health check status for instances, defaults to FALSE. This setting takes effect only for scaling groups bound with application load balancers. When enabled, if an instance fails the check after being refreshed, its load balancer port weight remains 0 and is marked as a refresh failure. Valid values: <br><li>TRUE: Enable the check.</li> <li>FALSE: Do not enable the check.",
						},
						"rolling_update_settings": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Rolling update settings parameters. RefreshMode is the rolling update. This parameter must be filled in.Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"batch_number": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Batch quantity. The batch quantity should be a positive integer greater than 0, but cannot exceed the total number of instances pending refresh.",
									},
									"batch_pause": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Pause policy between batches. Default value: Automatic. Valid values: <br><li>FIRST_BATCH_PAUSE: Pause after the first batch update completes.</li> <li>BATCH_INTERVAL_PAUSE: Pause between each batch update.</li> <li>AUTOMATIC: No pauses.",
									},
									"max_surge": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: "Maximum Extra Quantity. After setting this parameter, a batch of pay-as-you-go extra instances will be created according to the launch configuration before the rolling update starts, and the extra instances will be destroyed after the rolling update is completed.",
									},
									"fail_process": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Failure Handling Policy. The default value is `AUTO_PAUSE`. The values are as follows, `AUTO_PAUSE`: Pause after refresh fails; `AUTO_ROLLBACK`: Roll back after refresh fails; `AUTO_CANCEL`: Cancel after refresh fails.",
									},
								},
							},
						},
					},
				},
			},
			"refresh_mode": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Refresh mode, currently, only rolling updates are supported, with the default value being ROLLING_UPDATE_RESET.",
			},
		},
	}
}

func resourceTencentCloudAsStartInstanceRefreshCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId             = tccommon.GetLogId(tccommon.ContextNil)
		ctx               = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		request           = as.NewStartInstanceRefreshRequest()
		response          = as.NewStartInstanceRefreshResponse()
		waitRequest       = as.NewDescribeRefreshActivitiesRequest()
		refreshActivityId string
	)

	if v, ok := d.GetOk("auto_scaling_group_id"); ok {
		request.AutoScalingGroupId = helper.String(v.(string))
	}

	if refreshSettingsMap, ok := helper.InterfacesHeadMap(d, "refresh_settings"); ok {
		refreshSettings := as.RefreshSettings{}
		if v, ok := refreshSettingsMap["check_instance_target_health"]; ok {
			refreshSettings.CheckInstanceTargetHealth = helper.Bool(v.(bool))
		}

		if rollingUpdateSettingsMap, ok := helper.ConvertInterfacesHeadToMap(refreshSettingsMap["rolling_update_settings"]); ok {
			rollingUpdateSettings := as.RollingUpdateSettings{}
			if v, ok := rollingUpdateSettingsMap["batch_number"]; ok {
				rollingUpdateSettings.BatchNumber = helper.IntUint64(v.(int))
			}

			if v, ok := rollingUpdateSettingsMap["batch_pause"]; ok && v != "" {
				rollingUpdateSettings.BatchPause = helper.String(v.(string))
			}

			if v, ok := rollingUpdateSettingsMap["max_surge"]; ok {
				rollingUpdateSettings.MaxSurge = helper.IntInt64(v.(int))
			}

			if v, ok := rollingUpdateSettingsMap["fail_process"]; ok && v != "" {
				rollingUpdateSettings.FailProcess = helper.String(v.(string))
			}

			refreshSettings.RollingUpdateSettings = &rollingUpdateSettings
		}

		request.RefreshSettings = &refreshSettings
	}

	if v, ok := d.GetOk("refresh_mode"); ok {
		request.RefreshMode = helper.String(v.(string))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseAsClient().StartInstanceRefreshWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || result.Response.RefreshActivityId == nil {
			e = fmt.Errorf("create as start instance refresh failed.")
			return resource.NonRetryableError(e)
		}

		response = result
		return nil
	})

	if err != nil {
		log.Printf("[CRITAL]%s create as start instance refresh failed, reason:%+v", logId, err)
		return err
	}

	refreshActivityId = *response.Response.RefreshActivityId
	d.SetId(refreshActivityId)

	// wait
	waitRequest.RefreshActivityIds = helper.Strings([]string{refreshActivityId})
	err = resource.Retry(d.Timeout(schema.TimeoutCreate), func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseAsClient().DescribeRefreshActivitiesWithContext(ctx, waitRequest)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, waitRequest.GetAction(), waitRequest.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || len(result.Response.RefreshActivitySet) != 1 {
			e = fmt.Errorf("create as start instance refresh failed.")
			return resource.NonRetryableError(e)
		}

		if *result.Response.RefreshActivitySet[0].Status == REFRESH_ACTIVITIES_SUCCESSFUL {
			return nil
		}

		return resource.RetryableError(fmt.Errorf("start instance refresh is still in running, state %s", *result.Response.RefreshActivitySet[0].Status))
	})

	if err != nil {
		log.Printf("[CRITAL]%s create as start instance refresh failed, reason:%+v", logId, err)
		return err
	}

	return resourceTencentCloudAsStartInstanceRefreshRead(d, meta)
}

func resourceTencentCloudAsStartInstanceRefreshRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}

func resourceTencentCloudAsStartInstanceRefreshDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
