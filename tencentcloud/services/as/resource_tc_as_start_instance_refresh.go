// Code generated by iacg; DO NOT EDIT.
package as

import (
	"context"
	"fmt"
	"log"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	as "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/as/v20180419"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudAsStartInstanceRefresh() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudAsStartInstanceRefreshCreate,
		Read:   resourceTencentCloudAsStartInstanceRefreshRead,
		Delete: resourceTencentCloudAsStartInstanceRefreshDelete,
		Schema: map[string]*schema.Schema{
			"auto_scaling_group_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Scaling group ID.",
			},
			"refresh_settings": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				MaxItems:    1,
				Description: "Refresh settings.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"check_instance_target_health": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Backend service health check status for instances, defaults to FALSE. This setting takes effect only for scaling groups bound with application load balancers. When enabled, if an instance fails the check after being refreshed, its load balancer port weight remains 0 and is marked as a refresh failure. Valid values: <br><li>TRUE: Enable the check.</li> <li>FALSE: Do not enable the check.",
						},
						"rolling_update_settings": {
							Type:        schema.TypeList,
							Required:    true,
							MaxItems:    1,
							Description: "Rolling update settings parameters. RefreshMode is the rolling update. This parameter must be filled in.Note: This field may return null, indicating that no valid value can be obtained.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"batch_number": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: "Batch quantity. The batch quantity should be a positive integer greater than 0, but cannot exceed the total number of instances pending refresh.",
									},
									"batch_pause": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Pause policy between batches. Default value: Automatic. Valid values: <br><li>FIRST_BATCH_PAUSE: Pause after the first batch update completes.</li> <li>BATCH_INTERVAL_PAUSE: Pause between each batch update.</li> <li>AUTOMATIC: No pauses.",
									},
								},
							},
						},
					},
				},
			},
			"refresh_mode": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "Refresh mode, currently, only rolling updates are supported, with the default value being ROLLING_UPDATE_RESET.",
			},
		},
	}
}

func resourceTencentCloudAsStartInstanceRefreshCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	var (
		logId             = tccommon.GetLogId(tccommon.ContextNil)
		ctx               = tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)
		request           = as.NewStartInstanceRefreshRequest()
		response          = as.NewStartInstanceRefreshResponse()
		waitRequest       = as.NewDescribeRefreshActivitiesRequest()
		refreshActivityId string
	)

	if v, ok := d.GetOk("auto_scaling_group_id"); ok {
		request.AutoScalingGroupId = helper.String(v.(string))
	}

	if refreshSettingsMap, ok := helper.InterfacesHeadMap(d, "refresh_settings"); ok {
		refreshSettings := as.RefreshSettings{}
		if v, ok := refreshSettingsMap["check_instance_target_health"]; ok {
			refreshSettings.CheckInstanceTargetHealth = helper.Bool(v.(bool))
		}

		if rollingUpdateSettingsMap, ok := helper.ConvertInterfacesHeadToMap(refreshSettingsMap["rolling_update_settings"]); ok {
			rollingUpdateSettings := as.RollingUpdateSettings{}
			if v, ok := rollingUpdateSettingsMap["batch_number"]; ok {
				rollingUpdateSettings.BatchNumber = helper.IntUint64(v.(int))
			}

			if v, ok := rollingUpdateSettingsMap["batch_pause"]; ok {
				rollingUpdateSettings.BatchPause = helper.String(v.(string))
			}

			refreshSettings.RollingUpdateSettings = &rollingUpdateSettings
		}

		request.RefreshSettings = &refreshSettings
	}

	if v, ok := d.GetOk("refresh_mode"); ok {
		request.RefreshMode = helper.String(v.(string))
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseAsClient().StartInstanceRefreshWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || result.Response.RefreshActivityId == nil {
			e = fmt.Errorf("create as start instance refresh failed.")
			return resource.NonRetryableError(e)
		}

		response = result
		return nil
	})

	if err != nil {
		log.Printf("[CRITAL]%s create as start instance refresh failed, reason:%+v", logId, err)
		return err
	}

	refreshActivityId = *response.Response.RefreshActivityId
	d.SetId(refreshActivityId)

	// wait
	waitRequest.RefreshActivityIds = helper.Strings([]string{refreshActivityId})
	err = resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseAsClient().DescribeRefreshActivitiesWithContext(ctx, waitRequest)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, waitRequest.GetAction(), waitRequest.ToJsonString(), result.ToJsonString())
		}

		if result == nil || result.Response == nil || len(result.Response.RefreshActivitySet) != 1 {
			e = fmt.Errorf("create as start instance refresh failed.")
			return resource.NonRetryableError(e)
		}

		if *result.Response.RefreshActivitySet[0].Status == REFRESH_ACTIVITIES_SUCCESSFUL {
			return nil
		}

		return resource.RetryableError(fmt.Errorf("start instance refresh is still in running, state %s", *result.Response.RefreshActivitySet[0].Status))
	})

	if err != nil {
		log.Printf("[CRITAL]%s create as start instance refresh failed, reason:%+v", logId, err)
		return err
	}

	return resourceTencentCloudAsStartInstanceRefreshRead(d, meta)
}

func resourceTencentCloudAsStartInstanceRefreshRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}

func resourceTencentCloudAsStartInstanceRefreshDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_as_start_instance_refresh.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	return nil
}
